# 算法（2022-02-13）

[TOC]

## ♥♥算法基础题目

### <font color='green'>1.基础算法</font>

- [x] AcWing 785. 快速排序
- [x] AcWing 786. 第k个数
- [x] AcWing 787. 归并排序
- [x] AcWing 788. 逆序对的数量
- [x] AcWing 789. 数的范围
- [x] AcWing 790. 数的三次方根
- [x] AcWing 791. 高精度加法
- [x] AcWing 792. 高精度减法
- [x] AcWing 793. 高精度乘法
- [x] AcWing 794. 高精度除法
- [x] AcWing 795. 前缀和
- [x] AcWing 796. 子矩阵的和
- [x] AcWing 797. 差分
- [x] AcWing 798. 差分矩阵
- [x] AcWing 799. 最长连续不重复子序列
- [x] AcWing 800. 数组元素的目标和
- [x] AcWing 801. 二进制中1的个数
- [x] AcWing 802. 区间和
- [x] AcWing 803. 区间合并

### <font color='cornflowerblue'>2.数据结构</font>

- [x] AcWing 826. 单链表
- [x] AcWing 827. 双链表
- [x] AcWing 828. 模拟栈
- [x] AcWing 829. 模拟队列
- [x] AcWing 830. 单调栈
- [x] AcWing 154. 滑动窗口
- [x] AcWing 831. KMP字符串
- [x] AcWing 835. Trie字符串统计
- [x] AcWing 143. 最大异或对
- [x] AcWing 836. 合并集合
- [x] AcWing 837. 连通块中点的数量
- [x] AcWing 240. 食物链
- [x] AcWing 838. 堆排序
- [x] AcWing 839. 模拟堆
- [x] AcWing 840. 模拟散列表
- [x] AcWing 841. 字符串哈希

### 3.搜索与图论 

#### DFS

- [x] AcWing 842. 排列数字
- [x] AcWing 843. n-皇后问题

#### BFS

- [x] AcWing 844. 走迷宫
- [x] AcWing 845. 八数码

#### 树与图的深度优先遍历

- [x] AcWing 846. 树的重心

#### 树与图的广度优先遍历

- [x] AcWing 847. 图中点的层次

#### 拓扑排序

- [x] AcWing 848. 有向图的拓扑序列

#### Dijkstra

- [x] AcWing 849. Dijkstra求最短路 I
- [x] AcWing 850. Dijkstra求最短路 II

#### bellman-ford

- [x] AcWing 853. 有边数限制的最短路

#### spfa

- [x] AcWing 851. spfa求最短路
- [x] AcWing 852. spfa判断负环

#### Floyd

- [x] AcWing 854. Floyd求最短路

#### Prim

- [x] AcWing 858. Prim算法求最小生成树

#### Kruskal

- [x] AcWing 859. Kruskal算法求最小生成树

#### 染色法判定二分图

- [x] AcWing 860. 染色法判定二分图

#### 匈牙利算法

- [x] AcWing 861. 二分图的最大匹配

### 4.数学知识

#### 质数

- [x] AcWing 866. 试除法判定质数

- [x] AcWing 867. 分解质因数

- [x] AcWing 868. 筛质数

#### 约数

- [x] AcWing 869. 试除法求约数

- [x] AcWing 870. 约数个数

- [x] AcWing 871. 约数之和

- [x] AcWing 872. 最大公约数
#### 欧拉函数

- [x] AcWing 873. 欧拉函数

- [x] AcWing 874. 筛法求欧拉函数
#### 快速幂

- [x] AcWing 875. 快速幂

- [x] AcWing 876. 快速幂求逆元
#### 扩展欧几里得算法

- [x] AcWing 877. 扩展欧几里得算法

- [x] AcWing 878. 线性同余方程
#### 中国剩余定理

- [x] AcWing 204. 表达整数的奇怪方式
#### 高斯消元

- [x] AcWing 883. 高斯消元解线性方程组

- [x] AcWing 884. 高斯消元解异或线性方程组
#### 求组合数

- [x] AcWing 885. 求组合数 I

- [x] AcWing 886. 求组合数 II

- [x] AcWing 887. 求组合数 III

- [x] AcWing 888. 求组合数 IV

- [x] AcWing 889. 满足条件的01序列
#### 容斥原理

- [x] AcWing 890. 能被整除的数
#### 博弈论

- [x] AcWing 891. Nim游戏

- [x] AcWing 892. 台阶-Nim游戏

- [x] AcWing 893. 集合-Nim游戏

- [x] AcWing 894. 拆分-Nim游戏

### 5.动态规划

#### 背包问题

- [x] AcWing 2. 01背包问题
- [x] AcWing 3. 完全背包问题
- [x] AcWing 4. 多重背包问题
- [x] AcWing 5. 多重背包问题 II
- [x] AcWing 9. 分组背包问题

#### 线性DP

- [x] AcWing 898. 数字三角形
- [x] AcWing 895. 最长上升子序列
- [x] AcWing 896. 最长上升子序列 II
- [x] AcWing 897. 最长公共子序列
- [x] AcWing 902. 最短编辑距离
- [x] AcWing 899. 编辑距离

#### 区间DP

- [x] AcWing 282. 石子合并

#### 计数类DP

- [x] AcWing 900. 整数划分

#### 数位统计DP

- [x] AcWing 338. 计数问题

#### 状态压缩DP

- [x] AcWing 291. 蒙德里安的梦想
- [x] AcWing 91. 最短Hamilton路径

#### 树形DP

- [x] AcWing 285. 没有上司的舞会

#### 记忆化搜索

- [x] AcWing 901. 滑雪

### 6.贪心

### 7.时空复杂度分析



## ♥♥力扣精选

### 1.二分查找

- [x] 33、搜索旋转排序数组
- [x] 34、在排序数组中查找元素的第一个和最后一个位置
- [x] 35、搜索插入位置
- [x] 69、x的平方根
- [x] 74、搜索二维矩阵
- [x] 153、寻找旋转排序数组中的最小值
- [x] 162、寻找峰值
- [x] 275、H指数II
- [x] 278、第一个错误的版本
- [x] 287、寻找重复数

>冲！！！！

### 2.链表专题

- [x] 19删除链表的倒数第N个节点
- [x] 24两两交换链表中的节点
- [x] 25K个一组翻转链表
- [x] 61旋转链表
- [x] 83删除排序链表中的重复元素
- [x] 92反转链表II
- [x] 142环形链表II
- [x] 148排序链表
- [x] 160相交链表
- [x] 206反转链表
- [x] 237删除链表中的节点

### 3.树专题

- [x] 94二叉树的中序遍历
- [x] 98验证二叉搜索树
- [x] 99恢复二叉搜索树
- [x] 100相同的树
- [x] 101对称二叉树
- [x] 102二叉树的层序遍历
- [x] 105从前序与中序遍历序列构造二叉树
- [x] 124二叉树中的最大路径和
- [x] 144二叉树的前序遍历
- [x] 145二叉树的后序遍历
- [x] 173二叉搜索树迭代器
- [x] 236二叉树的最近公共祖先
- [x] 297二叉树的序列化与反序列化
- [x] 543二叉树的直径

### 4.背包专题（acwing）

- [x] 2 0-1背包问题
- [x] 3完全背包问题
- [x] 4多重背包问题I
- [x] 5多重背包问题II
- [x] 6多重背包问题 III
- [x] 7混合背包问题
- [x] 8二维费用的背包问题
- [x] 9分组背包问题
- [x] 10有依赖的背包问题
- [x] 11背包问题求方案数
- [x] 12背包问题求具体方案

### 5.动态规划专题

- [x] 10正则表达式匹配
- [x] 53最大子序和
- [x] 63不同路径 II
- [x] 72编辑距离
- [x] 91解码方法
- [x] 120三角形最小路径和
- [x] 198打家劫舍
- [x] 300最长上升子序列
- [x] 312戳气球
- [x] 337打家劫舍III
- [x] 518零钱兑换II
- [x] 664奇怪的打印机
- [x] 1143最长公共子序列
- [x] AcWing282石子合并
- [x] AcWing285没有上司的舞会
- [x] AcWing286选课

### 6.字符串处理

- [x] 38 外观数列
- [x] 49 字母异位词分组
- [x] 151 翻转字符串里的单词
- [x] 165 比较版本号
- [x] 929 独特的电子邮件地址
- [x] 5 最长回文子串
- [x] 6 Z字形变换
- [x] 3 无重复字符的最长子串
- [x] 208 实现Trie前缀树
- [x] 273 整数转换英文表示

### 7.搜索DFS_BFS_回溯

- [x]  17 电话号码的字母组合
- [x]  79 单词搜索
- [x]  46 全排列
- [x]  47 全排列II
- [x]  78 子集
- [x]  90 子集II
- [x]  216 组合总和III
- [x]  52 N皇后II
- [x]  37 解数独
- [x]  473 火柴拼正方形

### 8.滑动窗口_双指针_单调队列

- [x]  167 两数之和 II - 输入有序数组
- [x]  88 合并两个有序数组
- [x]  26 删除排序数组中的重复项
- [x]  76 最小覆盖子串
- [x]  32 最长有效括号
- [x]  155 最小栈
- [x]  84 柱状图中最大的矩形
- [x]  42 接雨水
- [x]  239 滑动窗口最大值
- [x]  918 环形子数组的最大和

### 9.基本数据结构

- [x]  1 两数之和
- [x]  187 重复的DNA序列
- [x]  706 设计哈希映射
- [x]  652 寻找重复的子树
- [x]  560 和为K的子数组
- [x]  547 并查集
- [x]  684 冗余连接
- [x]  692 前k个高频单词
- [x]  295 数据流的中位数
- [x]  352 将数据流变为多个不相交区间



## 一.基础算法

### 1.排序

#### 1.1 快速排序算法模板

**[题目：]()**

```
题目:
给定你一个长度为n的整数数列。
请你使用快速排序对这个数列按照从小到大进行排序。
并将排好序的数列按顺序输出。

输入格式
输入共两行，第一行包含整数 n。
第二行包含 n 个整数（所有整数均在1~10^9范围内），表示整个数列。

输出格式
输出共一行，包含 n 个整数，表示排好序的数列。
数据范围
1≤n≤100000
输入样例：
5
3 1 2 4 5
输出样例：
1 2 3 4 5
```

**题解：**

```
快速排序-----分治思想  O(nlogn)
 1.确定分界点q[l],q[l+r/2],q[r]，随机一个都可以当作分界点
 2.调整区间以x为分界,让<=x的在左边;>=x的在右边
 解1：
    2.1 两个数组a[],b[]
    2.2 q[l--r]     q[i]<=x     x---->a[]
                    q[i]>=x     x---->b[]
    2.3 a[]放q[]，b[]放q[]
 解2：(双指针):
    左边i,右边j；i左边所有的数都<=x，j右边数都是>=x
    
 3.递归处理左右两段左右排序再拼一起
```

**代码：**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int n;
int q[N];

void quick_sort(int q[], int l, int r)
{
    //只有一个数或者没有数的时候直接return
    if (l>=r) return;
    //边界的左右两边
    //第一次的时候i和j都向两边移动所以i和j的初始值为i=l-1，j=r+1
    int i=l-1,j=r+1,x=q[l+r>>1];
    while(i<j)
    {
        do i ++; while(q[i]<x);
        do j --; while(q[j]>x);
        //如果指针没有相遇就交换两个数据
        if(i<j) swap(q[i],q[j]);
    }
    quick_sort(q,l,j), quick_sort(q,j+1,r);
}
/*
//递归是j的话不能取到q[r]
void quick_sort(int q[],int l,int r){
    if(l>=r) return;
    int x=q[l],i=l-1,j=r+1;
    while(i<j){
        do i++;while(q[i]<x);
        do j--;while(q[j]>x);
        if(i<j) swap(q[i],q[j]);
    }
    quick_sort(q,l,j);
    quick_sort(q,j+1,r);
}


//递归用i的话,边界不能取到q[l],会死循环  eg.1 2的时候
void quick_sort(int q[],int l,int r){
    if(l>=r) return;
    int x=q[(l+r+1)/2],i=l-1,j=r+1;
    //int x=q[(l+r)/2],i=l-1,j=r+1;
    while(i<j){
        do i++;while(q[i]<x);
        do j--;while(q[j]>x);
        if(i<j) swap(q[i],q[j]);
    }
    quick_sort(q,l,i-1);
    quick_sort(q,i,r);
}
*/
int main(){
    scanf("%d",&n);
    for(int i=0;i<n;i++){
        scanf("%d",&q[i]);
    }
    quick_sort(q,0,n-1);
    for(int i=0;i<n;i++){
        printf("%d ",q[i]);
    }
    return 0;
}
```
#### （1）例题1

[ P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)

#### （2）例题2快速选择

**[题目：]()**

```
题目:
给定一个长度为n的整数数列，以及一个整数k，
请用快速选择算法求出数列的第k小的数是多少。
输入格式：
第一行包含两个整数 n和k。
第二行包含n个整数(所有整数均在1~109范围内)，表示整数数列。
输出格式：
输出一个整数，表示数列的第k小数。
数据范围：
1≤n≤100000,1≤k≤n
输入样例：
5 3
2 4 1 5 3
输出样例：
3
```

**题解：**
```
一、快排：O(NlogN)
 快速排序-----分治思想  O(nlogn)
 1.确定分界点q[l],q[l+r/2],q[r]，随机
 2.调整区间以x为分界,让Left<=x在左边;Right>=x在右边
 3.递归处理左右两段左右排序再拼一起
 二、快速选择：O(N)
 1.k<=Sl,递归Left
 2.k>Sl,递归Right,k-Sl
 sl左边数的个数
```

**代码：**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=100010;
int n,k;
int q[N];

int quick_sort(int l,int r,int k){
    if(l==r) return q[l];
    int x=q[l],i=l-1,j=r+1;
    while(i<j){
        while(q[++i]<x);
        while(q[--j]>x);
        if(i<j) swap(q[i],q[j]);
    }
    //左边Left的数l----j----r
    int sl=j-l+1;
    if(k<=sl) return quick_sort(l,j,k);
    //找第K个数，左边sl个数，右边k-sl个数
    return quick_sort(j+1,r,k-sl);
}

int main(){
    cin>>n>>k;
    for(int i=0;i<n;i++) cin>>q[i];
    cout<<quick_sort(0,n-1,k)<<endl;
}
```

#### 1.2 归并排序算法模板

**[题目：]()**

``` 
题目描述:
给定你一个长度为n的整数数列。
请你使用归并排序对这个数列按照从小到大进行排序。
并将排好序的数列按顺序输出。

输入格式
输入共两行，第一行包含整数 n。
第二行包含 n 个整数（所有整数均在1~10^9范围内），表示整个数列。

输出格式
输出共一行，包含 n 个整数，表示排好序的数列。

数据范围
1≤n≤100000
输入样例：
5
3 1 2 4 5
输出样例：
1 2 3 4 5
```

**题解：**

``` 
归并排序---分治(稳定排序)  O(nlogn)
1.以数组下标中间分开为左边和右边：mid=(l+r)/2
2.递归排序left,right
3.归并合二为一    
    双指针
    ----------
    i  1 3 5 7 9 
    j  2 4 5 8 10
    ----------
    比较a[i],b[j]大小，小的放进res[];
    若a[i]<b[j]则a[i]放res[],i++;
    若a[i]>b[j]则b[j]放res[],j++;
    若a[i]==a[b],则两个任意一个都可以放进res[]
    i先完后面把b[j]后面加res[];
    j先完后面把a[i]后面加res[];
```

**代码：**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int n;
int a[N],temp[N];   //temp[]为辅助空间
void merge_sort(int a[],int l,int r){
    //1个或者0个数
    if(l>=r) return;
    
    //(1)确定中间点
    int mid=l+r>>1;
    //(2)递归排序
    merge_sort(a,l,mid);
    merge_sort(a,mid+1,r);

    //(3)归并
    //k表示当前合并了几个数了,也就是temp里面有几个数了;i,j是两指针起点
    int k=0,i=l,j=mid+1;    
    while(i<=mid && j<=r){
        if(a[i]<a[j]) temp[k++]=a[i++];
        else temp[k++]=a[j++];
    }
    //左边没有循环完
    while(i<=mid) temp[k++]=a[i++];
    //右边没有循环完
    while(j<=r) temp[k++]=a[j++];

    for(i=l,j=0;i<=r;i++,j++){
        a[i]=temp[j];
    }
}
int main(){
    scanf("%d",&n);
    for(int i=0;i<n;i++) scanf("%d",&a[i]);
    merge_sort(a,0,n-1);
    for(int i=0;i<n;i++) printf("%d ",a[i]);
    return 0;
}
```



### 2.二分

#### 2.1 整数二分算法模板 
**[题目：]()**

``` 
题目描述:
给定一个按照升序排列的长度为n的整数数组，以及q个查询。
对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。
如果数组中不存在该元素，则返回“-1 -1”。

输入格式
第一行包含整数n和q，表示数组长度和询问个数。
第二行包含n个整数（均在1~10000范围内），表示完整数组。
接下来q行，每行包含一个整数k，表示一个询问元素。

输出格式
共q行，每行包含两个整数，表示所求元素的起始位置和终止位置。

如果数组中不存在该元素，则返回“-1 -1”。

数据范围
1≤n≤100000
1≤q≤10000
1≤k≤10000
输入样例：
6 3
1 2 2 3 3 4
3
4
5
输出样例：
3 4
5 5
-1 -1
```
**题解：**

``` 
二分的本质是边界二段性：
    在某区间定义了某一种性质，一边满足该性质，另外一边不满足该性质，则二分能找到满足该性质的边界
      
一.区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：mid在右边,找下边界  
    l-----mid(true)----下边界，上边界---mid(false)-----r
        左半边不满足性质               右半边满足性质
1.mid=l+r+1>>1   if(check(mid))  1.1 true   要找的下边界在{mid,r}
											包含mid(mid在整个左半边区间都能取到可能是下边界)   											 更新 l=mid;  mid在下边界的左边
                                 1.2 false  要找的边界在{l,mid-1}不包含mid  
                                            更新 r=mid-1
2.eg:当l=r-1,若mid=l+r>>1,则此时mid=l，会死循环
             若mid=l+r+1>>1,则此时mid=r，正确
             
3.模板:找下边界(左边)--->l=mid
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：左边
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;   //l=mid的情况，中间点的更新方式是m=(l+r+1)/2
        else r = mid - 1;
    }
    return l;
}

二.区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：mid在左边,找上边界  
    l-----mid(false)----下边界，上边界---mid(true)-----r
          左半边不满足性质              右半边满足性质           
1.mid=l+r>>1    if(check(mid))   1.1 true    要找的上边界在{l,mid}包含mid    
                                             更新 r=mid ;mid在上边界的右边
                                 1.2 false   要找的边界在{mid+1,r}不包含mid 
                                             更新 l=mid+1
2.模板:找上边界(右边)--->r=mid
// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：右边
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // r=mid的情况，中间点的更新方式是m=(l+r)/2
        else l = mid + 1;
    }
    return l;
}
```
```
需要写两个二分，一个需要找到>=x的第一个数，另一个需要找到<=x的最后一个数。
1.查找不小于x的第一个位置-->找上边界(右边)--->l---x---mid(true)----r
2.查找不大于x的最后一个位置-->找下边界(左边)
```

**代码：**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,m;
int a[N];
int main(){
    scanf("%d%d",&n,&m);
    for(int i=0;i<n;i++) scanf("%d",&a[i]);
    while(m--){
        int x;
        scanf("%d",&x);
        int l=0,r=n-1;
        //二分起始坐标
        //相当于找x的上边界在右边
        while(l<r){
            int mid=l+r>>1;
            //a[0]---x---mid(true)--a[l-1]如果满足的话check则mid在边界x(要找的数)的右边
            //当a[mid] >= x时，说明mid及其左边可能含有值为x的元素
            //当a[mid]小于x时，令l = mid + 1，mid及其左边的位置被排除了，可能出现解的位置是mid + 1及其后面的位置；
            if(a[mid]>=x) r=mid;
            else l=mid+1;
        }
        //上面的while结束时候l==r
        if(a[l]!=x)  cout<<"-1 -1"<<endl;   
        else{
            //相当于在左边
            cout<<l<<" ";
            int l=0,r=n-1;
            while(l<r){
               int mid=l+r+1>>1;
                //a[0]---mid(true)---x--a[l-1]如果满足的话check则mid在边界x(要找的数)的左边
               if(a[mid]<=x) l=mid;  
               else r=mid-1;
            }
            cout<<l<<endl;
        }
    }
    return 0;
}
```
#### 2.2 浮点数二分算法模板
**[题目：]()**

``` 
求一个数的开平方根
```
**题解：**

``` 
1.直接迭代一百次
　　while(right - left > eps)  　{ ... }
　　或者：
　　for(int i = 0; i < 100; i++) { ... }

2.求误差在某一个范围（比要求的经度值大2）
const double eps =1e-7;        //精度eps
while(r - l> eps){     
      double mid = l+r>>1;
      if (check(mid)) r = mid;           //判定，然后继续二分
      else            l = mid;
}
或者：
for(int i = 0; i < 100; i++) {
	  double mid = l+r>>1;
      if (check(mid)) r = mid;           //判定，然后继续二分
      else            l = mid;
}
```

**代码：**

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    double x;
    cin>>x;
    double l=0,r=x;
    //比要求的经度值大2
    while(r-l>1e-8){
        double mid=(l+r)/2;
        if(mid*mid>=x) r=mid;
        else l=mid;
    }
    /*
    或者直接迭代一百次
    for(int i=0;i<100;i++){
        double mid=(l+r)/2;
        if(mid*mid>=x) r=mid;
        else l=mid;
    }*/
    printf("%lf\n",l);
    return 0;
}
```

#### ps:[推荐博客1](https://blog.csdn.net/weixin_43914593/article/details/103250854?spm=1001.2014.3001.5502)    [推荐博客2](https://www.acwing.com/solution/content/8235/)



### 3.高精度

####  3.1 几种常见的情况:

#### （1）A+B  位数1e6

#### （2）A-B   位数1e6

#### （3）A*b   len(A)<=1e6 ,b<=1e9

####　（4）A/B



#### 3.2 步骤：

#### （1）大整数存储(逆序存储)

#### （2）计算



#### 3.3 高精度加法
**[题目：]()**

``` 
题目：
现在有一个简单的问题，给你两个正整数A和B，你需要计算出A+B 的结果。不过要注意哦，这两个正整数非常大。
输入描述:
输入两个正整数A和 B ，A和 B的位数不超过 1000000。
输出描述:
输出 A+B，结果占一行。
数据范围：
1<=参数长度<=1e6；
```
**题解：**

``` 
和我们笔算加法时一样的思路，注意数据存储的时候时倒着存储的
```

**代码：**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+10;

//加引用加快效率，不加引用的话把整个数组copy一遍，加了不用拷贝;数字存个位到0
vector<int> add(vector<int> &a,vector<int> &b){
    vector<int> c;
    //if(a.size()<b.size()) return add(b,a);
    int t=0;    //表示进位，一开始t为0个位不需要进位
    for(int i=0;i<a.size()||i<b.size();i++){
        if(i<a.size())  t+=a[i];
        if(i<b.size())  t+=b[i];
        c.push_back(t%10);
        t/=10;
    }
    //最后最高位还有没有进位，有的话加上1
    if(t) c.push_back(1);
    return c;
}
int main(){
    string str1,str2;
    vector<int> a,b;
    cin>>str1>>str2;
    //存储进去的是数字
    for(int i=str1.size()-1;i>=0;i--) a.push_back(str1[i]-'0');   //a={6,5,4,3,2,1}
    for(int i=str2.size()-1;i>=0;i--) b.push_back(str2[i]-'0');
    auto c=add(a,b);
    for(int i=c.size()-1;i>=0;i--) printf("%d",c[i]);
    return 0;
}
```
#### 3.4 高精度减法
**[题目：]()**

``` 
题目：
现在有一个简单的问题，给你两个正整数A和B，你需要计算出A-B 的结果。不过要注意哦，这两个正整数非常大。
输入描述:
输入两个正整数A和 B ，A和 B的位数不超过 1000000。
输出描述:
输出 A-B，结果占一行。
数据范围：
1<=参数长度<=1e6；
```
**题解：**

``` 
    A3 A2 A1 A0
 -     B2 B1 B0
----------------
if A>=B
    A-B
else 
    -(B-A)
----------------
Ai-Bi-t   (1)当>=0  Ai-Bi-t
          (2)当<0   Ai-Bi+10-t
t为借为
```

**代码：**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+10;

//判断a>=b
bool cmp(vector<int> &a,vector<int> &b){
    //位数不同的，位数大的数就大，位数小的数就小
    if(a.size()!=b.size()) return a.size()>b.size();
    //位数相同时,需要从大到小
    // for(int i=0;i<A.size();i++){
    //     if(a[i]!=b[i]) 
    //         return a[i]>b[i];
    // }
    for(int i=a.size()-1;i>=0;i--){
        if(a[i]!=b[i])
            return a[i]>b[i];
    }
    
    return true;
}
//  C=A-B
vector<int> sub(vector<int> &a,vector<int> &b){
    vector<int> c;
    for(int i=0,t=0;i<a.size();i++){
        t=a[i]-t;
        //判断Bi是否越界，否则借位
        if(i<b.size()) t-=b[i];
        /*
        (t+10)%10
        （1）t>=0 t本身
        （2）t<0  返回t+10
        */
        c.push_back((t+10)%10);

        //t<0表示Ai不够减需要借位t=1,不需要借位的话t=0
        if(t<0) t=1;
        else t=0;
    }
    //去掉前导0
    while(c.size()>1 && c.back()==0) c.pop_back();  
    return c;
}
int main(){
    string str1,str2;
    cin>>str1>>str2;
    vector<int> a,b;
    for(int i=str1.size()-1;i>=0;i--) a.push_back(str1[i]-'0');
    for(int i=str2.size()-1;i>=0;i--) b.push_back(str2[i]-'0');
    if(cmp(a,b)){
        auto c=sub(a,b);
        for(int i=c.size()-1;i>=0;i--) printf("%d",c[i]);
    }
    else{
        auto c=sub(b,a);
        printf("-");
        for(int i=c.size()-1;i>=0;i--) printf("%d",c[i]);
    }
    return 0;
}
```
#### 3.5 高精度乘低精度
**[题目：]()**

``` 
题目描述：
给定两个正整数A,B，请你计算A*B
输入格式：
共两行，第一行包含正整数A，第二行包含正整数B；
输出格式：
共一行，包含A*B的值；
数据范围：
1<=A长度<=1e6
1<=B<=1e4
```
**题解：**

``` 
       1  2  3     A
*         1  2     B
--------------
   C3 C2 C1 C0
    1  4  7  6
--------------
   C0=(3*12)%10=6
   T1=3*12/10=3
   C1=(2*12+T1)%10=7
   T2=2
   C2=(1*12+T2)%10=4
   T3=1
   C3=1
注意：将B看作一个整体
```

**代码：**

```cpp
#include <bits/stdc++.h>
using namespace std;
vector<int> mul(vector<int> &a,int b){
    vector<int> c;
    int t=0;
    for(int i=0;i<a.size() || t;i++){
        if(i<a.size())
            t+=a[i]*b;
        c.push_back(t%10);  //当前位数字t%10
        t/=10;          //进位t/10
    }
    return c;
}
int main(){
    string a;
    int b;
    cin>>a>>b;
    vector<int> A;
    for(int i=a.size()-1;i>=0;i--) A.push_back(a[i]-'0');
    auto c=mul(A,b);
    for(int i=c.size()-1;i>=0;i--) printf("%d",c[i]);
    return 0;
}
```

#### 3.6 高精度除以低精度
**[题目：]()**

``` 
题目描述
现在给你一个简单的问题，给你两个正整数A和B，你需要计算出A除以B的结果。
不过要注意哦，这里的A非常大，b小。大到老师提醒你们需要使用高精度来做。
输入描述
输入两个正整数A和B，A的位数不超过10000，B的位数不超过100位。
输出描述
输出A除以B的结果，只保留整数部分，结果占一行。
```
**题解：**

``` 
为了统一数据存储，当运算时可能加减乘除都有，所以将除法也逆序存储
```

**代码：**

```cpp
#include <bits/stdc++.h>
using namespace std;

//A/b  商是c,余数是r
vector<int> div(vector<int> &A,int b,int &r){   //r是引用
    vector<int> c;  //c商
    r=0;
    for(int i=A.size()-1;i>=0;i--){
        r=r*10+A[i];
        c.push_back(r/b);
        r%=b;
    }
    reverse(c.begin(),c.end());
    while(c.size()>1 && c.back()==0) c.pop_back();
    return c;
}
int main(){
    string a;
    int b;
    vector<int> A;
    cin>>a>>b;
    for(int i=a.size()-1;i>=0;i--) A.push_back(a[i]-'0');   //记得-'0'
    //r为余数
    int r;
    auto c=div(A,b,r);
    for(int i=c.size()-1;i>=0;i--) printf("%d",c[i]);
    cout<<endl<<r<<endl;
    return 0;
}
```
### 4.前缀和与差分
#### 4.1 一维前缀和
**[题目：]()**

``` 
题目描述：
有长度为n的整数序列，接下来再输入m次询问，每次询问输入一对l,r
对于每个询问，输出序列中从第1个数到r的数的和
输入格式：
第一行包含两个整数n和m
第二行包含n个整数，表示整数数列
接下来m行，每行包含两个整数l和r，表示一个询问得区间范围
输出格式：
共m行，每行输出一个询问的结果
数据范围：
1<=l<=r<=n
1<=n,m<=100000
-1000<=数列中元素的值<=1000
输入样例：
5 3
2 1 3 6 4
1 2 
1 3
2 4
输出样例：
3
6
10
```
**题解：**

``` 
a1 a2 a3 a4 a5 ...an
前缀和：Si=a1+a2+a3+..+ai
数组下标从1开始，Si要从1开始,主要是为了处理边界，比如求解{1，10}则S[10]-S[0]
1.S[i]怎么求   先定义：S[0]=0，后求S[i]=S[i-1]+a[i]
2.S[i]作用     求[l,r]和:S[r]-S[l-1]

S[i] = a[1] + a[2] + ... a[i]
a[l] + ... + a[r] = S[r] - S[l - 1]
```

**代码：**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,m;
int a[N],s[N];
int main(){
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<=n;i++) s[i]=s[i-1]+a[i];
    while(m--){
        int l,r;
        cin>>l>>r;
        cout<<s[r]-s[l-1]<<endl;
    }
    return 0;
}
```
#### 4.2 二维前缀和
**[题目：]()**

``` 
题目描述
JM有一个一个n行m列的整数矩阵.
好奇的JM有q次询问，每个询问包含四个整数x_1, y_1, x_2, y_2，表示一个子矩阵的左上角坐标和右下角坐标。
对于每个询问输出子矩阵中所有数的和。

输入描述
第一行包含三个整数n，m，q。
接下来n行，每行包含m个整数a{ij}，表示整数矩阵。
接下来q行，每行包含四个整数x_1, y_1, x_2, y_2 ，表示一组询问
```
**题解：**

``` 
S[i, j] = 第i行j列格子左上部分所有元素的和
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```

**代码：**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e3+10;
int n,m,q;
int a[N][N],s[N][N];
int main(){
    // ios::sync_with_stdio(false);
    scanf("%d%d%d",&n,&m,&q);
    // cin>>n>>m>>q;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            // cin>>a[i][j];
            scanf("%d",&a[i][j]);

    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];    //求前缀和
    while(q--){
        int x1,y1,x2,y2;
        // cin>>x1>>y1>>x2>>y2;
        scanf("%d %d %d %d",&x1,&y1,&x2,&y2);
        printf("%d\n",s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1]);
        //cout<<s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1]<<endl; //算子矩阵
    }
    return 0;
}
```
#### 4.3 一维差分
**[题目：]()**

``` 
题目：
 输入一个长度为n的整数序列
 接下来输入m个操作，每个操纵包含三个整数l,r,c,表示将序列中的[l,r]之间的每个数加上c.
 请你输出进行完所有操作后的序列。
 输入格式：
 第一行包含两个整数n和m
 第二行包含n个整数，表示整数序列
 接下来m行，每行包含三个整数l,r,c，表示一个操作
 输出格式：
 共一行，包含n个整数，表示的是序列
 数据范围：
 1<=n,m<=100000
 1<=l<=r<=n
 -1000<=c<=1000
 -1000<=整数序列中元素的值<=1000
输入数据：
 6 3
 1 2 2 1 2 1
 1 3 1
 3 5 1
 1 6 1
 输出数据:
 3 4 5 3 4 2
```
**题解：**

``` 
b[i]称为a[i]的差分，a[i]为b[i]的前缀和
    a[1] a[2] a[3] ..a[n]
构造b[1] b[2] b[3] ..b[n]使得a[i]=b[1]+b[2]+...+b[i]
    b[1]=a[1]
    b[2]=a[2]-a[1]
    b[3]=a[3]-a[2]
    .....
    b[n]=a[n]-a[n-1]

 给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c
```

**代码：**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=10010;
int n,m;
int a[N],b[N];

void insert(int l,int r ,int c){
    b[l]+=c;
    b[r+1]-=c;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);

    for(int i=1;i<=n;i++) insert(i,i,a[i]);
    while(m--){
        int l,r,c;
        scanf("%d%d%d",&l,&r,&c);
        insert(l,r,c);
    }
    //求原来数组的值，求差分数组的前缀和得到原数组
    for(int i=1;i<=n;i++) b[i]+=b[i-1];
    for(int i=1;i<=n;i++) printf("%d ",b[i]);
    return 0;
}
```
#### 4.4 二维差分
**[题目：]()**

``` 
题目：
输入一个n行m列的整数矩阵，再输入q个操作，每个操作包含五个整数x1,y1,x2,y2,c,
其中(x1,y1)和(x2,y2)表示一个子矩阵的左上角坐标和右下角坐标
每个操作都要将选中的子矩阵中的每个元素的值都加上c
请您将进行完所有操作的矩阵输出
输入格式：
第一行包含整数n,m,q
接下来n行，每行包含m个整数，表示整数矩阵
接下来q行，每行包含5个整数x1,y1,x2,y2,c,表示一个操作
输出格式：
共n行，每行m个整数，表示所有操作进行完毕后的最终矩阵
数据范围：
1<=n,m<=1000
1<=q<=100000
1<=x1<=x2<=n
1<=y1<=y2<=m
输入数据：
3 4 3
1 2 2 1
3 2 2 1 
1 1 1 1
1 1 2 2 1
1 3 2 3 2
3 1 3 4 1
输出数据：
2 3 4 1
4 3 4 1
2 2 2 2
```
**题解：**

``` 
原矩阵a[i][j]

给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1][y1] += c, 
S[x2+1][y1] -= c, 
S[x1][y2+1] -= c, 
S[x2+1][y2+1] += c
```

**代码：**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1010;
int n,m,q;
int a[N][N],b[N][N];

void insert(int x1,int y1,int x2,int y2,int c){
    b[x1][y1]+=c;
    b[x2+1][y1]-=c;
    b[x1][y2+1]-=c;
    b[x2+1][y2+1]+=c;
}

int main(){
    scanf("%d%d%d",&n,&m,&q);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            scanf("%d",&a[i][j]);
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            insert(i,j,i,j,a[i][j]);
        }
    }
    while(q--){
        int x1,y1,x2,y2,c;
        cin>>x1>>y1>>x2>>y2>>c;
        insert(x1,y1,x2,y2,c);
    }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            printf("%d",b[i][j]);
        }
        puts("");
    } 
    return 0;
}
```

### 5.双指针算法
#### 5.1 双指针算法 
**[题目1：]()**

``` 
题目：
输入字符串，将字符串以空格分开，每行一个字符
```
**题解：**

``` 
for(int i=0,j=0;i<n;i++){
    if(j<n && check(j)) j++;
    //题目逻辑思路
}
for(int i=0;i<n;i++)
    for(int j=0;j<m;j++)
        O(n^2)
运用双指针算法将朴素算法时间复杂度降为O(n)
```

**代码：**

```cpp
#include <iostream>
#include <string.h>
using namespace std;
int main(){
    char str[100];
    gets(str);
    int len=strlen(str);
    for(int i=0;i<len;i++){
        int j=i;
        while(j<len && str[j] !=' ') j++;
        //这道题目的具体逻辑
        for(int k=i;k<j;k++) cout<<str[k];
        cout<<endl;
        //更新i
        i=j;
    }
    return 0;
}
```

**[题目2：]()**

``` 
  题目：
  给定一个长度为n的整数序列，请找出最长的不包含重复数字的连续子序列，输出它的长度
  输入格式：
  第一行包含整数n
  第二行包含n个整数，表示最长的不包含重复数字的连续子序列的长度
  数据范围：
  1<=n<=100000
  输入样例：
  5
  1 2 2 3 4
  输出样例：
  3
```
**题解：**

``` 
for (int i = 0, j = 0; i < n; i ++ )
{
    while (j < i && check(i, j)) j ++ ;
    // 具体问题的逻辑
}
常见问题分类：
    (1) 对于一个序列，用两个指针维护一段区间
    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作
    
//朴素做法：O(n^2)
  for(int i-0;i<n;i++){
      for(int j=0;j<=i;j++){
          if(check(i,j)){
              res=max(res,i-j+1);
          }
      }
  }
```

**代码：**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n;
int a[N],s[N];
int main(){
    cin>>n;
    for(int i=0;i<n;i++) cin>>a[i];
    int res=0;
    //j表示往左边离i最远到什么地方，j------i
    //当i向后面走的时候，j不可能向前面走
    for(int i=0,j=0;i<n;i++){
        s[a[i]]++;
        //新加入的数有重复的话s[a[i]]>1
        while(s[a[i]]>1){
            s[a[j]]--;
            j++;
        }
        res=max(res,i-j+1);
    }
    cout<<res<<endl;
    return 0;
}
```

### 6.位运算

#### 6.1 位运算
**[题目1：]()**

``` 
n的二进制表示中第k位是几
```
**题解：**

``` 
n=15=(1 1 1 1)2
      3 2 1 0
1.先把第k位移动到最后一位   n>>k
2.看个位(最后一位)是几     x&1
```

**代码：**

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n=10; //1010
    //倒着遍历
    for(int i=3;i>=0;i--) cout<<(n>>i & 1);
    return 0;
}
```

**[题目2：二进制中1的个数]()**

``` 
题目：
给定一个长度为n的数列，求出数列中每个数的二进制表示中1的个数
输入：
第一行包含整数n
第二行包含n个整数，表示整数个数列
输出:
共一行，包含N个整数，其中第i个数表示数列中第i个数的二进制中1的个数
数据范围：
1<=n<=1e5
0<=元素值<=1e5
输入：
5
1 2 3 4 5
输出：
1 1 2 1 2
```
**题解：**

``` 
lowbit(x):返回x的最后(最右边)一个1
          x&-x=x&(~x+1) //求补码取反+1
          -x=~x+1  补码
          x=10101010 1 00000
         ~x=01010101 0 11111
       ~x+1=01010101 1 00000
   x&(~x+1)=00000000 1 00000
eg:
x=1010      lowbit(x)=10
x=101000    lowbit(x)=1000
```

**代码：**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n;
int a[N];
int lowbit(int x){
    return x&-x;
}
int main(){
    ios::sync_with_stdio(false);
    cin>>n;
    while(n--){
        int x;
        cin>>x;
        int res=0;
        while(x) x-=lowbit(x),res++;  //每次减去x的最后一位
        cout<<res<<" ";
    }   
    return 0;
}
```

### 7.整数离散化

#### 7.1 离散化
**[题目：]()**

``` 
假定有一个无限长的数轴，数轴上每个坐标上的数据都是0
现在，我们首先进行n次操作，每次操作将某一位置x上的数加c
接下来，进行m次询问，每个询问包含两个整数l和r,你需要求出在区间[l,r]之间的所有数的和
输入格式：
每一行包含两个整数n和m
接下来n行，每行包含两个整数x和c
再接下来m行，每行包含两个整数l和r
输出：
共m行，每行输出一个询问中所求的区间内数字和
输入样例：
3 3
1 2
3 6
7 5
1 3
4 6
7 8
输出样例：
8 
0 
5
```
**题解：**

``` 
离散化：
a[]  1   3   100   2000  50000
     0   1    2     3     4
     
(1)a[]中可能有重复元素-->去重
   unique去重：将数组中所有元素去重，并且返回去重之后元素的尾端点，在erase
(2)如何算出a[]离散化后的值-->二分
    找到第一个>=x的位置
(3)代码

vector<int> alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end()); // 将所有值排序
alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素

// 二分求出x对应的离散化的值
int find(int x) // 找到第一个大于等于x的位置
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1; // 映射到1, 2, ...n
}
```

**代码：**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
const int N=3e5+10;
int n,m;
int a[N],s[N]; //s[]前缀和
vector<int> alls; //存的所有离散化得结果
typedef pair<int,int> PII;
vector<PII> add,query;  //插入操作，求操作
int find(int x){
    int l=0,r=alls.size()-1;
    while(l<r){
        int mid=r+l>>1;
        if(alls[mid]>=x) r=mid;
        else l=mid+1;
    }
    //映射为1,2,3,4...
    return r+1;
}
//自己定义unique 原理(1)它是第一个数 (2)a[i]!=a[i-1]
vector<int>::iterator unique(vector<int> &a){
    int j=0;  
    //遍历所有得数
    for(int i=0;i<a.size();i++)
        if(!i || a[i]!=a[i-1])
            a[j++]=a[i];
    //a[0]=a[j-1] 所有a中不重复的数
    return a.begin()+j;
}
int main(){
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=0;i<n;i++){
        int x,c;
        cin>>x>>c;
        add.push_back({x,c});       
        alls.push_back(x);  //x加到离散化数组里面
    }
    for(int i=0;i<m;i++){
        int l,r;
        cin>>l>>r;
        query.push_back({l,r});
        alls.push_back(l);
        alls.push_back(r);
    }
    //去重
    sort(alls.begin(),alls.end());
    // alls.erase(unique(alls.begin(),alls.end()),alls.end());

    alls.erase(unique(alls),alls.end());
    //处理插入
    for(auto item:add){
        int x=find(item.first);
        a[x]+=item.second;
    }
    //预处理数组和
    for(int i=1;i<=alls.size();i++) s[i]=s[i-1]+a[i];
    //处理查询
    for(auto item:query){
        int l=find(item.first),r=find(item.second);
        cout<<s[r]-s[l-1]<<endl;
    }
    return 0;
}
```

### 8.区间合并
#### 8.1 区间合并
**[题目：]()**

``` 
题目：
给定n个区间[l,r];要求合并所有有交集的区间
注意如果在端点处相交，也算有交集
输出合并完成后的区间个数
如：[1,3]和[2,6]可以合并为一个区间[1,6]
输入格式：
第一行包含整数n
接下来n行,每行包含两个整数l和r
输出格式：
共一行，包含一个整数，表示合并完成后的区间个数
输入：
5
1 2
2 4
5 6
7 8
7 9
输出：
3
数据范围:
1≤n≤100000,
−10^9≤l_i≤r_i≤10^9
```
**题解：**

``` 
1.按照区间左端点排序
2.扫描strt---end,将所有可能的区间合并
```

**代码：**

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef pair<int,int> PII;
const int N=1e5+10;
int n;
vector<PII> a;
void merge(vector<PII> &a){
    vector<PII> res;
    sort(a.begin(),a.end());
    int st=-2e9,ed=-2e9;     //设置边界值
    for(auto it:a){
        if(ed<it.first){
            if(st!=-2e9) res.push_back({st,ed});
            st=it.first,ed=it.second;
        }else{
            ed=max(ed,it.second);
        }
    }
    if(st!=-2e9) res.push_back({st,ed});  //防止输入是空
    a=res;
}
int main(){
    cin>>n;
    for(int i=0;i<n;i++){
        int l,r;
        cin>>l>>r;
        a.push_back({l,r});
    }
    merge(a);
    cout<<a.size()<<endl;
    return 0;
}
```



## 二.数据结构

### 1.链表与邻接表：树与图的存储

#### 1.1 单链表---邻接表（存储图、树）

**[题目：Acwing826. 单链表](https://www.acwing.com/problem/content/828/)**

**题目描述**

实现一个单链表，链表初始为空，支持三种操作：
(1) 向链表头插入一个数；
(2) 删除第k个插入的数后面的数；
(3) 在第k个插入的数后插入一个数
现在要对该链表进行M次操作，进行完所有操作后，从头到尾输出整个链表。
注意:题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个
数，则按照插入的时间顺序，这n个数依次为：第1个插入的数，第2个插入的数，…第n个
插入的数。

**输入格式**

第一行包含整数M，表示操作次数。
接下来M行，每行包含一个操作命令，操作命令可能为以下几种：

(1) “H x”，表示向链表头插入一个数x。
(2) “D k”，表示删除第k个插入的数后面的数（当k为0时，表示删除头结点）。
(3) “I k x”，表示在第k个插入的数后面插入一个数x（此操作中k均大于0）。

**输出格式**

共一行，将整个链表从头到尾输出。

**数据范围**
1≤M≤100000
所有操作保证合法。

**输入样例：**

```
10
H 9
I 1 1
D 1
D 0
H 6
I 3 6
I 4 5
I 4 5
I 3 4
D 6
```

**输出样例：**

```
6 4 6 5
```

**题解：**

``` c++
// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点
/*
e和ne是按下标关联起来的,空节点下标用-1表示
head-->#-->#-->#-->#--->-1
下标    0   1   2   3    -1
对应值  3   5   7   9
 e[0]=3   e[1]=5   e[2]=7   e[3]=9
ne[0]=1   ne[1]=2  ne[2]=3  ne[3]=-1
*/   
int head, e[N], ne[N], idx;

// 初始化
void init()
{
    head = -1;
    idx = 0;
}

// 在链表头插入一个数a
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}

// 将头结点删除，需要保证头结点存在
void remove()
{
    head = ne[head];
}
```

**代码：**

```c++
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace  std;
const int N=100010;
//head表示头节点下标
//e[i]表示节点i的值
//ne[i]表示节点i的next指针是多少
//idx表示存储当前已经用到的那个点
int head,e[N],ne[N],idx;    

//初始化
void init(){
    head=-1;
    idx=0;
}

//x插入头节点-头插法
void add_to_head(int x){
    e[idx]=x;	//构造新的节点，存x
    ne[idx]=head;	//将新节点指向head指向的点
    head=idx;	//更新头指针的指向，head指向新的节点
    idx++;	//	idx已经使用了
    // head=idx++;
}

//将x插入下标为k的点位置后面
void add(int k,int x){
    e[idx]=x;
    ne[idx]=ne[k];      //插入新的点为k位置的下一个指针
    ne[k]=idx;        
    idx++;
    // ne[k]=idx++;
}

//将下标是k后面的点删掉
void remove(int k){
    ne[k]=ne[ne[k]];
}
int main(){
    int m;
    cin>>m;
    init();
    while(m--){
        int k,x;
        char op;
        cin>>op;
        if(op=='H'){
            cin>>x;
            add_to_head(x);
        }else if(op=='D'){
            cin>>k;
            //删除头节点
            if(!k){
                head=ne[head];
            }
            remove(k-1);		//要求二
        }else{
            cin>>k>>x;
            add(k-1,x);
        }
    }
    for(int i=head;i!=-1;i=ne[i]) cout<<e[i]<<' ';
    cout<<endl;
    return 0;
}
```

#### 1.2 双链表（优化某些问题）

**[题目：Acwing827. 双链表](https://www.acwing.com/problem/content/829/)**

**题目描述**

实现一个双链表，双链表初始为空，支持5种操作：
(1) 在最左侧插入一个数；
(2) 在最右侧插入一个数；
(3) 将第k个插入的数删除；
(4) 在第k个插入的数左侧插入一个数；
(5) 在第k个插入的数右侧插入一个数

现在要对该链表进行M次操作，进行完所有操作后，从左到右输出整个链表。
注意:题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个数，
则按照插入的时间顺序，这n个数依次为：第1个插入的数，第2个插入的数，…第n个插入的数。

**输入格式**

第一行包含整数M，表示操作次数。
接下来M行，每行包含一个操作命令，操作命令可能为以下几种：
(1) “L x”，表示在链表的最左端插入数x。
(2) “R x”，表示在链表的最右端插入数x。
(3) “D k”，表示将第k个插入的数删除。
(4) “IL k x”，表示在第k个插入的数左侧插入一个数。
(5) “IR k x”，表示在第k个插入的数右侧插入一个数。

**输出格式**

共一行，将整个链表从左到右输出。

**数据范围**
1≤M≤100000
所有操作保证合法。

**输入样例：**

```
10
R 7
D 1
L 3
IL 2 10
D 3
IL 2 7
L 8
R 9
IL 4 7
IR 2 2
```

**输出样例：**

```
8 7 7 3 2 9
```


**题解：**

``` c++
// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点
int e[N], l[N], r[N], idx;

// 初始化
void init()
{
    //0是左端点，1是右端点
    r[0] = 1, l[1] = 0;
    idx = 2;
}

// 在节点a的右边插入一个数x
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}

// 删除节点a
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```

**代码：**

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
const int N=100010;
int m;
int e[N],l[N],r[N],idx;

//初始化
void init(){
    //0表示左端点，1表示右端点
    //0右边是1，1左边是0
    r[0]=1,l[1]=0;
    //idx表示存储当前已经用到的那个点,0,1已经用了
    idx=2;
}

//下标k右边插入x
void add(int k,int x){
    e[idx]=x;
    r[idx]=r[k];
    l[idx]=k;
    //先l后r
    l[r[k]]=idx;
    r[k]=idx++;
}

//删除第k个点
void remove(int k){
    r[l[k]]=r[k];
    l[r[k]]=l[k];
}

//
int main(){
    cin>>m;
    init();
    while(m--){
        int x,k;
        string op;
        cin>>op;
        if(op=="L"){
            cin>>x;
            add(0,x);
        }else if(op=="R"){
            cin>>x;
            add(l[1],x);
        }else if(op=="D"){
            cin>>k;
            remove(k+1);
        }else if(op=="IL"){
            cin>>k>>x;
            add(l[k+1],x);
        }else{
            cin>>k>>x;
            add(k+1,x);
        }
    }
    for(int i=r[0];i!=1;i=r[i]) cout<<e[i]<<' ';
    cout<<endl;
    return 0;
}
```

### 2.栈与队列：单调队列、单调栈

#### 2.1 模拟栈

**[题目：Acwing828. 模拟栈](https://www.acwing.com/problem/content/830/)**

**题目描述**

实现一个栈，栈初始为空，支持四种操作：

1.push x – 向栈顶插入一个数 x；
2.pop – 从栈顶弹出一个数；
3.empty – 判断栈是否为空；
4.query – 查询栈顶元素。
现在要对栈进行 M 个操作，其中的每个操作 3 和操作 4 都要输出相应的结果。

**输入格式**

第一行包含整数 M，表示操作次数。
接下来 M 行，每行包含一个操作命令，操作命令为 push x，pop，empty，query 中的一种。

**输出格式**

对于每个 empty 和 query 操作都要输出一个查询结果，每个结果占一行。

其中，empty 操作的查询结果为 YES 或 NO，query 操作的查询结果为一个整数，表示栈顶元素的值。

**数据范围:**
1≤M≤100000,
1≤x≤10^9 
所有操作保证合法。

**输入样例：**

```
10
push 5
query
push 6
pop
query
pop
empty
push 4
query
empty
```

**输出样例：**

```
5
5
YES
4
NO
```

**题解：**

``` c
int stk[N], tt; //  tt栈顶

//插入
void push_data(int x)
{
    stk[++tt] = x;
}

//弹出
void pop_data()
{
    tt--;
}

//判断栈是否为空
bool isEmpty()
{
    if (tt > 0)
        return false;
    else
        return true;
}

//栈顶
int get_tt_data
{
    int top = stk[tt];
    return top;
}
```

**代码：**

```cpp
#include <iostream>
using namespace std;
const int N=100010;
int m;
int stk[N],tt;

int main(){
    cin>>m;
    while(m--){
        string op;
        int x;
        cin >> op;
        if (op == "push")
        {
            cin >> x;
            stk[ ++ tt] = x;
        }
        else if (op == "pop") tt -- ;
        else if (op == "empty") cout << (tt ? "NO" : "YES") << endl;
        else cout << stk[tt] << endl;
    }
    return 0;
}
```

#### 2.2 栈应用之表达式求值

**[题目：AcWing 3302. 表达式求值](https://www.acwing.com/problem/content/3305/)**

**题目描述**

给定一个表达式，其中运算符仅包含 +,-,*,/（加 减 乘 整除），可能包含括号，请你求出表达式的最终值。

注意：
1.数据保证给定的表达式合法。
2.题目保证符号 - 只作为减号出现，不会作为负号出现，例如，-1+2,(2+2)*(-(1+1)+2) 之类表达式均不会出现。
3.题目保证表达式中所有数字均为正整数。
4.题目保证表达式在中间计算过程以及结果中，均不超过 2^31−1。
5.题目中的整除是指向 0 取整，也就是说对于大于 0 的结果向下取整，例如 5/3=1，对于小于 0 的结果向上取整，例如 5/(1−4)=−1。
6.C++和Java中的整除默认是向零取整；Python中的整除//默认向下取整，因此Python的eval()函数中的整除也是向下取整，在本题中不能直接使用。

**输入格式**

共一行，为给定表达式。

**输出格式**

共一行，为表达式的结果。

**数据范围:**
表达式的长度不超过 10^5。

**输入样例：**

```
(2+2)*(1+1)
```

**输出样例：**

``` 
8
```

**题解：**

``` c
int stk[N], tt; //  tt栈顶

//插入
void push_data(int x)
{
    stk[++tt] = x;
}

//弹出
void pop_data()
{
    tt--;
}

//判断栈是否为空
bool isEmpty()
{
    if (tt > 0)
        return false;
    else
        return true;
}

//栈顶
int get_tt_data
{
    int top = stk[tt];
    return top;
}

//中缀表达式求值

/*
    如何判断某子树遍历完了===当前运算符优先级>=上一个运算符优先级
					===遇到括号的话从右往左算
*/
```

**代码：**

```c
#include <iostream>
#include <cstring>
#include <algorithm>
#include <stack>
#include <unordered_map>

using namespace std;

stack<int> num;
stack<char> op;

void eval()
{
    auto b = num.top(); num.pop();
    auto a = num.top(); num.pop();
    auto c = op.top(); op.pop();
    int x;
    if (c == '+') x = a + b;
    else if (c == '-') x = a - b;
    else if (c == '*') x = a * b;
    else x = a / b;
    num.push(x);
}

int main()
{
    unordered_map<char, int> pr{{'+', 1}, {'-', 1}, {'*', 2}, {'/', 2}};
    string str;
    cin >> str;
    for (int i = 0; i < str.size(); i ++ )
    {
        auto c = str[i];
        if (isdigit(c))
        {
            int x = 0, j = i;
            while (j < str.size() && isdigit(str[j]))
                x = x * 10 + str[j ++ ] - '0';
            i = j - 1;
            num.push(x);
        }
        else if (c == '(') op.push(c);
        else if (c == ')')
        {
            while (op.top() != '(') eval();
            op.pop();
        }
        else
        {
            //当前运算符优先级>=上一个运算符优先级
            while (op.size() && op.top() != '(' && pr[op.top()] >= pr[c]) eval();
            op.push(c);
        }
    }
    while (op.size()) eval();
    cout << num.top() << endl;
    return 0;
}
```



#### 2.3 模拟队列

**[题目：AcWing 829. 模拟队列](https://www.acwing.com/problem/content/831/)**

**题目描述**

实现一个队列，队列初始为空，支持四种操作：

(1) push x – 向队尾插入一个数x；

(2) pop – 从队头弹出一个数；

(3) empty – 判断队列是否为空；

(4) query – 查询队头元素。

现在要对队列进行M个操作，其中的每个操作3和操作4都要输出相应的结果。

**输入格式**

第一行包含整数M，表示操作次数。

接下来M行，每行包含一个操作命令，操作命令为”push x”，”pop”，”empty”，”query”中的一种。

**输出格式**

对于每个”empty”和”query”操作都要输出一个查询结果，每个结果占一行。

其中，”empty”操作的查询结果为“YES”或“NO”，”query”操作的查询结果为一个整数，表示队头元素的值。

**数据范围**

1≤M≤100000,
1≤x≤109,

所有操作保证合法。
**输入样例：**

```r
10
push 6
empty
query
pop
empty
push 3
push 4
pop
query
push 6
```

**输出样例：**

```
NO
6
YES
4
```

**题解：**

``` c
// hh 表示队头，tt表示队尾；头左尾右
int q[N], hh = 0, tt = -1;

// 向队尾插入一个数
q[++tt] = x;

// 从队头弹出一个数
hh++;

// 取出队头的值
q[hh];

// 取出队尾的值
q[tt];

// 判断队列是否为空
bool isp_empty()
{
    if (hh <= tt)
        return false;
    return true;
}
```

**代码：**

```cpp
#include <iostream>

using namespace std;

const int N = 100010;

int m;
int q[N], hh, tt = -1;

int main()
{
    cin >> m;

    while (m -- )
    {
        string op;
        int x;

        cin >> op;
        if (op == "push")
        {
            cin >> x;
            q[ ++ tt] = x;
        }
        else if (op == "pop") hh ++ ;
        else if (op == "empty") cout << (hh <= tt ? "NO" : "YES") << endl;
        else cout << q[hh] << endl;
    }

    return 0;
}
```



#### 2.4 单调栈模板

**给定一个序列，找到给定值左边离该数最近且比它小的数**

**[题目：AcWing 830. 单调栈](https://www.acwing.com/problem/content/832/)**

**题目描述**

给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。

**输入格式**

第一行包含整数 N，表示数列长度。

第二行包含 N 个整数，表示整数数列。

**输出格式**

共一行，包含 N 个整数，其中第 i 个数表示第 i 个数的左边第一个比它小的数，如果不存在则输出 −1。

**数据范围**

1≤N≤10^5
1≤数列中元素≤10^9
**输入样例：**

```r
5
3 4 2 7 5
```

**输出样例：**

```
-1 3 -1 2 2
```

**题解：**

``` c
方法一：暴力
    往i前面一个数i-1左走，找到第一个满足的数
for(int i=0;i<n;i++){
    for(int j=i-1;j>=0;j--){
        if(a[i]>a[j]){
            cout<<a[j]<<endl;
            break;
        }
    }
}

方法二：单调栈
详细过程：将当前位置前面的数据都放到一个栈里面，如果栈里面存在这样的数据(逆序对)
   	a1>a2  下标1<2;那a1这个数据将不会被用到，可以删除；
  	将所有的数据进行这样操作之后，那最后得到的栈里面的数据就都是递增的。
常见模型：找出每个数左边离它最近的比它大/小的数
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
    while (tt && check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
} 
```

**代码：**

```c
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N=10e5+10;
int n;
int stk[N],tt=0;
int main(){
    cin.tie(0);
    ios::sync_with_stdio(false);
    cin>>n;
    for(int i=0;i<n;i++){
        int x;
        cin>>x;
        //当栈不空，栈顶元素>=当前这个数，栈顶元素用不到，弹出用不到
        while(tt && stk[tt]>=x) tt--;
        //栈不为空，则栈顶元素就是其最小的值
        if(tt) cout<<stk[tt]<<" ";
        else cout<<"-1 ";
		//将当前数据加入到栈里面
        stk[++tt]=x;
    }
    return 0;
}
```



#### 2.5 单调队列之滑动窗口

**在长度为 n 的序列中，求每个长度为 m 的区间的区间最值**

**[题目：AcWing 154. 滑动窗口](https://www.acwing.com/problem/content/156/)**

**题目描述**

给定一个大小为$n≤10^6$的数组。

有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。

你只能在窗口中看到 k 个数字。

每次滑动窗口向右移动一个位置。

以下是一个例子：

该数组为 `[1 3 -1 -3 5 3 6 7]`，k 为 3。

| 窗口位置            | 最小值 | 最大值 |
| :------------------ | :----- | :----- |
| [1 3 -1] -3 5 3 6 7 | -1     | 3      |
| 1 [3 -1 -3] 5 3 6 7 | -3     | 3      |
| 1 3 [-1 -3 5] 3 6 7 | -3     | 5      |
| 1 3 -1 [-3 5 3] 6 7 | -3     | 5      |
| 1 3 -1 -3 [5 3 6] 7 | 3      | 6      |
| 1 3 -1 -3 5 [3 6 7] | 3      | 7      |

你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。

**输入格式**

输入包含两行。

第一行包含两个整数 n 和 k，分别代表数组长度和滑动窗口的长度。

第二行有 n 个整数，代表数组的具体数值。

同行数据之间用空格隔开。

**输出格式**

输出包含两个。

第一行输出，从左至右，每个位置滑动窗口中的最小值。

第二行输出，从左至右，每个位置滑动窗口中的最大值。

**输入样例：**

```r
8 3
1 3 -1 -3 5 3 6 7
```

**输出样例：**

```
-1 -3 -3 -3 3 3
3 3 5 5 6 7
```

**题解：**

``` c
暴力：先遍历，将k个数据放到队列里面，不足k个数据的时候，将新数据插到队列的尾部，
      达到k个数据的话将队列的对头删除，将当前数据插入到队尾；
      时间复杂度O(k)
优化：1 3 -1 -3 5 3 6 7
    队列里面，将逆序的数据对，将下标小的但是数据大删了，得到严格单调递增数据
    3 -1 -3的情况，将3，-1都可以删除
注意：队列里面存的不是数据值，存的是数据的下标
```

**代码：**

```c
#include <iostream>
using namespace std;
const int N = 1000010;
// a数组存数据，q模拟队列
int a[N], q[N], k, n;
int main()
{
    scanf("%d%d", &n, &k);
    for (int i = 0; i < n; i++)
        scanf("%d", &a[i]);
    // hh表示队头，tt表示队尾，头左尾右
    int hh = 0, tt = -1;
    for (int i = 0; i < n; i++)
    {
        //当队列不为空hh<=tt,每次判断队列头是否滑出了窗口，当前位置是i;
        //前面的k个数据的起始坐标i-k+1,不在得话则弹出队列头维持窗口大小
        //也就是删除i - k + 1 > q[hh]
        if (hh <= tt && i - k + 1 > q[hh])
            hh++;
        //构造单调队列，新的元素a[i]是否比队尾元素小，小得话则删除
        while (hh <= tt && a[q[tt]] >= a[i])
            tt--;
        //删除后将当前节点i加入到队列尾部
        q[++tt] = i;
        //每次的答案是队列头元素
        if (i >= k - 1)
            printf("%d ", a[q[hh]]);
    }
    puts("");
    hh = 0, tt = -1;
    for (int i = 0; i < n; i++)
    {
        //每次判断队列头是否滑出了窗口
        if (hh <= tt && i - k + 1 > q[hh])
            hh++;
        while (hh <= tt && a[q[tt]] <= a[i])
            tt--;
        q[++tt] = i;
        if (i >= k - 1)
            printf("%d ", a[q[hh]]);
    }
    puts("");
    return 0;
}
```



### 3.kmp

**[题目：831. KMP字符串](https://www.acwing.com/problem/content/833/)**

**题目描述**

给定一个模式串 S，以及一个模板串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。

模板串 P 在模式串 S 中多次作为子串出现。

求出模板串 P 在模式串 S 中所有出现的位置的起始下标。

**输入格式**

第一行输入整数 N，表示字符串 P 的长度。

第二行输入字符串 P。

第三行输入整数 M，表示字符串 S 的长度。

第四行输入字符串 S。

**输出格式**

共一行，输出所有出现位置的起始下标（下标从 0 开始计数），整数之间用空格隔开。

**数据范围**

1≤N≤10^5
1≤M≤10^6

**输入样例：**

```r
3
aba
5
ababa
```

**输出样例：**

```
0 2
```

**题解：**

``` c
方法一：暴力BF
**主串S[N],匹配串p[N];
for(int i=1;i<=n;i++){
    bool flag=true;
    for(int j=1;j<=m;j++){
        if(s[i]!=p[j]){
            flag=false;
            break;
        }
    }
}

int BF(string s,string p,int pos){
    //s[0]存放s串的长度n,p[0]存放p的长度m
    int sum=0;
    int i=pos,j=1;
    while(i<s[0] && j<p[0]){
        sum++;
        if(s[i]==s[j]){
            i++,j++;
        }else{
            i=i-j+2;
            j=1;
        }
    }
    if(p[0]<j){
        return i-p[0];
    }else{
        return 0;
    }
}

方法二：优化

 S1  ----------------|-|--------------------
                   i-1 i(匹配到j，下一个位置不匹配了,false)
 S2      ------------|-|----
                     j j+1  (S1[某字符,i-1]与S2[1,j]匹配了，看S1[i]和S2[j+1]是否匹配)
 S3              ----|-------------  
                next[j] (S3到next[j]部分的字符保证和S1中到i-1位置匹配)
                  ---|--------------
                next[next[j]]一直移动直到匹配
                
next[i]=j:以i为终点的后缀，从1开始的前缀相等且长度为j的
next[i]:所有p[1到i]的相等的前缀和后缀中长度的最大值--->力扣：28. 实现 strStr()  https://leetcode-cn.com/problems/implement-strstr/

    1                           i    
    ----------------------------
    -----------------
                    j

 p[1,j]==p[i-j+1,i]

举例：
s=abababc(1--7)
P=abababab(1--8)
当S中i=7,P中j=6,看p[j+1]和s[i]是否匹配，不匹配j前跳,next[j=6]=4,j跳到4位置
即S[3,6]==P[1,4]

                  前缀           后缀          
next[1]=0          0              0           a
next[2]=0          0              0           ab
next[3]=1          a              a           aba
next[4]=2          ab             ab          abab
next[5]=3          aba            aba         ababa
next[6]=4          abab           abab        ababab
next[7]=5          ababa          ababa       abababa
next[8]=6    
        
        
结论：
   1.n-next[n]是字符串的最小周期T_0;
	 n-next[n]<=T_0  && n-next[n]>=T_0
   2.LeetCode 459. 重复的子字符串
```

**代码：**

```c
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N=1e4+10,M=1e5+10;
char p[N],s[M];
int ne[N];
int n,m;
int main(){
    cin.tie(0);
    ios::sync_with_stdio(false);
    //下标1开始
    cin>>n>>p+1>>m>>s+1;

    //求next[],next[1]=0
    for(int i=2,j=0;i<=n;i++){
        //不匹配，j回退到ne[j]移动
        while(j && p[i]!=p[j+1]) j=ne[j];
        //匹配，j前进
        if(p[i]==p[j+1]) j++;
        //记录next数组
        ne[i]=j;
    }

    //KMP匹配过程
    //s[i]当前,p中是下标为j+1的字符和s的第i字符试图匹配的
    for(int i=1,j=0;i<=m;i++){
        //j没有，退回起点，j退回起点则重新开始匹配
        while(j && s[i]!=p[j+1]) j=ne[j];
        //如果匹配了,j到下一个位置
        if(s[i]==p[j+1]) j++;
        //匹配成功
        if(j==n){
            printf("%d ",i-n);
            //匹配后的逻辑(匹配后退一步)
            j=ne[j];
        }
    }
    return 0;
}
```



### 4.Trie

**[题目：835. Trie字符串统计](https://www.acwing.com/problem/content/837/)**

**题目描述**

维护一个字符串集合，支持两种操作：

1. `I x` 向集合中插入一个字符串 x；
2. `Q x` 询问一个字符串在集合中出现了多少次。

共有 N 个操作，输入的字符串总长度不超过 10^5，字符串仅包含小写英文字母。

**输入格式**

第一行包含整数 N，表示操作数。

接下来 N 行，每行包含一个操作指令，指令为 `I x` 或 `Q x` 中的一种。

**输出格式**

对于每个询问指令 `Q x`，都要输出一个整数作为结果，表示 x 在集合中出现的次数。

每个结果占一行。

**数据范围**

1≤N≤2∗10^4

**输入样例：**

```r
5
I abc
Q abc
Q ab
I ab
Q ab
```

**输出样例：**

```
1
0
1
```

**题解：**

``` c
Trie树:用来高效的存储和查找字符串集合的数据结构
    abcdef
    abdef
    aced
    bcdf
    bcff
    cdaa
    bcdc
存储：将前缀相同的部分用树存储起来
   	 将每个字符串的最后一个结尾的字母标记一下
查找：找到最后的一个标记，则可以判断是否存在这个单词，要查找的字符结尾部分刚好是标记截止地方则存在
```

**代码：**

```c
#include <iostream>
using namespace std;
const int N = 100010;
// son存储有多少个儿子,每个节点可能最多有26个儿子
// cnt表示以当前单词结尾的点有多少个，idx表示当前的下标
int son[N][26], cnt[N], idx; //下标是0的节点，既是根节点，也是空节点
char str[N];
//存储(插入)
void insert(char str[])
{
    //根节点为0
    int p = 0;
    // cpp里面字符串结尾是/0，可以判断是否能走到结尾了str[i]
    for (int i = 0; str[i]; i++)
    {
        //当前字母对应的子节点编号a-z映射为0-25
        int u = str[i] - 'a';
        //如果p节点不存在u这个儿子则创建出来插入
        if (!son[p][u])
            son[p][u] = ++idx;
        //创建好或者已经有这个节点不需要创建，都走到下一个点
        p = son[p][u];
    }
    //走到了结尾则这个这个单词都查了，则该单词个数加1
    cnt[p]++;
}

//查询操作
int query(char str[])
{
    //根节点开始
    int p = 0;
    // str[i]!="\0"
    for (int i = 0; str[i]; i++)
    {
        //当前字母对应的子节点编号a-z映射为0-25
        int u = str[i] - 'a';
        //如果p节点不存在u这个儿子则返回0
        if (!son[p][u])
            return 0;
        //否则走过去
        p = son[p][u];
    }
    //返回以p为根节点的单词数量
    return cnt[p];
}
int main()
{
    int n;
    scanf("%d", &n);
    while (n--)
    {
        char op[2];
        scanf("%s%s", op, str);
        if (op[0] == 'I')
            insert(str);
        else
            printf("%d\n", query(str));
    }
    return 0;
}
```



### 5.并查集

#### 5.1 模板

```c
(1)朴素并查集：

    int p[N]; //存储每个点的祖宗节点

    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }

    // 初始化，假定节点编号是1~n
    for (int i = 1; i <= n; i ++ ) p[i] = i;

    // 合并a和b所在的两个集合：
    p[find(a)] = find(b);


(2)维护size的并查集：

    int p[N], size[N];
    //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量

    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }

    // 初始化，假定节点编号是1~n
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        size[i] = 1;
    }

    // 合并a和b所在的两个集合：
    size[find(b)] += size[find(a)];
    p[find(a)] = find(b);


(3)维护到祖宗节点距离的并查集：

    int p[N], d[N];
    //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离

    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x)
        {
            int u = find(p[x]);
            d[x] += d[p[x]];
            p[x] = u;
        }
        return p[x];
    }

    // 初始化，假定节点编号是1~n
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        d[i] = 0;
    }

    // 合并a和b所在的两个集合：
    p[find(a)] = find(b);
    d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量
```

#### 5.2 朴素并查集应用

**[题目：836. 合并集合](https://www.acwing.com/problem/content/838/)**

**路径压缩模块**

**题目描述**

一共有 n 个数，编号是 1∼n，最开始每个数各自在一个集合中。

现在要进行 m个操作，操作共有两种：

1. `M a b`，将编号为 a 和 b 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；
2. `Q a b`，询问编号为 a 和 b 的两个数是否在同一个集合中；

**输入格式**

第一行输入整数 n 和 m。

接下来 m 行，每行包含一个操作指令，指令为 `M a b` 或 `Q a b` 中的一种。

**输出格式**

对于每个询问指令 `Q a b`，都要输出一个结果，如果 a 和 b 在同一集合内，则输出 `Yes`，否则输出 `No`。

每个结果占一行。

**数据范围**

1≤n,m≤10^5

**输入样例：**

```r
4 5
M 1 2
M 3 4
Q 1 2
Q 1 3
Q 3 4
```

**输出样例：**

```
Yes
No
Yes
```

**题解：**

``` c
并查集 ( 近似0(1) )：
1、将两个集合合并
2、询问两个元素是否在一个集合之中

//x属于a
belong[x]=a
if(belong[x]==belong[y]) O(1)
    
基本原理：用树的形式维护所有的集合，每个集合用一棵树来表示，树根的编号就是整个集合的编号，每个节点存储它的父节点，P[x]表示x的父节点
    1.如何判断树根：if(p[x]==x)
    2.如何求x的集合编号，while(p[x]!=x) x=p[x];
	3.如何合并两个集合：px是x的编号，py是y的集合编号，p[x]=y
        
优化（路径压缩）：
        
优化（按秩合并）：按照树的高度合并（保留树的结构）   
```

**代码（路径压缩模块）：**

```c
#include <iostream>
using namespace std;
const int N = 100010;
int p[N];
int n, m;
//返回x所在集合的编号,返回x的祖宗节点+路径压缩
int find(int x)
{
    //如果p[x]不等于x，则找到p[x]的祖宗，之后返回p[x]的值
    if (p[x] != x)
        p[x] = find(p[x]);
    return p[x];
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
        p[i] = i;
    while (m--)
    {
        char op[2];	//sacanf可能会读入空格和回车等，所以用字符串读字符
        int a, b;
        scanf("%s%d%d", op, &a, &b);
        if (op[0] == 'M')
        {
            // 合并为：a的祖宗是b
            //找到a的祖宗
            p[find(a)] = find(b);
        }
        else
        {
            if (find(a) == find(b))
                puts("Yes");
            else
                puts("No");
        }
    }
    return 0;
}
```

#### 5.3 路径压缩应用

**[题目：837. 连通块中点的数量](https://www.acwing.com/problem/content/839/)**

**计算每个集合中元素的个数**

**题目描述**

给定一个包含 n 个点（编号为 1∼n）的无向图，初始时图中没有边。

现在要进行 m 个操作，操作共有三种：

1. `C a b`，在点 a 和点 b 之间连一条边，a 和 b 可能相等；
2. `Q1 a b`，询问点 a 和点 b 是否在同一个连通块中，a 和 b 可能相等；
3. `Q2 a`，询问点 a 所在连通块中点的数量；

**输入格式**

第一行输入整数 n 和 m。

接下来 m 行，每行包含一个操作指令，指令为 `C a b`，`Q1 a b` 或 `Q2 a` 中的一种。

**输出格式**

对于每个询问指令 `Q1 a b`，如果 a 和 b 在同一个连通块中，则输出 `Yes`，否则输出 `No`。

对于每个询问指令 `Q2 a`，输出一个整数表示点 a 所在连通块中点的数量

每个结果占一行。

**数据范围**

1≤n,m≤10^5

**输入样例：**

```r
5 5
C 1 2
Q1 1 2
Q2 1
C 2 5
Q2 5
```

**输出样例：**

```
Yes
2
3
```

**题解：**

``` c
计算每个集合中元素的个数
    （1）维护size的并查集
	（2）维护到祖宗节点距离的并查集
```

**代码：**

```c
#include <iostream>
using namespace std;
const int N = 100010;
int p[N], res[N]; // res表示该集合里面节点的数量
int n, m;
//返回x所在集合的编号,返回x的祖宗节点+路径压缩
int find(int x)
{
    //如果p[x]不等于x，则找到p[x]的祖宗，之后返回p[x]的值
    if (p[x] != x)
        p[x] = find(p[x]);
    return p[x];
}
int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
    {
        p[i] = i;
        //初始时候res=1
        res[i] = 1;
    }
    while (m--)
    {
        char op[5];
        int a, b;
        scanf("%s", op);

        if (op[0] == 'C')
        {
            scanf("%d%d", &a, &b);
            //特判一下，如果两个都在里面
            if (find(a) == find(b))
                continue;
            //更新b的res个数，加上a的所有的个数
            res[find(b)] += res[find(a)];
            // 合并为：a的祖宗是b
            p[find(a)] = find(b);
        }
        else if (op[1] == '1')
        {
            scanf("%d%d", &a, &b);
            if (find(a) == find(b))
                puts("Yes");
            else
                puts("No");
        }
        else
        {
            scanf("%d", &a);
            printf("%d\n", res[find(a)]);
        }
    }
    return 0;
}
```



### 6.堆

#### 6.1 堆排序模板

**[题目：838. 堆排序](https://www.acwing.com/problem/content/840/)**

**题目描述**

输入一个长度为 n 的整数数列，从小到大输出前 m 小的数。

**输入格式**

第一行包含整数 n 和 m。

第二行包含 n 个整数，表示整数数列。

**输出格式**

共一行，包含 m 个整数，表示整数数列中前 m 小的数。

**数据范围**

1≤m≤n≤10^5，
1≤数列中元素≤10^9

**输入样例：**

```r
5 3
4 5 1 3 2
```

**输出样例：**

```
1 2 3
```

**题解：**

``` c
如何手写堆(以小根堆为例，大根堆同理)：
1.插入一个数
    size表示当前的位置，heap[]是表示堆
    heap[++size]=x;
	up(size);

2.求集合当中最小值
    heap[1]
    
3.删除最小值
    将堆的最后一个元素，覆盖堆顶元素，删除最后一个元素，之后在对堆顶down操作
    heap[1]=heap[size];
	size--;
	down(1);

4.删除任意一个元素
    heap[k]=heap[size];
	size--;
	down(k),up(k);
	分情况：变大了还是变小了，大了down操作，小了up操作,代码里面都写，但是只会执行一个操作
        
5.修改任意一个元素
    heap[k]=heap[size];
	size--;
	down(x),up(x);

堆的本质：堆是一个完全二叉树
堆的存储：1号点是根节点,x的左儿子是2x,x的右儿子是2x+1,下标从1开始
down(x)往下调整
void down(int u)
{
    // t表示根节点和左右儿子三个节点里面的最小值，之后处理左右儿子更新t
    int t = u;
    //先处理左儿子
    if (u * 2 <= cnt && h[u * 2] < h[t])
        t = u * 2;
    //处理右儿子
    if (u * 2 + 1 <= cnt && h[u * 2 + 1] < h[t])
        t = u * 2 + 1;
    //如果不是根节点，则说明根节点不是最小的，则根节点和最小值交换一下
    if (u != t)
    {
        swap(h[u], h[t]);
        down(t);
    }
}

up(x)往上调整
void up(int u)
{
    //如果u存在父节点，并且父节点的值大于当前的节点值
    while (u / 2 && h[u / 2] > h[u])
    {
        //换上去
        swap(h[u / 2], h[u]);
        //更新当前操作
        u /= 2;
    }
}
```

**代码：**

```c
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 100010;

int n, m;
// h表示存的数，cnt表示当前的元素个数
int h[N], cnt;

void down(int u)
{
    // t表示根节点和左右儿子三个节点里面的最小值，之后处理左右儿子更新t
    int t = u;
    //先处理左儿子
    if (u * 2 <= cnt && h[u * 2] < h[t])
        t = u * 2;
    //处理右儿子
    if (u * 2 + 1 <= cnt && h[u * 2 + 1] < h[t])
        t = u * 2 + 1;
    //如果不是根节点，则说明根节点不是最小的，则根节点和最小值交换一下
    if (u != t)
    {
        swap(h[u], h[t]);
        down(t);
    }
}

void up(int u)
{
    //如果u存在父节点，并且父节点的值大于当前的节点值
    while (u / 2 && h[u / 2] > h[u])
    {
        //换上去
        swap(h[u / 2], h[u]);
        //更新当前操作
        u /= 2;
    }
}

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> h[i];
    cnt = n;

    // 1.建堆，从n/2开始down(最后一层都是叶子节点不需要down操作)，时间复杂度O(n)
    for (int i = n / 2; i; i--)
        down(i);
    while (m--)
    {
        //每次输出堆顶元素
        cout << h[1] << " ";
        //之后删除最小元素堆顶h[1]元素
        h[1] = h[cnt];
        cnt--;
        down(1);
    }
    return 0;
}
```

#### 6.2 模拟堆

**[题目：839. 模拟堆](https://www.acwing.com/problem/content/841/)**

**题目描述**

维护一个集合，初始时集合为空，支持如下几种操作：

1. `I x`，插入一个数 x；
2. `PM`，输出当前集合中的最小值；
3. `DM`，删除当前集合中的最小值（数据保证此时的最小值唯一）；
4. `D k`，删除第 k 个插入的数；
5. `C k x`，修改第 k 个插入的数，将其变为 x；

现在要进行 N 次操作，对于所有第 2 个操作，输出当前集合的最小值。

**输入格式**

第一行包含整数 N。

接下来 N 行，每行包含一个操作指令，操作指令为 `I x`，`PM`，`DM`，`D k` 或 `C k x` 中的一种。

**输出格式**

对于每个输出指令 `PM`，输出一个结果，表示当前集合中的最小值。

每个结果占一行。

**数据范围**

1≤N≤10^5
−10^9≤x≤10^9
数据保证合法。

**输入样例：**

```c
8
I -10
PM
I -10
D 1
C 2 8
I 6
PM
DM
```

**输出样例：**

```
-10
6
```

**题解：**

``` c
// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1
// ph[k]存储第k个插入的点在堆中的位置
// hp[k]存储堆中下标是k的点是第几个插入的
int h[N], ph[N], hp[N], size;

// 交换两个点，及其映射关系
void heap_swap(int a, int b)
{
    swap(ph[hp[a]],ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}

void down(int u)
{
    int t = u;
    if (u * 2 <= size && h[u * 2] < h[t]) t = u * 2;
    if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
    if (u != t)
    {
        heap_swap(u, t);
        down(t);
    }
}

void up(int u)
{
    while (u / 2 && h[u] < h[u / 2])
    {
        heap_swap(u, u / 2);
        u >>= 1;
    }
}

// O(n)建堆
for (int i = n / 2; i; i -- ) down(i);
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <string.h>
using namespace std;

const int N = 100010;
// ph[k]表示存放第k个插入点的下标
// hp[k]表示存放堆中点的插入次序(映射)
// ph[j]=k,hp[k]=j;
int h[N], ph[N], hp[N], cnt;
int n, m = 0;

void heap_swap(int a, int b)
{
    swap(ph[hp[a]], ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}

void down(int u)
{
    int t = u;
    if (u * 2 <= cnt && h[u * 2] < h[t])
        t = u * 2;
    if (u * 2 + 1 <= cnt && h[u * 2 + 1] < h[t])
        t = u * 2 + 1;
    if (u != t)
    {
        heap_swap(u, t);
        down(t);
    }
}

void up(int u)
{
    while (u / 2 && h[u / 2] > h[u])
    {
        heap_swap(u / 2, u);
        u /= 2;
    }
}

int main()
{
    scanf("%d", &n);
    while (n--)
    {
        char op[10];
        int k, x;
        scanf("%s", op);
        if (!strcmp(op, "I"))
        {
            scanf("%d", &x);
            cnt++;
            //当前插入的数是第m个
            m++;
            ph[m] = cnt, hp[cnt] = m;
            h[cnt] = x;
            up(cnt);
        }
        else if (!strcmp(op, "PM"))
        {
            printf("%d\n", h[1]);
        }
        else if (!strcmp(op, "DM"))
        {
            heap_swap(1, cnt);
            cnt--;
            down(1);
        }
        else if (!strcmp(op, "D"))
        {
            scanf("%d", &k);
            //找到在堆中的位置
            k = ph[k];
            heap_swap(k, cnt);
            cnt--;
            down(k), up(k);
        }
        else
        {
            scanf("%d%d", &k, &x);
            k = ph[k];
            h[k] = x;
            down(k), up(k);
        }
    }
    return 0;
}
```



### 7.Hash表

#### 7.1  一般哈希拉链法和开放寻址法

```c
(1) 拉链法
    int h[N], e[N], ne[N], idx;

    // 向哈希表中插入一个数
    void insert(int x)
    {
        int k = (x % N + N) % N;
        e[idx] = x;
        ne[idx] = h[k];
        h[k] = idx ++ ;
    }

    // 在哈希表中查询某个数是否存在
    bool find(int x)
    {
        int k = (x % N + N) % N;
        for (int i = h[k]; i != -1; i = ne[i])
            if (e[i] == x)
                return true;

        return false;
    }

(2) 开放寻址法
    int h[N];

    // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置
    int find(int x)
    {
        int t = (x % N + N) % N;
        while (h[t] != null && h[t] != x)
        {
            t ++ ;
            if (t == N) t = 0;
        }
        return t;
    }
```

#### 7.2 一般哈希应用

**[题目：AcWing 840. 模拟散列表](https://www.acwing.com/problem/content/842/)**

**题目描述**

维护一个集合，支持如下几种操作：

1. `I x`，插入一个数 x；
2. `Q x`，询问数 xx 是否在集合中出现过；

现在要进行 N 次操作，对于每个询问操作输出对应的结果。

**输入格式**

第一行包含整数 N，表示操作数量。

接下来 N 行，每行包含一个操作指令，操作指令为 `I x`，`Q x` 中的一种。

**输出格式**

对于每个询问指令 `Q x`，输出一个询问结果，如果 x 在集合中出现过，则输出 `Yes`，否则输出 `No`。

每个结果占一行。

**数据范围**

1≤N≤10^5^
−10^9^≤x≤10^9^

**输入样例：**

```c
5
I 1
I 2
I 3
Q 2
Q 5
```

**输出样例：**

```c
Yes
No
```

**题解：**

``` c
哈希表 1.存储字符串	 1.1.开放寻址法
					开一个数组是数据范围的2~3倍；
					求出hash值k=h(x)，找到第k位置，已经有的话往后面找坑位，直到找到
					添加：先hash，后面的操作和上面一样的思路
					查找:先hash，其他一样
					删除：按照查找的方式找到x，标记x删除了实际不删除
				  1.2.拉链法
				  	开一个一维数组10^5，存储所有的哈希值，冲突处理，冲突了用一根拉链连接
				  	主要涉及操作：添加、查找、删除（不会真的删除，开一个数组记录下）
	
	  2.字符串哈希方式(字符串前缀哈希法)
	  str="ABCABCDEYXCACWING"
	  h[0]=0;
	  h[1]='A'的哈希值
	  h[2]='AB'的哈希值
	  h[3]='ABC'的哈希值
	  h[4]='ABAC'的哈希值
	  ......
	  eg:“ABCD”
	  (1)将字符串看作是p进制的数,就能将字符串变为数字
	  	 A B C D
	 	(1 2 3 4)p=1*p^3+2*p^2+3*p^1+4*p^0
	  (2)将数字mod Q
      	(1 2 3 4)p=1*p^3+2*p^2+3*p^1+4*p^0 mod Q
      注意：
      (1)不能将字符映射为0否则冲突了
      		A  0
      		AA 0
      (2)假设不存在冲突，经验值取p=131或者13331 ，取Q=2^64
      (3)unsigned long long 存储h的话溢出就相当于直接取模了，就不用对Q取模操作了
      (4)求l到k的hash为h[k]-h[l]*p^(k-l+1)
      	   高位(k-1)					 低位(0)
       		1        l-1 l         k
       		h[k]   p^(k-1).......p^0
       		h[l-1]*p^(k-l+1)
      (5)h[i]=h[i-1]*p+str[i]	
       		
      	
离散化是特殊的哈希方式，离散化需要保顺序的，保证单调递增

10^9映射为10^5：	1.x mod 10^5   取模最好取质数，减少冲突
				   2.冲突(处理冲突开放寻址法，拉链法)
```

**代码：(拉链法)**

```c
#include <iostream>
#include <cstring>
using namespace std;
const int N=100003;
//h表槽，e表示链表的数据，ne表示链表的指针,idx表当前用到哪个位置
int h[N],e[N],ne[N],idx;

void insert(int x){
  //求hash值，加N是为了使结果是正数
  int k=(x % N + N) % N;
  //将当前插入到槽对应的链表里面,h[K]表示当前的槽位置的数据
  e[idx]= x;
  ne[idx]=h[k];
  h[k]=idx++;
}
bool find(int x){
  //hash函数映射
  int k=(x%N+N)%N;
  for(int i=h[k];i!=-1;i=ne[i])
    if(e[i]==x)
      return true;
  return false;
}

int main(){
  /*
  求出最接近100000的质数
  for(int i=100000;;i++){
    bool falg=  true;
    for(int j=2;j*j<=i;j++){
      if(i%j==0){
        falg=false;
        break;
      }
    }
    if(falg){
      cout<<i<<endl;
      break;
    }
  }
  */
  int n;
  scanf("%d",&n);
  memset(h,-1,sizeof h);
  while(n--){
    char op[2];
    int x;
    scanf("%s%d",op,&x);
    if(*op=='I') insert(x);
    else{
      if(find(x)) puts("Yes");
      else puts("No");
    } 
  }
  return 0;
}
```

**代码：（开放寻址法）**

```c
#include <iostream>
#include <cstring>
using namespace std;
//null表示hash表里面没有被占的话默认值
const int N=200003,null=0x3f3f3f3f;
//h表槽
int h[N];

//如果x在hash表中已经存在了则返回在hash中的位置
//如果x在hash表中不存在则返回的是x应该存储的位置
int find(int x){
  //hash函数映射
  int k=(x%N+N)%N;
  //当前位置已经有数据了，并且数据不等于x的话，就往后面看x的值
  while(h[k]!=null && h[k]!=x){
    k++;
    //如果已经到最后一个位置了，则将k值为0
    if(k==N) k=0;
  }
  //如果x在hash表里面k就是下标，如果不在hash里面则k就是应该存的位置
  return k;
}

int main(){
  /*
  求出最接近200000的质数
  for(int i=200000;;i++){
    bool falg=  true;
    for(int j=2;j*j<=i;j++){
      if(i%j==0){
        falg=false;
        break;
      }
    }
    if(falg){
      cout<<i<<endl;
      break;
    }
  }
  */
  int n;
  scanf("%d",&n);
  //memset是以字节为单位对内存进行初始化的，所以上面是null=0x3f3f3f3f，不是初始化为null
  //一般都是-1和0
  memset(h,0x3f,sizeof h);
  while(n--){
    char op[2];
    int x;
    scanf("%s%d",op,&x);
    //先找到需要x的位置
    int k=find(x);
    if(*op=='I'){
      //插入
      h[k]=x;
    }else{
      if(h[k]!=null) puts("Yes");
      else puts("No");
    } 
  }
  return 0;
}
```

****

#### 7.3 字符串哈希

**[题目：AcWing 841. 字符串哈希](https://www.acwing.com/problem/content/843/)**

**题目描述**

给定一个长度为 n 的字符串，再给定 m 个询问，每个询问包含四个整数 l1,r1,l2,r2，请你判断 [l1,r1][l1,r1] 和 [l2,r2][l2,r2] 这两个区间所包含的字符串子串是否完全相同。

字符串中只包含大小写英文字母和数字。

**输入格式**

第一行包含整数 n 和 m，表示字符串长度和询问次数。

第二行包含一个长度为 n 的字符串，字符串中只包含大小写英文字母和数字。

接下来 m 行，每行包含四个整数 l1,r1,l2,r2，表示一次询问所涉及的两个区间。

注意，字符串的位置从 1 开始编号。

**输出格式**

对于每个询问输出一个结果，如果两个字符串子串完全相同则输出 `Yes`，否则输出 `No`。

每个结果占一行。

**数据范围**

1≤n,m≤10^5^

**输入样例：**

```r
8 3
aabbaabb
1 3 5 7
1 3 6 8
1 2 1 2
```

**输出样例：**

```
Yes
No
Yes
```

**题解：**

``` c
字符串哈希方式(字符串前缀哈希法)
	  str="ABCABCDEYXCACWING"
	  h[0]=0;
	  h[1]='A'的哈希值
	  h[2]='AB'的哈希值
	  h[3]='ABC'的哈希值
	  h[4]='ABAC'的哈希值
	  ......
	  eg:“ABCD”
	  (1)将字符串看作是p进制的数,就能将字符串变为数字
	  	 A B C D
	 	(1 2 3 4)p=1*p^3+2*p^2+3*p^1+4*p^0
	  (2)将数字mod Q
      	(1 2 3 4)p=1*p^3+2*p^2+3*p^1+4*p^0 mod Q
      注意：
      (1)不能将字符映射为0否则冲突了
      		A  0
      		AA 0
      (2)假设不存在冲突，经验值取p=131或者13331 ，取Q=2^64
      (3)unsigned long long 存储h的话溢出就相当于直接取模了，就不用对Q取模操作了
       取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果
      (4)求l到k的hash为h[k]-h[l]*p^(k-l+1)
      	   高位(k-1)					 低位(0)
       		1        l-1  l         k
       		h[k]   p^(k-1).......p^0
       		h[l-1]*p^(k-l+1)
      (5)h[i]=h[i-1]*p+str[i]	
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;

typedef unsigned long long ULL;

const int N = 100010, P = 131;

int n, m;
char str[N];
// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64
//p存放存p的多少次方的
ULL h[N], p[N];

// 计算子串 str[l ~ r] 的哈希值
ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}

int main()
{
    scanf("%d%d", &n, &m);
    scanf("%s", str + 1);
    
    // 初始化
    //p^0=1
    p[0] = 1;
    for (int i = 1; i <= n; i ++ )
    {
        h[i] = h[i - 1] * P + str[i];
        p[i] = p[i - 1] * P;
    }

    while (m -- )
    {
        int l1, r1, l2, r2;
        scanf("%d%d%d%d", &l1, &r1, &l2, &r2);

        if (get(l1, r1) == get(l2, r2)) puts("Yes");
        else puts("No");
    }

    return 0;
}
```

### 8.STL

```c
vector, 变长数组，倍增的思想
    size()  返回元素个数
    empty()  返回是否为空
    clear()  清空
    front()/back() 返回第一个数和最后一个数
    push_back()/pop_back()
    begin()/end()
    []
    支持比较运算，按字典序

pair<int, int>
    first, 第一个元素
    second, 第二个元素
    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）
    初始化操作：
    p={1,'zky'}
	p=make_pair{1,'zky'}

string，字符串
    size()/length()  返回字符串长度
    empty()
    clear()
    substr(起始下标，(子串长度))  返回子串
    c_str()  返回字符串所在字符数组的起始地址

queue, 队列
    size()
    empty()
    push()  向队尾插入一个元素
    front()  返回队头元素
    back()  返回队尾元素
    pop()  弹出队头元素

priority_queue, 优先队列，默认是大根堆
    size()
    empty()
    push()  插入一个元素
    top()  返回堆顶元素
    pop()  弹出堆顶元素
    定义成小根堆的方式：priority_queue<int, vector<int>, greater<int>> q;

stack, 栈
    size()
    empty()
    push()  向栈顶插入一个元素
    top()  返回栈顶元素
    pop()  弹出栈顶元素

deque, 双端队列
    size()
    empty()
    clear()
    front()/back()  返回第一个和最后一个元素
    push_back()/pop_back()
    push_front()/pop_front()
    begin()/end()
    []

set, map, multiset(支持重复), multimap(支持重复), 基于平衡二叉树（红黑树），动态维护有序序列
    size()
    empty()
    clear()
    begin()/end()
    ++, -- 返回前驱和后继，时间复杂度 O(logn)

    set/multiset
        insert()  插入一个数
        find()  查找一个数
        count()  返回某一个数的个数
        erase()
            (1) 输入是一个数x，删除所有x   O(k + logn)
            (2) 输入一个迭代器，删除这个迭代器
        lower_bound()/upper_bound()
            lower_bound(x)  返回大于等于x的最小的数的迭代器
            upper_bound(x)  返回大于x的最小的数的迭代器
    map/multimap
        insert()  插入的数是一个pair
        erase()  输入的参数是pair或者迭代器
        find()
        []  注意multimap不支持此操作。 时间复杂度是 O(logn)
        lower_bound()/upper_bound()

unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表
    和上面类似，增删改查的时间复杂度是 O(1)
    不支持 lower_bound()/upper_bound()， 迭代器的++，--

bitset, 圧位
    bitset<10000> s;
    ~, &, |, ^
    >>, <<
    ==, !=
    []

    count()  返回有多少个1

    any()  判断是否至少有一个1
    none()  判断是否全为0

    set()  把所有位置成1
    set(k, v)  将第k位变成v
    reset()  把所有位变成0
    flip()  等价于~
    flip(k) 把第k位取反
```



## 三.搜索与图论

### 1.DFS（stack,空间O(h),不具备最短性,回溯，剪枝）

#### 1.1 排列数字

**[题目：842. 排列数字]()**

**题目描述**

给定一个整数n，将数字1~n排成一排，将会有很多种排列方法。

现在，请你按照字典序将所有的排列方法输出。

**输入格式**

共一行，包含一个整数n。

**输出格式**

按字典序输出所有排列方案，每个方案占一行。

**数据范围**

$1≤n≤7$

**输入样例：**

```c
3
```

**输出样例：**

```c
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```

**题解：**

``` c
dfs爆搜
```

**代码：**

```c
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 10;
int n;
//每次的方案
int path[MAXN];
//判断是否用过
bool vis[MAXN];
//当前位置是u，填充u的数字
void dfs(int u)
{
    //如果已经到最后一个数了则输出结果
    if (u == n)
    {
        //已经放好了，输出
        for (int i = 0; i < n; i++)
        {
            printf("%d ", path[i]);
        }
        puts("");
        return;
    }
    for (int i = 1; i <= n; i++)
    {
        //i还没有用过
        if (!vis[i])
        {
            //放进去答案里面
            path[u] = i;
            //标记
            vis[i] = true;
            //递归下一层
            dfs(u + 1);
            // path[u]=0;       //数字会被覆盖，可以
            //回溯恢复现场
            vis[i] = false;
        }
    }
}
int main()
{
    cin >> n;
    dfs(0);
    return 0;
}
```



#### 1.2 n皇后问题

**[题目：843. n-皇后问题]()**

**题目描述**

n-皇后问题是指将 n 个皇后放在 n∗n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。

现在给定整数n，请你输出所有的满足条件的棋子摆法。

**输入格式**

共一行，包含整数n。

**输出格式**

每个解决方案占n行，每行输出一个长度为n的字符串，用来表示完整的棋盘状态。

其中”.”表示某一个位置的方格状态为空，”Q”表示某一个位置的方格上摆着皇后。

每个方案输出完成后，输出一个空行。

输出方案的顺序任意，只要不重复且没有遗漏即可。

**数据范围**

$1≤n≤9$

**输入样例：**

```c
4
```

**输出样例：**

```c
.Q..
...Q
Q...
..Q. 

..Q.
Q...
...Q
.Q..
```

**题解：**

``` c
dfs+剪枝
```

**代码：**

```c
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 10;
int n;

// dg表示主对角线平行的对角线，udg表示和副对角线平行的对角线
bool row[MAXN], col[MAXN], dg[MAXN * 2], udg[MAXN * 2];

char a[MAXN][MAXN];

//全排列思想,u表示行
void dfs(int u)
{
    if (u == n)
    {
        for (int i = 0; i < n; i++)
            puts(a[i]);
        puts("");
        return;
    }
    for (int i = 0; i < n; i++)
    { //从第一列枚举
        // y=x+k,y=-x+k
        //这里就是k=u+i和k=-u+i,以为可能会有负数，则需k=-u+i+n
        if (!col[i] && !dg[u + i] && !udg[n - u + i])
        {
            //先放皇后
            a[u][i] = 'Q';
            //标记横纵和斜对角线不能放
            col[i] = dg[u + i] = udg[n - u + i] = true;
            //递归下一层
            dfs(u + 1);
            //恢复现场
            col[i] = dg[u + i] = udg[n - u + i] = false;
            a[u][i] = '.';
        }
    }
}

//每个格子分为放与不放两种状态，直到放完
//从(x,y)开始放皇后，当前当了s个皇后
void solve(int x, int y, int s)
{
    //从第一行开始放，如果放到了第一行的最后一个格子
    //就让其出界，也就是y=0，后面行一样的
    if (y == n)
        y = 0, x++;
    //枚举到了最后一行了
    if (x == n)
    {
        //如果皇后个数够了，则保存答案
        if (s == n)
        {
            for (int i = 0; i < n; i++)
                puts(a[i]);
            puts("");
        }
        return;
    }
    //不放皇后，递归下一个格子
    solve(x, y + 1, s);
    //放皇后
    if (!row[x] && !col[y] && !dg[x + y] && !udg[x - y + n])
    {
        //放皇后,记录
        a[x][y] = 'Q';
        //更新状态
        row[x] = col[y] = dg[x + y] = udg[x - y + n] = true;
        //递归下一层
        solve(x, y + 1, s + 1);
        //现场恢复
        row[x] = col[y] = dg[x + y] = udg[x - y + n] = false;
        a[x][y] = '.';
    }
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            a[i][j] = '.';
        }
    }
    // dfs(0);
    solve(0, 0, 0);
    return 0;
}
```



### 2.BFS（queue,空间O(2^h),具备最短性）

#### 2.1 走迷宫

**[题目：AcWing 844. 走迷宫]()**

**题目描述**

给定一个n*m的二维整数数组，用来表示一个迷宫，数组中只包含0或1，其中0表示可以走的路，1表示不可通过的墙壁。

最初，有一个人位于左上角(1, 1)处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。

请问，该人从左上角移动至右下角(n, m)处，至少需要移动多少次。

数据保证(1, 1)处和(n, m)处的数字为0，且一定至少存在一条通路。

**输入格式**

第一行包含两个整数n和m。

接下来n行，每行包含m个整数（0或1），表示完整的二维数组迷宫。

**输出格式**

输出一个整数，表示从左上角移动至右下角的最少移动次数。

**数据范围**

$1≤n,m≤100$

**输入样例：**

```c
5 5
0 1 0 0 0
0 1 0 1 0
0 0 0 0 0
0 1 1 1 0
0 0 0 1 0
```

**输出样例：**

```c
8
```

**题解：**

``` c
 边权都相同的时候可以用bfs
```

**代码：**

```c
#include <bits/stdc++.h>
using namespace std;
const int N = 110;
typedef pair<int, int> PII;
int n, m;
//地图
int g[N][N];
//
int d[N][N];
int Prev[N][N];
PII q[N * N];
int bfs()
{
    //队列hh头tt尾
    int hh = 0, tt = 0;
    q[0] = {0, 0};
    memset(d, -1, sizeof(d));
    d[0][0] = 0; // 走过了
    //上下左右四个方向
    int dx[4] = {-1, 0, 1, 0};
    int dy[4] = {0, 1, 0, -1};
    while (hh <= tt)
    {
        //取队头
        auto t = q[hh++];
        //遍历四个方向
        for (int i = 0; i < 4; i++)
        {
            int x = t.first + dx[i], y = t.second + dy[i];
            //在边界内，且点可以走，并且点没有走过
            if (x >= 0 && x < n && y >= 0 && y < m && g[x][y] == 0 && d[x][y] == -1)
            {
                d[x][y] = d[t.first][t.second] + 1;

                //打印路径记录路径
                // xy这个点是从t出来的
                // Prev[x][y]=t;

                //当前点加进来
                q[++tt] = {x, y};
            }
        }
    }
    //打印路径
    // int x=n-1;m-1;
    // while(x||y){
    //     cout<<x<<' '<<y<<endl;
    //     auto t=Prev[x][y];
    //     x=t.first,y=t.second;
    // }
    return d[n - 1][m - 1];
}
int main()
{
    cin >> n >> m;
    //读入地图
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            cin >> g[i][j];
    cout << bfs() << endl;
    return 0;
}
```



### 3.树与图的深度优先遍历

```c
树与图的存储
树是一种特殊的图，与图的存储方式相同。
对于无向图中的边ab，存储两条有向边a->b, b->a。
因此我们可以只考虑有向图的存储。
(1) 邻接矩阵：g[a][b] 存储边a->b

(2) 邻接表：
// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点
int h[N], e[N], ne[N], idx;

// 添加一条边a->b
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

// 初始化
idx = 0;
memset(h, -1, sizeof h);
```

#### 3.1 树的重心

**[题目：AcWing 846. 树的重心]()**

**题目描述**

给定一颗树，树中包含n个结点（编号1~n）和n-1条无向边。

请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。

重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。

**输入格式**

第一行包含整数n，表示树的结点数。

接下来n-1行，每行包含两个整数a和b，表示点a和点b之间存在一条边。

**输出格式**

输出一个整数m，表示将重心删除后，剩余各个连通块中点数的最大值。

**数据范围**

$1≤n≤10^5$

**输入样例：**

```c
9
1 2
1 7
1 4
2 8
2 5
4 3
3 9
4 6
```

**输出样例：**

```c
4
```

**题解：**

``` c
有向图：邻接矩阵： g[a,b]
       邻接表：单链表
深度优先遍历:
int dfs(int u)
{
    st[u] = true; // st[u] 表示点u已经被遍历过

    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j]) dfs(j);
    }
}
```

**代码：**

```c
#include <bits/stdc++.h>
using namespace std;
const int N = 100010, M = N * 2;
int n;
//全局的答案
int ans = N;
// h存N链表头、e是存的是每个节点的值,ne存的是每个节点的值
int h[N], e[M], ne[M], idx;
//每个点只遍历一次
bool st[N];

//搜索：每个点只遍历一次，返回u为根，子树中点的数量
int dfs(int u)
{
    //当前dfs的点
    st[u] = true; //标记当前点已经搜过
    // sum记录当前点大小，算自己,res每一个连通块大小的最大值
    int sum = 1, res = 0;
    //遍历u的出边
    for (int i = h[u]; i != -1; i = ne[i])
    {                 //遍历u的所有出边
        int j = e[i]; //存当前链表里面节点对应图里面的点的编号
        //没有搜过
        if (!st[j])
        {
            //没有搜过继续搜,s当前子树的大小
            int s = dfs(j);
            res = max(res, s);
            sum += s;
        }
    }
    // n-sum是u节点上面的点数
    res = max(res, n - sum);
    ans = min(ans, res);
    return sum;
}

// void dfs(int u){        //当前dfs的点
//     st[u]=true;         //标记当前点已经搜过
//     for(int i=h[u];i!=-1;i=ne[i]){      //遍历u的所有出边
//         int j=e[i];             //存当前链表里面节点对应图里面的点的编号
//         if(!st[j])  dfs(j);     //没有搜过继续搜
//     }
// }

//邻接表存储插入（头插法）-将b插入a中
void add(int a, int b)
{
    //e记录当前点的值(地址->值),ne下一点的地址(地址->地址)，h记录指向的第一个点的地址(值->地址)
    //a所对应的单链表中插入b  a作为根 
    //插入a指向b的边
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

int main()
{
    cin >> n;
    memset(h, -1, sizeof(h)); // n个头节点全部指向-1
    for (int i = 0; i < n - 1; i++)
    {
        int a, b;
        cin >> a >> b;
        add(a, b), add(b, a); // 无向边
    }
    dfs(1);
    cout << ans << endl;
    return 0;
}
```



### 4.树与图的宽度优先遍历

#### 4.1 图中点的层次

**[题目：AcWing 847. 图中点的层次]()**

**题目描述**

给定一个n个点m条边的有向图，图中可能存在重边和自环。

所有边的长度都是1，点的编号为1~n。

请你求出1号点到n号点的最短距离，如果从1号点无法走到n号点，输出-1。

**输入格式**

第一行包含两个整数n和m。

接下来m行，每行包含两个整数a和b，表示存在一条从a走到b的长度为1的边。

**输出格式**

输出一个整数，表示1号点到n号点的最短距离。

**数据范围**

$1≤n,m≤10^5$

**输入样例：**

```c
4 5
1 2
2 3
3 4
1 3
1 4
```

**输出样例：**

```c
1
```

**题解：**

``` c
宽度优先遍历:
queue<int> q;
st[1] = true; // 表示1号点已经被遍历过
q.push(1);

while (q.size())
{
    int t = q.front();
    q.pop();

    for (int i = h[t]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true; // 表示点j已经被遍历过
            q.push(j);
        }
    }
}    
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 100010;

int n, m;
// h存N链表头、e是存的是每个节点的值,ne存的是每个节点的值
int h[N], e[N], ne[N], idx;
// d表示距离，q
int d[N], q[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

int bfs()
{
    //定义队头和队尾
    int hh = 0, tt = 0;
    //第一个元素为起点1
    q[0] = 1;
    //初始化距离
    memset(d, -1, sizeof d);
    d[1] = 0;
    while (hh <= tt)
    {
        //取队头
        int t = q[hh++];
        //扩展当前点
        for (int i = h[t]; i != -1; i = ne[i])
        {
            //当前可以到达的点
            int j = e[i];
            //没有遍历的话
            if (d[i] == -1)
            {
                //加进来
                d[j] = d[t] + 1;
                //加到队列
                q[++tt] = j;
            }
        }
    }
    return d[n];
}

int main()
{
    cin >> n >> m;
    memset(h, -1, sizeof(h));

    for (int i = 0; i < m; i++)
    {
        int a, b;
        cin >> a >> b;
        add(a, b);
    }
    cout << bfs() << endl;
    return 0;
}
```



### 5.拓扑排序（有向图）

**[题目：AcWing 848. 有向图的拓扑序列]()**

**题目描述**

给定一个n个点m条边的有向图，点的编号是1到n，图中可能存在重边和自环。

请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出-1。

若一个由图中所有点构成的序列A满足：对于图中的每条边(x, y)，x在A中都出现在y之前，则称A是该图的一个拓扑序列。

**输入格式**

第一行包含两个整数n和m

接下来m行，每行包含两个整数x和y，表示存在一条从点x到点y的有向边(x, y)。

**输出格式**

共一行，如果存在拓扑序列，则输出任意一个合法的拓扑序列即可。

否则输出-1。

**数据范围**

$1≤n,m≤10^5$

**输入样例：**

```c
3 3
1 2
2 3
1 3
```

**输出样例：**

```c
1 2 3
```

**题解：**

``` c
有向无环图-拓扑图:时间复杂度 O(n+m), n 表示点数，m 表示边数
所有入度为0的点，放入queue里面
    while(queue不空){
        取队头t
        枚举t的所有的出边t->j
            删除t->j的边，d[j]--;
        	if(d[j]==0)
                j入队
    }
一个有向无环图，一定至少存在一入度为0的点
```

```c
bool topsort()
{
    int hh = 0, tt = -1;

    // d[i] 存储点i的入度
    for (int i = 1; i <= n; i ++ )
        if (!d[i])
            q[ ++ tt] = i;

    while (hh <= tt)
    {
        int t = q[hh ++ ];

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (-- d[j] == 0)
                q[ ++ tt] = j;
        }
    }

    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。
    return tt == n - 1;
}
```

**代码：**

```c
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 100010;

int n, m;

int h[N], e[N], ne[N], idx;
int q[N], d[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

bool topsort()
{
    int hh = 0, tt = -1;
    //所有入度为0的点，放入queue里面
    for (int i = 1; i <= n; i++)
    {
        if (!d[i])
            q[++tt] = i;
    }
    while (hh <= tt)
    {
        //取队头并且删除队头元素
        int t = q[hh++];
        //枚举t的所有的出边t->j
        for (int i = h[t]; i != -1; i = ne[i])
        {
            //删除t->j的边，d[j]--;
            int j = e[i];
            d[j]--;
            //如果入度为0则加如队列
            if (d[j] == 0)
                q[++tt] = j;
        }
    }
    //判断是否空了
    return tt == n - 1;
}

int main()
{
    cin >> n >> m;
    memset(h, -1, sizeof(h));
    for (int i = 0; i < m; i++)
    {
        int a, b;
        cin >> a >> b;
        add(a, b);
        // a->b，则b的入度加一
        d[b]++;
    }
    if (topsort())
    {
        //队列里面的就是拓扑序列
        for (int i = 0; i < n; i++)
            printf("%d ", q[i]);
        puts("");
    }
    else
    {
        puts("-1");
    }
    return 0;
}
```

### 6.最短路

```c
最短路   n个点,m条边
		1.单源最短路(从一个点到其他所有点的最短距离)
 			 1.1 所有边权都是正数(贪心思想)
 			 	(1) 朴素Dijkstra算法（适用于边多，稠密图m~n^2）
 			 		时间复杂度O(n^2)
 			 		
 			 		算法思想(基于贪心，每次找距离最近的点):S表示当前已经确定最短距离的点的集合
 			 		① 初始化距离：dist[1]=0;dist[i]=+∞
 			 		② 迭代
 			 		 for(int i=0;i<n;i++){
 			 			 1）t<--找到不在S中的距离最近的点
 			 			 2）S<--t 将t加入S
 			 			 3）用t更新其他点x到起点1的距离dis[x]=min(dis[x],dis[t]+w)
 			 			 (从t出去的所有点的边，1可以到x,1可以到t再到x点，看dis[x]>dis[t]+w；
 			 			 则可以用t来进行更新)
 			 		 }
 			 		 ③ 遍历n次，更新n次
 			 		 ④ 稠密图：邻接矩阵存
 			 		   稀疏图: 邻接表存
 			 		
 			 	(2) 堆优化版本的Dijkstra算法（稀疏图m~n）
 			 		时间复杂度O(mlogn),n 表示点数，m 表示边数
 			 		
 			 1.2 存在负边权
 			 	(1)Bellman-Ford(边有限制的时候，不超过k条边)（dp思想）
 			 		时间复杂度O(nm)
 			 		算法思想：存边任意方法都可以，比如用结构体
 			 		① 初始化距离：dist[1]=0;dist[i]=+∞
 			 		②迭代n次
 			 		for(int i=0;i<n;i++){
 			 			注意：有时候需要备份backup
 			 			for(所有边 a,b,w)   a--->b权重是w
 			 				//通过a点更新b得距离（松弛操作）
 			 				更新dist[b]=min(dist[b],dist[a]+w);	
					}
					③遍历完之后一定满足三角不等式
					dist[b]<=dist[a]+w
					④有负权回路，最短路径不一定存在
					⑤可以求出是否存在负权回路
						迭代k次，得到最多经过不超过k条边
						
 			 	(2)SPFA 
 			 		可以用Dijkstra算法的题目
 			 		时间复杂度一般O(m),最坏O(nm)
 			 		优化：宽度优先搜索优化
 			 		
 			 		dist[b]=min(dist[b],dist[a]+w);
 			 		只有当dist[a]减小的时候dist[b]才可能减少
 			 		
 			 		算法思想:
 			 		①将起点放入queue
 			 		②while(queue.size()){
                        (1)t=q.front();
                           q.pop();
                        (2)遍历更新所有t的出边
                        	t---->b权值为w
                        	更新之后如果b不在queue里面则将b加入queue
 			 		}
 			 		
 			 		SPFA求负环：利用抽屉原理
 			 			dist[x]表示最短距离
 			 			cnt[x]表示当前最短路的边数
 			 			更新：
 			 			dist[x]=dist[t]+w[i];
 			 			cnt[x]=cnt[t]+1;
 			 			当cnt[x]>=n表示从1到x至少经过了n+1条边，n个点，由抽屉原理至少有一个重复							的数，就存在一个环，则就是存在负环
 			 		
 			 
 		2.多源汇最短路(很多不同起点到其他不同点的情况)
 			Floyd算法，时间复杂度O(n^3)
 			①初始化
 			邻接矩阵存所有点的边d[i][j]
 			②遍历
 			for(int k=1;k<=n;k++)
 				for(int i=1;i<=n;i++)
 					for(int j=1;j<=n;j++)
 						d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
 			d[i][j]存的是i到j的最短路径长度
 			③dp思想
 			d[k,i,j]表示从第i出发只经过k，j的最短路径
 			d[k,i,j]=d[k-1,i,k]+d[k-1,k,j]
            d[i][j]=d[i][k]+d[k][j]
 		
```

#### 6.1 Dijkstra求最短路 I 

**[题目：AcWing 849. Dijkstra求最短路 I]()**

**题目描述**

给定一个n个点m条边的有向图，图中可能存在重边和自环，所有边权均为正值。

请你求出1号点到n号点的最短距离，如果无法从1号点走到n号点，则输出-1。

**输入格式**

第一行包含整数n和m。

接下来m行每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。

**输出格式**

输出一个整数，表示1号点到n号点的最短距离。

如果路径不存在，则输出-1。

**数据范围**

$1≤n≤500,$
$1≤m≤10^5,$

图中涉及边长均不超过10000。

**输入样例：**

```r
3 3
1 2 2
2 3 1
1 3 4
```

**输出样例：**

```
3
```

**题解：**

``` c
朴素Dijkstra算法：（适用于边多，稠密图m~n^2）
 			 		时间复杂度O(n^2)
 			 		
 			 		算法思想(基于贪心，每次找距离最近的点):S表示当前已经确定最短距离的点的集合
 			 		① 初始化距离：dist[1]=0;dist[i]=+∞
 			 		② 迭代
 			 		 for(int i=0;i<n;i++){
 			 			 1）t<--找到不在S中的距离最近的点
 			 			 2）S<--t 将t加入S
 			 			 3）用t更新其他点x到起点1的距离dis[x]=min(dis[x],dis[t]+w)
 			 			 (从t出去的所有点的边，1可以到x,1可以到t再到x点，看dis[x]>dis[t]+w；
 			 			 则可以用t来进行更新)
 			 		 }
 			 		 ③ 遍历n次，更新n次
 			 		 ④ 稠密图：邻接矩阵存
 			 		   稀疏图: 邻接表存
```

```c
int g[N][N]; //存储每条边
int dist[N]; //存储1号点到每个点的最短距离
bool st[N];  //表示当前的最短路是否已经确定了

int n, m;

// 求1号点到n号点的最短路，如果不存在则返回-1
int dijkstra()
{
    // 1.初始化距离：dist[1]=0;dist[i]=+∞,0x3f代表无限大
    memset(dist, 0x3f, sizeof dist);

    dist[1] = 0; //第一个点到自身的距离为0

    //在st[j]为false的点中找dist最小的点
    //for (int i = 0; i < n; i++)	这里重复进行n-1次就可以
    for (int i = 1; i < n; i++)
    {
        int t = -1; // t存储当前访问的点
        //当前点还没有确定最短路，并且点t不在S中或者距离最近
        for (int j = 1; j <= n; j++)
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        //优化可以加
        if (t == n)
            break;

        // 2）S < --t 将t加入S
        st[t] = true;

        // 3）用t更新其他点x到起点1的距离dist[x] = min(dis[x], dis[t] + w)
        //(从t出去的所有点的边，1可以到x, 1可以到t再到x点，看dis [x] > dis[t] + w；
        for (int j = 1; j <= n; j++)
            dist[j] = min(dist[j], dist[t] + g[t][j]);
    }
    //如果第n个点路径为无穷大即不存在最低路径
    if (dist[n] == 0x3f3f3f3f)
        return -1;
    return dist[n];
}
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;

const int N = 510;

int g[N][N]; //存储每条边
int dist[N]; //存储1号点到每个点的最短距离
bool st[N];  //表示当前的最短路是否已经确定了

int n, m;

// 求1号点到n号点的最短路，如果不存在则返回-1
int dijkstra()
{
    // 1.初始化距离：dist[1]=0;dist[i]=+∞,0x3f代表无限大
    memset(dist, 0x3f, sizeof dist);

    dist[1] = 0; //第一个点到自身的距离为0

    //在st[j]为false的点中找dist最小的点
    //for (int i = 0; i < n; i++)	这里重复进行n-1次就可以
    for (int i = 1; i < n; i++)
    {
        int t = -1; // t存储当前访问的点
        //当前点还没有确定最短路，并且点t不在S中或者距离最近
        for (int j = 1; j <= n; j++)
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        //优化可以加
        if (t == n)
            break;

        // 2）S < --t 将t加入S
        st[t] = true;

        // 3）用t更新其他点x到起点1的距离dist[x] = min(dis[x], dis[t] + w)
        //(从t出去的所有点的边，1可以到x, 1可以到t再到x点，看dis [x] > dis[t] + w；
        for (int j = 1; j <= n; j++)
            dist[j] = min(dist[j], dist[t] + g[t][j]);
    }
    //如果第n个点路径为无穷大即不存在最低路径
    if (dist[n] == 0x3f3f3f3f)
        return -1;
    return dist[n];
}
int main()
{
    cin >> n >> m;

    //存在重复边和自环，如果存在多条边的话就保存最短的一条边
    memset(g, 0x3f, sizeof g);
    // for (int i = 1; i <= n; i++)
    //     for (int j = 1; j <= n; j++)
    //         if (i == j)
    //             g[i][j]=0;
    //             else g[i][j]=INF;

    while (m--)
    {
        int a, b, c;
        cin >> a >> b >> c;
        //存在多条边
        g[a][b] = min(g[a][b], c);
    }

    int t = dijkstra();
    cout << t << endl;
    return 0;
}
```



#### 6.2 堆优化Dijkstra求最短路 II

**[题目：Dijkstra求最短路 II]()**

**题目描述**

给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为非负值。

请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。

**输入格式**

第一行包含整数 n 和 m。

接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。

**输出格式**

输出一个整数，表示 1 号点到 n 号点的最短距离。

如果路径不存在，则输出 −1。

**数据范围**

$1≤n,m≤1.5×10^5$
图中涉及边长均不小于 0，且不超过 10000。
数据保证：如果最短路存在，则最短路的长度不超过 $10^9$。

**输入样例：**

```r
3 3
1 2 2
2 3 1
1 3 4
```

**输出样例：**

```
3
```

**题解：**

``` c
优先队列+dijkstra
typedef pair<int, int> PII;

int n;      // 点的数量
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储所有点到1号点的距离
bool st[N];     // 存储每个点的最短距离是否已确定

// 求1号点到n号点的最短距离，如果不存在，则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    //第一维距离值，第二维节点编号
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});      // first存储距离，second存储节点编号

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();

        int ver = t.second, distance = t.first;

        if (st[ver]) continue;
        st[ver] = true;

        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>
using namespace std;

typedef pair<int, int> PII;
const int N = 100010;
//邻接表存储
int h[N], e[N], ne[N], w[N], idx; // w存权重
int dist[N];                      //存储1号点到每个点的最短距离
bool st[N];                       //表示当前的最短路是否已经确定了

int n, m;

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}

// 求1号点到n号点的最短路，如果不存在则返回-1
int dijkstra()
{
    // 1.初始化距离：dist[1]=0;dist[i]=+∞,0x3f代表无限大
    memset(dist, 0x3f, sizeof dist);

    dist[1] = 0; //第一个点到自身的距离为0
	//第一维距离值，第二维节点编号
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    //把第一个点放进来，编号是1,距离值是0
    heap.push({0, 1});

    while (heap.size())
    {
        //每次找到距离最近的点，就是堆的起点
        auto t = heap.top();
        heap.pop();

        // ver表示编号，distance表示距离
        int ver = t.second, distance = t.first;
        //如果ver之前已经处理了，是冗余备份，则跳过
        if (st[ver])
            continue;
        //用当前点t更新其他点
        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }

    //如果第n个点路径为无穷大即不存在最低路径
    if (dist[n] == 0x3f3f3f3f)
        return -1;
    return dist[n];
}
int main()
{
    cin >> n >> m;

    //初始化邻接表的表头
    memset(h, -1, sizeof(h));

    while (m--)
    {
        int a, b, c;
        cin >> a >> b >> c;
        //存
        add(a, b, c);
    }

    int t = dijkstra();
    cout << t << endl;
    return 0;
}
```

**spfa版本**

```c
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>
using namespace std;

typedef pair<int, int> PII;
const int N = 100010;
//邻接表存储
int h[N], e[N], ne[N], w[N], idx; // w存权重
int dist[N];                      //存储1号点到每个点的最短距离
bool st[N];                       //表示当前的是否在队列中

int n, m;

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}

// 求1号点到n号点的最短路，如果不存在则返回-1
int spfa()
{
    //初始化所有点的距离
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    //队列存储待更新的点
    queue<int> q;
    // 1号点放入队列
    q.push(1);
    st[1] = true;

    while (q.size())
    {
        int t = q.front();
        q.pop();
        st[t] = false; //从队列中出来了置为false

        //遍历更新所有t的出边
        for (int i = h[t]; i != -1; i = ne[i])
        {
            //当前点
            int j = e[i];
            //更新t---->b权值为w
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                //更新之后如果b不在queue里面则将b加入queue
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    if (dist[n] == 0x3f3f3f3f)
        return -1;
    return dist[n];
}
int main()
{
    cin >> n >> m;

    //初始化邻接表的表头
    memset(h, -1, sizeof(h));

    while (m--)
    {
        int a, b, c;
        cin >> a >> b >> c;
        //存
        add(a, b, c);
    }

    int t = spfa();
    cout << t << endl;
    return 0;
}
```



#### 6.3 bellman-ford

**[题目：853. 有边数限制的最短路]()**

**题目描述**

给定一个n个点m条边的有向图，图中可能存在重边和自环， 边权可能为负数。

请你求出从1号点到n号点的最多经过k条边的最短距离，如果无法从1号点走到n号点，输出impossible。

注意：图中可能 存在负权回路 。

**输入格式**

第一行包含三个整数n，m，k。

接下来m行，每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。

**输出格式**

输出一个整数，表示从1号点到n号点的最多经过k条边的最短距离。

如果不存在满足条件的路径，则输出“impossible”。

**数据范围**

$1≤n,k≤500,$
$1≤m≤10000,$

任意边长的绝对值不超过10000。

**输入样例：**

```r
3 3 1
1 2 1
2 3 1
1 3 3
```

**输出样例：**

```
3
```

**题解：**

``` c
Bellman-Ford(边有限制的时候，不超过k条边)（dp思想）
 	时间复杂度O(nm)
 	算法思想：存边任意方法都可以，比如用结构体
 	① 初始化距离：dist[1]=0;dist[i]=+∞
 	② 迭代n次
 	for(int i=0;i<n;i++){
 		注意：有时候需要备份backup
 		for(所有边 a,b,w)   a--->b权重是w
 			 //通过a点更新b得距离（松弛操作）
 			 更新dist[b]=min(dist[b],dist[a]+w);	
		}
	③遍历完之后一定满足三角不等式
	dist[b]<=dist[a]+w
	④有负权回路，最短路径不一定存在
	⑤可以求出是否存在负权回路
	迭代k次，得到最多经过不超过k条边
```

```c
模板：
int n, m;       // n表示点数，m表示边数
int dist[N];        // dist[x]存储1到x的最短路距离

struct Edge     // 边，a表示出点，b表示入点，w表示边的权重
{
    int a, b, w;
}edges[M];

// 求1到n的最短路距离，如果无法从1走到n，则返回-1。
int bellman_ford()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。
    for (int i = 0; i < n; i ++ )
    {
        for (int j = 0; j < m; j ++ )
        {
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;
            if (dist[b] > dist[a] + w)
                dist[b] = dist[a] + w;
        }
    }

    if (dist[n] > 0x3f3f3f3f / 2) return -1;
    return dist[n];
}
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

// n点m边
const int N = 510, M = 10010;

int n, m, k;
// backup用于备份，有k次限制，如果按照dijkstra算法的话不一定得到的是k次的结果
int dist[N], backup[N];

//结构体存边
struct Edge
{
    //起点终点和权重
    int a, b, w;
} edges[M];

int bellman_ford()
{
    //初始化
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    //不超过K次,则迭代K次
    for (int i = 0; i < k; i++)
    {
        //更新得时候只用上一次迭代的结果，先将上一次的结果backup备份下
        memcpy(backup, dist, sizeof(dist));
        for (int j = 0; j < m; j++)
        {
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;
            //用上一次的结果迭代更新b，则不会发生串联了
            dist[b] = min(dist[b], backup[a] + w);
        }
    }
    //最后可能不是正无穷，所以写大于某一个大的数
    if (dist[n] > 0x3f3f3f3f / 2)
        return -1;
    return dist[n];
}

int main()
{
    cin >> n >> m >> k;
    for (int i = 0; i < m; i++)
    {
        int a, b, w;
        cin >> a >> b >> w;
        edges[i] = {a, b, w};
    }
    int t = bellman_ford();
    if (t == -1)
        puts("impossible");
    else
        cout << t << endl;
    return 0;
}
```



#### 6.4 spfa

**[题目：AcWing 851. spfa求最短路]()**

**题目描述**

给定一个n个点m条边的有向图，图中可能存在重边和自环， 边权可能为负数。

请你求出1号点到n号点的最短距离，如果无法从1号点走到n号点，则输出impossible。

数据保证不存在负权回路。

**输入格式**

第一行包含整数n和m。

接下来m行每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。

**输出格式**

输出一个整数，表示1号点到n号点的最短距离。

如果路径不存在，则输出”impossible”。

**数据范围**

$1≤n,m≤10^5,$

图中涉及边长绝对值均不超过10000。

**输入样例：**

```r
3 3
1 2 5
2 3 -3
1 3 4
```

**输出样例：**

```
2
```

**题解：**

``` c
SPFA:
 	可以用Dijkstra算法的题目
 	时间复杂度一般O(m),最坏O(nm)
 	优化：宽度优先搜索优化
 			 		
 	//dist[b]=min(dist[b],dist[a]+w);
 	只有当dist[a]减小的时候dist[b]才可能减少
 			 		
 	算法思想:
 	①将起点放入queue
 	②while(queue.size()){
      	(1)t=q.front();
           q.pop();
      	(2)遍历更新所有t的出边
           t---->b权值为w
           更新之后如果b不在queue里面则将b加入queue
 	 }
 	 
```

```c
模板实现：
int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储每个点到1号点的最短距离
bool st[N];     // 存储每个点是否在队列中

// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1
int spfa()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    queue<int> q;
    q.push(1);
    st[1] = true;

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>
using namespace std;

typedef pair<int, int> PII;
const int N = 100010;
//邻接表存储
int h[N], e[N], ne[N], w[N], idx; // w存权重
int dist[N];                      //存储1号点到每个点的最短距离
bool st[N];                       //表示当前的是否在队列中

int n, m;

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}

// 求1号点到n号点的最短路，如果不存在则返回-1
int spfa()
{
    //初始化所有点的距离
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    //队列存储待更新的点
    queue<int> q;
    // 1号点放入队列
    q.push(1);
    st[1] = true;	//	是否在队列中

    while (q.size())
    {
        int t = q.front();
        q.pop();
        st[t] = false; //从队列中出来了置为false

        //遍历更新所有t的出边
        for (int i = h[t]; i != -1; i = ne[i])
        {
            //当前点
            int j = e[i];
            //更新t---->b权值为w
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                //更新之后如果b不在queue里面则将b加入queue
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    if (dist[n] == 0x3f3f3f3f)
        return -1;
    return dist[n];
}
int main()
{
    cin >> n >> m;

    //初始化邻接表的表头
    memset(h, -1, sizeof(h));

    while (m--)
    {
        int a, b, c;
        cin >> a >> b >> c;
        //存
        add(a, b, c);
    }

    int t = spfa();
    if (t == -1)
        puts("impossible");
    else
        cout << t << endl;
    return 0;
}
```



**[题目：AcWing 852. spfa判断负环]()**

**题目描述**

给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， **边权可能为负数**。

请你判断图中是否存在负权回路。

**输入格式**

第一行包含整数 n 和 m。

接下来 m 行每行包含三个整数x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。

**输出格式**

如果图中**存在**负权回路，则输出 `Yes`，否则输出 `No`。

**数据范围**

$1≤n≤2000,$
$1≤m≤10000,$
图中涉及边长绝对值均不超过 10000。

**输入样例：**

```r
3 3
1 2 -1
2 3 4
3 1 -4
```

**输出样例：**

```
Yes
```

**题解：**

``` 
SPFA求负环：利用抽屉原理
 	dist[x]表示最短距离
 	cnt[x]表示当前最短路的边数
 	更新：
 	dist[x]=dist[t]+w[i];
 	cnt[x]=cnt[t]+1;
 	当cnt[x]>=n表示从1到x至少经过了n+1条边，n个点，由抽屉原理至少有一个重复							的数，就存在一个环，则就是存在负环
```

```c
int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N], cnt[N];        // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数
bool st[N];     // 存储每个点是否在队列中

// 如果存在负环，则返回true，否则返回false。
bool spfa()
{
    // 不需要初始化dist数组
    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。

    queue<int> q;
    for (int i = 1; i <= n; i ++ )
    {
        q.push(i);
        st[i] = true;
    }

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if (cnt[j] >= n) return true;       // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    return false;
}
```



**代码：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>
using namespace std;

typedef pair<int, int> PII;
const int N = 100010;
//邻接表存储
int h[N], e[N], ne[N], w[N], idx; // w存权重
int dist[N], cnt[N];              // dist存储1号点到每个点的最短距离
bool st[N];                       //表示当前的是否在队列中

int n, m;

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}

// 求1号点到n号点的最短路，如果不存在则返回-1
int spfa()
{
    //队列存储待更新的点
    queue<int> q;
    // 所有点放入队列i
    for (int i = 1; i <= n; i++)
    {
        q.push(i);
        st[i] = true;
    }

    while (q.size())
    {
        int t = q.front();
        q.pop();
        st[t] = false; //从队列中出来了置为false

        //遍历更新所有t的出边
        for (int i = h[t]; i != -1; i = ne[i])
        {
            //当前点
            int j = e[i];
            //更新t---->b权值为w
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if (cnt[j] >= n)
                    return true;
                //更新之后如果b不在queue里面则将b加入queue
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    return false;
}
int main()
{
    cin >> n >> m;

    //初始化邻接表的表头
    memset(h, -1, sizeof(h));

    while (m--)
    {
        int a, b, c;
        cin >> a >> b >> c;
        //存
        add(a, b, c);
    }

    if (spfa())
        puts("Yes");
    else
        puts("No");
    return 0;
}
```



#### 6.5 Floyd

**[题目：AcWing 854. Floyd求最短路]()**

**题目描述**

给定一个n个点m条边的有向图，图中可能存在重边和自环，边权可能为负数。

再给定k个询问，每个询问包含两个整数x和y，表示查询从点x到点y的最短距离，如果路径不存在，则输出“impossible”。

数据保证图中不存在负权回路。

**输入格式**

第一行包含三个整数n，m，k

接下来m行，每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。

接下来k行，每行包含两个整数x，y，表示询问点x到点y的最短距离。

**输出格式**

共k行，每行输出一个整数，表示询问的结果，若询问两点间不存在路径，则输出“impossible”。

**数据范围**

$1≤n≤200,$
$1≤k≤n^2$
$1≤m≤20000,$
图中涉及边长绝对值均不超过10000。

**输入样例：**

```r
3 3 2
1 2 1
2 3 2
1 3 1
2 1
1 3
```

**输出样例：**

```
impossible
1
```

**题解：**

``` 
Floyd算法，时间复杂度O(n^3)
①初始化
 邻接矩阵存所有点的边d[i][j]
②遍历
 for(int k=1;k<=n;k++)
 	for(int i=1;i<=n;i++)
 		for(int j=1;j<=n;j++)
 			d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
 d[i][j]存的是i到j的最短路径长度
```

```c
初始化：
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            if (i == j) d[i][j] = 0;
            else d[i][j] = INF;

// 算法结束后，d[a][b]表示a到b的最短距离
void floyd()
{
    for (int k = 1; k <= n; k ++ )
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;

const int N = 210, INF = 1e9;

int n, m, k;
//邻接矩阵存
int d[N][N];

void floyd()
{
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}

int main()
{
    cin >> n >> m >> k;
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            if (i == j)
                d[i][j] = 0;
            else
                d[i][j] = INF;
        }
    }
    while (m--)
    {
        int a, b, w;
        cin >> a >> b >> w;
        //如果有多条边的话保留最小的边就可以了
        d[a][b] = min(d[a][b], w);
    }
    floyd();

    while (k--)
    {
        int a, b;
        cin >> a >> b;
        if (d[a][b] > INF / 2)
            puts("impossible");
        else
            cout << d[a][b] << endl;
    }
    return 0;
}
```





### 7.最小生成树

```c
最小生成树 
    1.普利姆算法(Prim)
    	1.1 朴素版Prim---常用
    		时间复杂度o(N^2)
    		适用于稠密图
    
    		算法思想：S表示当前已经在连通块中所有的点的集合
    		①初始化为＋∞
    		dist[i]<--＋∞
    		②迭代
    		for(int i=0;i<n;i++){
                (1)找到集合S外距离最近的点--->t
                (2)用t更新其他点到集合S的距离
                (3)st[t]=true
            }

    	1.2 堆优化版Prim 
    		时间复杂度O(mlogn)
    		适用于稀疏图
    		
    2.克鲁斯卡尔算法(Kruskal)---常用
    	时间复杂度O(mlongm)
    	适用于稀疏图
            
        算法思想：
           ①将所有边按照权重从小到大排序(快排)  O(mlongm)
           ②枚举每条边a---b，权重是c
            if a,b不连通
                将这条边a--b加入集合中
		   ③并查集维护
```

#### 7.1 Prim

**[题目：AcWing 858. Prim算法求最小生成树]()**

**题目描述**

给定一个n个点m条边的无向图，图中可能存在重边和自环，边权可能为负数。

求最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。

给定一张边带权的无向图G=(V, E)，其中V表示图中点的集合，E表示图中边的集合，n=|V|，m=|E|。

由V中的全部n个顶点和E中n-1条边构成的无向连通子图被称为G的一棵生成树，其中边的权值之和最小的生成树被称为无向图G的最小生成树。

**输入格式**

第一行包含两个整数n和m。

接下来m行，每行包含三个整数u，v，w，表示点u和点v之间存在一条权值为w的边。

**输出格式**

共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。

**数据范围**

$1≤n≤500,$
$1≤m≤10^5,$
图中涉及边的边权的绝对值均不超过10000。

**输入样例：**

```r
4 5
1 2 1
1 3 2
1 4 3
2 3 2
3 4 4
```

**输出样例：**

```
6
```

**题解：**

``` c
朴素版prim:时间复杂度是O(n2+m), n 表示点数，m 表示边数
int n;      // n表示点数
int g[N][N];        // 邻接矩阵，存储所有边
int dist[N];        // 存储其他点到当前最小生成树的距离
bool st[N];     // 存储每个点是否已经在生成树中


// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和
int prim()
{
    memset(dist, 0x3f, sizeof dist);

    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        if (i && dist[t] == INF) return INF;

        if (i) res += dist[t];
        st[t] = true;

        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    }

    return res;
}
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;

const int N = 510, INF = 0x3f3f3f3f;
int n, m;
//邻接矩阵存稠密图
int g[N][N];
//表示到集合的距离
int dist[N];
//判断是否在集合里面
bool st[N];

int prim()
{
    //初始化为＋∞
    memset(dist, 0x3f, sizeof(dist));

    int res = 0;
    for (int i = 0; i < n; i++)
    {
        //(1)找到集合S外距离最近的点--->t
        int t = -1;

        for (int j = 1; j <= n; j++)
        {
            //如果没有在树中，且到树的距离最短，则选择该点
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        }

        //如果不是第一个点并且距离为正无穷(图不连通的)
        if (i && dist[t] == INF)
            return INF;
        
        //否则如果不是第一个点则加入
        if (i)
            res += dist[t]; //先累加后更新，防止加入自环

        //(2)用t更新其他点到集合S的距离
        for (int j = 1; j <= n; j++)
            dist[j] = min(dist[j], g[t][j]);

        //(3)st[t]=true,t标记为已经在集合里面
        st[t] = true;
    }
    return res;
}

int main()
{
    cin >> n >> m;
    //存在重复边，初始化为正无穷
    memset(g, 0x3f, sizeof(g));
    while (m--)
    {
        int a, b, c;
        cin >> a >> b >> c;
        //处理重复边
        g[a][b] = g[b][a] = min(g[a][b], c);
    }
    int t = prim();
    if (t == INF)
        puts("impossible");
    else
        cout << t << endl;
    return 0;
}
```



#### 7.2 Kruskal

**[题目：AcWing 859. Kruskal算法求最小生成树]()**

**题目描述**

给定一个n个点m条边的无向图，图中可能存在重边和自环，边权可能为负数。

求最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。

给定一张边带权的无向图G=(V, E)，其中V表示图中点的集合，E表示图中边的集合，n=|V|，m=|E|。

由V中的全部n个顶点和E中n-1条边构成的无向连通子图被称为G的一棵生成树，其中边的权值之和最小的生成树被称为无向图G的最小生成树。

**输入格式**

第一行包含两个整数n和m。

接下来m行，每行包含三个整数u，v，w，表示点u和点v之间存在一条权值为w的边。

**输出格式**

共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。

**数据范围**

$1≤n≤10^5,$
$1≤m≤2∗10^5,$
图中涉及边的边权的绝对值均不超过1000。

**输入样例：**

```r
4 5
1 2 1
1 3 2
1 4 3
2 3 2
3 4 4
```

**输出样例：**

```
6
```

**题解：**

``` c
并查集+kruskal:时间复杂度是O(mlogm), n 表示点数，m 表示边数
int n, m;       // n是点数，m是边数
int p[N];       // 并查集的父节点数组

struct Edge     // 存储边
{
    int a, b, w;

    bool operator< (const Edge &W)const
    {
        return w < W.w;
    }
}edges[M];

int find(int x)     // 并查集核心操作
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int kruskal()
{
    sort(edges, edges + m);

    for (int i = 1; i <= n; i ++ ) p[i] = i;    // 初始化并查集

    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;

        a = find(a), b = find(b);
        if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并
        {
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }

    if (cnt < n - 1) return INF;
    return res;
}
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 200010;

int n, m;
//并查集,存储每个点的祖宗节点
int p[N];

struct Edge
{
    int a, b, w;
    //重载运算符按照1权重排序
    bool operator<(const Edge &W) const
    {
        return w < W.w;
    }
} edges[N];

// 返回x的祖宗节点
int find(int x)
{
    if (p[x] != x)
        p[x] = find(p[x]);
    return p[x];
}

int main()
{
    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b, w;
        cin >> a >> b >> w;
        edges[i] = {a, b, w};
    }

    //对边进行排序
    sort(edges, edges + m);
    //初始化并查集
    for (int i = 1; i <= n; i++)
        p[i] = i;

    // res存的是最小生成树中所有数边的权重之和
    // cnt存的是当前最小生成树集合里面加入了多少条边
    int res = 0, cnt = 0;

    //从小到大枚举边
    for (int i = 0; i < m; i++)
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
        a = find(a), b = find(b);
        //如果不连通，将边加进来
        if (a != b)
        {
            //合并
            p[a] = b;
            res += w; //权重加到总和里面
            cnt++;    //最小生成树集合点数加一
        }
    }
    //如果边数小于所有边，则表示不连通
    if (cnt < n - 1)
        puts("impossible");
    else
        cout << res << endl;
    return 0;
}
```



### 8.二分图：染色法、匈牙利算法

```
二分图
	一个图是二分图，当且仅当图中不含奇数(边数)环
	1.染色法
		时间复杂度O(n+m)
		dfs
		一条边得两个颜色不属于同一个颜色；
		由于途中不含奇数环，所以染色过程中一定没有矛盾；
		算法思想：
		for(int i=1;i<=n;i++){
			if i未染色
				dfs(i，1)将i所有得连通块染色为1
		}
		
	2.匈牙利算法
		给定一个二分图，匹配成功中，求最大匹配；
		
		时间复杂度O(mn),实际运行时间一般远小于O(mn)
		
```



#### 8.1 染色法

**[题目：AcWing 860. 染色法判定二分图 ]()**

**题目描述**

给定一个n个点m条边的无向图，图中可能存在重边和自环。

请你判断这个图是否是二分图。

**输入格式**

第一行包含两个整数n和m。

接下来m行，每行包含两个整数u和v，表示点u和点v之间存在一条边。

**输出格式**

如果给定图是二分图，则输出“Yes”，否则输出“No”。

**数据范围**

$1≤n,m≤10^5$

**输入样例：**

```r
4 4
1 3
1 4
2 3
2 4
```

**输出样例：**

```
Yes
```

**题解：**

``` c
dfs染色
int n;      // n表示点数
int h[N], e[M], ne[M], idx;     // 邻接表存储图
int color[N];       // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色

// 参数：u表示当前节点，c表示当前点的颜色
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }

    return true;
}

bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```

**代码：**

```c
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 100010, M = 200010;

int n, m;
//邻接表存储图
int h[N], e[N], ne[N], idx;
int color[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

//染色为1和2
bool dfs(int u, int c)
{
    //记录染色
    color[u] = c;
    //遍历当前点得邻点
    for (int i = h[u]; i != -1; i = ne[i])
    {
        //存储当前点得编号
        int j = e[i];
        //如果当前点没有被染色
        if (!color[j])
        {
            if (!dfs(j, 3 - c))
                return false;
        }
        //如果两个点的颜色相同则染色失败
        else if (color[j] == c)
            return false;
    }
    return true;
}

int main()
{
    cin >> n >> m;
    memset(h, -1, sizeof h);

    while (m--)
    {
        int a, b;
        cin >> a >> b;
        add(a, b), add(b, a);
    }
    //表示染色得时候是否有矛盾发生
    bool flag = true;
    //遍历染色
    for (int i = 1; i <= n; i++)
    {
        //如果当前点没有被染色
        if (!color[i])
        {
            //如果染色过程发生了矛盾，则把flag标记
            if (!dfs(i, 1))
            {
                flag = false;
                break;
            }
        }
    }
    if (flag)
        puts("Yes");
    else
        puts("No");
    return 0;
}
```



#### 8.2 匈牙利算法

**[题目：AcWing 861. 二分图的最大匹配]()**

**题目描述**

给定一个二分图，其中左半部包含n1个点（编号1-n1），右半部包含n2个点（编号1~n2），二分图共包含m条边。

数据保证任意一条边的两个端点都不可能在同一部分中。

请你求出二分图的最大匹配数。

> 二分图的匹配：给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。
>
> 二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。

**输入格式**

第一行包含三个整数 n1、n2 和 m。

接下来m行，每行包含两个整数u和v，表示左半部点集中的点u和右半部点集中的点v之间存在一条边。

**输出格式**

输出一个整数，表示二分图的最大匹配数。

**数据范围**

$1≤n1,n2≤500,$
$1≤u≤n1,$
$1≤v≤n2,$
$1≤m≤10^5$

**输入样例：**

```r
2 2 4
1 1
1 2
2 1
2 2
```

**输出样例：**

```
2
```

**题解：**

``` c
int n1, n2;     // n1表示第一个集合中的点数，n2表示第二个集合中的点数
int h[N], e[M], ne[M], idx;     // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边
int match[N];       // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个
bool st[N];     // 表示第二个集合中的每个点是否已经被遍历过

bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }

    return false;
}

// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点
int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```

**代码：**

```c
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 510, M = 100010;

int n1, n2, m;
//邻接表
int h[N], e[M], ne[M], idx;
//右边点对应的点   a----->b,b所对应的点
int match[N];
//判重，每次不要搜同一个点
bool st[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        //当前点的编号
        int j = e[i];
        //如果当前点和x还没有匹配
        if (!st[j])
        {
            //标记为匹配了
            st[j] = true;
            //如果当前点可以和x匹配 或者 可以找到和当前点匹配的点，该点可以找到匹配的
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }

    return false;
}

int main()
{
    scanf("%d%d%d", &n1, &n2, &m);

    memset(h, -1, sizeof h);

    while (m--)
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b);
    }

    int res = 0;
    //遍历找
    for (int i = 1; i <= n1; i++)
    {
        //每次找先将标记数组清空
        memset(st, false, sizeof st);
        //如果i找到匹配的答案更新
        if (find(i))
            res++;
    }

    printf("%d\n", res);

    return 0;
}
```



## 四.数学知识

### 1.质数

#### 1.1 AcWing 866. 试除法判定质数  

**[题目：]()**

**题目描述**

给定 $n $个正整数 $ai$，判定每个数是否是质数。

**输入格式**

第一行包含整数 $n$。

接下来 $n$ 行，每行包含一个正整数 $a_i$。

**输出格式**

共 n 行，其中第 i 行输出第 i 个正整数 ai 是否为质数，是则输出 `Yes`，否则输出 `No`。

**数据范围**

$1≤n≤100$,
$1≤ai≤2^{31}−1$

**输入样例：**

```r
2
2
6
```

**输出样例：**

```
Yes
No
```

**题解：**

- **质数：**针对所有大于 $1$​​​ 的自然数来说，如果只包含 $1$​​ 和本身 这两个约数，就被称为质数，或者叫素数；否则被称为 合数

> 所有 $\leq 1$ 的数 既不是质数，也不是合数

- **约数：**若 $d$ 能整除 $n$，或者说 $n$ 能被 $d$ 整除，或者说 $n$ 是 $d$​ 的倍数，则称 $d$ 为 $n$ 的约数或因子，记作 $d|n$

>若 $d$ 为质数，则称 $d$ 为质因子

``` c
//试除法O(n)
bool is_prime1(int n)
{
    if (n < 2)
        return false;
    for (int i = 2; i < n; i++)
        if (n % i == 0)
            return false;
    return true;
}
```

- 时间复杂度为 $O(n)$

  

```c
  //优化
  bool is_prime(int n)
  {
      if (n < 2)
          return false;
      /*
      这两种方式都不推荐
      (1) i*i<n  可能溢出了
      (2) i<sqrt(n)  每次都需要计算sqrt会慢了
      */
      for (int i = 2; i <= n / i; i++)
          if (n % i == 0)
              return false;
      return true;
  }
```

- **性质：如果 $d|n$​​ （$d$​ 能整除 $n$​），那么显然 $\frac{n}{d}|n$​​​​，也就是说，约数总是成对出现的​（$d$​,$\frac{n}{d})$​​**

> 例如，$n=12$，则$\frac{12}{3}=4$，同理有 $\frac{12}{4}=3$

- 所以在枚举时，只需要枚举每对之中较小的那个，则有 $d \leq \frac{n}{d} \to d^2 \leq n \to d \leq \sqrt n$

- 可以发现，$d$ 只需要枚举到 $\sqrt n$​ 即可，时间复杂度就可以降到 $O(\sqrt n)$

> 不推荐写成 `for(int i=1;i<=sqrt(n);++i`，因为每次循环都会求一次 $\sqrt n$​ 的值​
>
> 也不推荐写成 `for(int i=1;i*i<=n;++i`，因为当 $n$​​ 接近于 `int` 的最大值时，`i` 是存在溢出风险的

**代码：**

```c
#include <bits/stdc++.h>
using namespace std;
const int N = 110;
int a[N];
int n;
//试除法O(n)
bool is_prime1(int n)
{
    if (n < 2)
        return false;
    for (int i = 2; i < n; i++)
        if (n % i == 0)
            return false;
    return true;
}

//优化
bool is_prime(int n)
{
    if (n < 2)
        return false;
    /*
    这两种方式都不推荐
    (1) i*i<n  可能溢出了
    (2) i<sqrt(n)  每次都需要计算sqrt会慢了
    */
    for (int i = 2; i <= n / i; i++)
        if (n % i == 0)
            return false;
    return true;
}

int main()
{
    cin >> n;
    while (n--)
    {
        int x;
        cin >> x;
        if (is_prime(x))
            puts("Yes");
        else
            puts("No");
    }
    return 0;
}
```



#### 1.2 AcWing 867. 分解质因数  

**[题目：]()**

**题目描述**

给定 $n$ 个正整数 $a_i$，将每个数分解质因数，并按照质因数从小到大的顺序输出每个质因数的底数和指数。

**输入格式**

第一行包含整数 $n$。

接下来 $n$ 行，每行包含一个正整数 $a_i$。

**输出格式**

对于每个正整数 $a_i$，按照从小到大的顺序输出其分解质因数后，每个质因数的底数和指数，每个底数和指数占一行。

每个正整数的质因数全部输出完毕后，输出一个空行。

**数据范围**

$1≤n≤100$,
$1≤a_i≤2×10^9$

**输入样例：**

```r
2
6
8
```

**输出样例：**

```
2 1
3 1

2 3
```

**题解：**

``` c
从小到大枚举所有数
for(int i=2;i<=n;i++){
    if(n%i==0){ //i一定是质数
        int s=0;
        while(n%i==0){
            n/=i;
            s++;
        }
        printf("%d %d\n",i,s);
    }
}
```

>Q：不应该从大到小枚举所有质因数吗？为什么会是从小到大枚举所有的数？会枚举到合数的，会不会有问题呢？
>
>A：其实是没有问题的，分解质因数的结果确实应为 $n=P_1^{c_1}\cdots P_k^{c_k}$，其中 $P_i$ 应该是质数
>但是当代码枚举到 $i$ 时，就意味着 把 $2 \sim i-1$ 当中所有的质因子都除干净了，即 $n$ 中已经不包含任何 $2 \sim i-1$ 中的质因子
>如果此时 $n\%i=0$，说明 $n$ 是 $i$ 的倍数，结合 $n$ 当中不包含任何 $2 \sim i-1$ 当中的质因子，所以 $i$ 当中也不包含 $2 \sim i-1$ 当中的质因子，故 $i$ 就一定为质数

- **性质：$n$ 中最多只包含一个大于 $\sqrt n$​ 的质因子**
- 证明：假设 $n$ 中包含两个大于 $\sqrt n$ 的质因子$P_i,P_j$​​​，则 $P_i * P_j> \sqrt n * \sqrt n=n$​​​，​矛盾，则两个及以上个都不应该成立
- 所以枚举时，可以先将小于 $\sqrt n$ 的质因子枚举出来；如果最后 $n>1$​，说明最后剩下这个数就是 $n$ 当中大于 $\sqrt n$​ 的质因子
- 时间复杂度 $O(\sqrt n)$

**代码：**

```c
#include <bits/stdc++.h>
using namespace std;

void divide(int n)
{
    for (int i = 2; i <= n / i; i++)
    {
        if (n % i == 0)
        { //这里保证i一定是质数
            int s = 0;
            while (n % i == 0)
            {
                n /= i;
                s++;
            }
            printf("%d %d\n", i, s);
        }
    }
    //可以先将小于sqrt(n)的质因子枚举出来；如果最后n>1,说明最后剩下这个数就是n当中大于sqrt(n)的质因子
    if (n > 1)
        printf("%d %d\n", n, 1);
    puts("");
}

int main()
{
    int n, a;
    scanf("%d", &n);
    while (n--)
    {
        scanf("%d", &a);
        divide(a);
    }
    return 0;
}
```

> 值得注意的是，虽然 质数的判定 和 分解质因数 的代码的时间复杂度都是 $\sqrt n$，但是还是有区别的

>1. 质数的判定的代码的时间复杂度一定是 $\sqrt n$，因为 `for` 循环一定会循环 $\sqrt n$ 次
>2. 分解质因数的代码的时间复杂度不一定是 $\sqrt n$，如 $n=2^k$ 时，`for` 循环只会循环 >$1$ 次；所以其时间复杂度 最好是 $O(\log n)$，最坏是 $O(\sqrt n)$

#### 1.3 AcWing 868. 筛质数

**[题目：]()**

**题目描述**

给定一个正整数 $n$，请你求出 $1 \sim n$ 中质数的个数。

**输入格式**

共一行，包含整数 $n$。

**输出格式**

共一行，包含一个整数，表示 $1∼n$ 中质数的个数。

**数据范围**

$1≤n≤10^6$

**输入样例：**

```r
8
```

**输出样例：**

```
4
```

**题解：**

**朴素做法**

- 首先先把所有数写到一个数表当中

| $2$    | $3$    | $4$    | $5$    | $6$    | $7$    | $8$    | $9$    | $10$   | $11$   | $12$   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

- 随后从前往后看，将每个数所有的倍数都删掉


>先把 $2$ 的所有倍数删掉

| $2$    | $3$    | $\not{4}$    | $5$    | $\not{6}$    | $7$    | $\not{8}$    | $9$    | $\not{10}$   | $11$   | $\not{12}$   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

>再把 $3$ 的所有倍数删掉

| $2$    | $3$    | $\not{4}$    | $5$    | $\not{6}$    | $7$    | $\not{8}$    | $\not{9}$    | $\not{10}$   | $11$   | $\not{12}$   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

>再把 $4$ 的所有倍数删掉

| $2$    | $3$    | $\not{4}$    | $5$    | $\not{6}$    | $7$    | $\not{8}$    | $\not{9}$    | $\not{10}$   | $11$   | $\not{12}$   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

>再把 $5$ 的所有倍数删掉

| $2$    | $3$    | $\not{4}$    | $5$    | $\not{6}$    | $7$    | $\not{8}$    | $\not{9}$    | $\not{10}$   | $11$   | $\not{12}$   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

>以此类推……

- 这样筛完之后，所有剩下的数都是质数

- 因为对一个数 $P$​​​​ 而言，如果它没有被删掉，就意味着 $P$​ 不是 $2 \sim P-1$​​​ ​中任何一个数的倍数，换言之即为 $2 \sim P-1$​ 中没有 $P$​ 的约数，所以 $P$ 是一个质数

```c++
// primes[]表示存储所有的素数
// st[x]存储x是否被筛掉
int primes[N], cnt;
bool st[N];

// 1.朴素做法
void get_primes(int n)
{
    for (int i = 2; i <= n; i++)
    {
        //如果没有筛过则是质数
        if (st[i])
            continue;
        primes[cnt++] = i;
        //否则将i得倍速删除
        for (int j = i + i; j <= n; j += i)
            st[j] = true;
    }
}
```

- 时间复杂度分析
- 代码的运算次数为$\frac{n}{2}+\frac{n}{3}+\frac{n}{4}+\cdots+\frac{n}{n}=n(\frac{1}{2}+\frac{1}{3}+\cdots+\frac{1}{n}) \approx n \ln n < n \log n$​

> 有调和级数 $1+\frac{1}{2}+\frac{1}{3}+\cdots+\frac{1}{n}$​，且存在 $\lim_{n\to\infty}1+\frac{1}{2}+\frac{1}{3}+\cdots+\frac{1}{n}=\ln n+C$​， 其中 $\ln n=\log_e n$​​，而 $C$​ 是一个欧拉常数，$C \approx 0.577$​​，且有 $\log_e n < \log_2 n$

- 故时间复杂度可以记成 $O(n \log n)$



**埃氏筛法**

- 可以发现，这里并不需要把每一个数的所有倍数全部删掉，这里可以只把所有质数的倍数全部删掉

- 为什么呢？如果留下 $P$​​，说明 $P$​ 是一个质数；可以发现其实并不需要把 $2 \sim P-1$ 都枚举一遍判断其是否为 $P$​ 的约数，而只需要把 $2 \sim P-1$ 当中的质数判断一下就可以了

- 所以只需要删掉质数的倍数即可

```c++
// primes[]表示存储所有的素数
// st[x]存储x是否被筛掉
int primes[N], cnt;
bool st[N];

// 2.埃氏筛法
void get_primes2(int n)
{
    for (int i = 2; i <= n; i++)
    {
        //如果没有筛过则是质数
        if (!st[i])
        {
            primes[cnt++] = i;
            //将i得倍速删除
            for (int j = i + i; j <= n; j += i)
                st[j] = true;
        }
    }
}
```

- 时间复杂度约为 $O(\frac{n \ln n}{\ln n})\approx O(n)$

>**质数分布定理：$1 \sim n$​ 中有大约 $\frac{n}{\ln n}$​ 个质数**
>这样整个代码就可以少算 $\ln n$ 倍，但真实的时间复杂度应该近似于 $O(n \log \log n)$​

- 优化完后的筛法被称为 **埃氏筛法**



**线性筛法**

- 思路基本同上，即 将合数用其质因子筛掉

```c++
// primes[]表示存储所有的素数
// st[x]存储x是否被筛掉
int primes[N], cnt;
bool st[N];

// 3.线性筛法
void get_primes3(int n)
{
    for (int i = 2; i <= n; i++)
    {
        //如果没有筛过则是质数
        if (!st[i])
            primes[cnt++] = i;
        
        // n只有最小质因子筛掉
        //对于一个合数x,假设primes[j]是x的最小质因子，当i枚举到x/primes[j]的时候
        for (int j = 0; primes[j] <= n / i; j++)
        {
            st[primes[j] * i] = true;
            // 1.当i % primes[j] == 0
            if (i % primes[j] == 0)
                // primes[j]一定是i的最小质因子
                // primes[j]一定是primes[j]*i的最小质因子
                break;
            // 2.i % primes[j] ！= 0
            // primes[j]一定小于i的所有质因子
            // primes[j]也一定是primes[j]*i的最小质因子
        }
    }
}
```

**上面代码有的数据过不掉：**

```c
// primes[]表示存储所有的素数
// st[x]存储x是否被筛掉
int primes[N], cnt;
bool st[N];

// 3.线性筛法
void get_primes3(int n)
{
    for (int i = 2; i < n; i++)
    {
        //如果没有筛过则是质数
        if (!st[i])
            primes[cnt++] = i;
        
        // n只有最小质因子筛掉
        //对于一个合数x,假设primes[j]是x的最小质因子，当i枚举到x/primes[j]的时候
        for (int j = 0; primes[j]*i < n ; j++)
        {
            st[primes[j] * i] = true;
            // 1.当i % primes[j] == 0
            if (i % primes[j] == 0)
                // primes[j]一定是i的最小质因子
                // primes[j]一定是primes[j]*i的最小质因子
                break;
            // 2.i % primes[j] ！= 0
            // primes[j]一定小于i的所有质因子
            // primes[j]也一定是primes[j]*i的最小质因子
        }
    }
}
```

> `st[i]` 中储存的是 `i` 的最小质因子
> 线性筛法在 $10^7$​ 的数据规模下，比埃氏筛法 快一倍左右；在 $10^6$ 的数据规模下，时间效率是差不多的

- 线性筛法的核心思路：**每一个数 $n$，只会被它的最小质因子筛掉**
- 若 `i%primes[j]==0` ， 由于质数是从小到大枚举的，说明 `primes[j]` 一定是 `i` 的最小质因子，也就是说 `primes[j]` 一定是 `i*primes[j]` 的最小质因子
- 若 `i%primes[j]!=0`，由于质数是从小到大枚举的，说明 `primes[j]` 一定是小于 `i` 的所有质因子的，所以 `prime[j]` 也一定是 `i*prime[j]` 的最小质因子
- 因为合数一定存在最小质因子，所以每个合数都会被筛掉；又因为每个合数都只会被自己的最小质因子筛掉，所以这个算法是线性的
- 时间复杂度为 $O(n)$

>《信息奥赛一本通·提高篇》中的写法是这样的：
>
>```c++
>void get_primes(int n){
>	for(int i=2;i<=n;++i){
>		if(!st[i]) st[i]=primes[cnt++]=i;
>		for(int j=0;j<cnt;++j){
>			if(primes[j]>st[i] || primes[j]>n/i) break;
>			st[primes[j]*i]=primes[j];
>		}
>	}
>}
>```
>
>可以通过不同的写法来加深对于代码顺序和算法原理的理解

>`j<cnt` 这个约束条件是没有必要的，因为如果 `i` 是合数时，其枚举到最小质因子时就会停下来，当 `i` 为质数时，则 `primes[j]==i` 时也会停下来，所以无论如何 `j` 都会在 `cnt` 内停下来

>实际应用中，用的比较多的还是线性筛法，埃氏筛法的思想是比较重要的

---



**代码：**

```c
#include <bits/stdc++.h>
using namespace std;
const int N = 100010;

// primes[]表示存储所有的素数
// st[x]存储x是否被筛掉
int primes[N], cnt;
bool st[N];

// 1.朴素做法
void get_primes(int n)
{
    for (int i = 2; i <= n; i++)
    {
        //如果没有筛过则是质数
        if (st[i])
            continue;
        primes[cnt++] = i;
        //否则将i得倍速删除
        for (int j = i + i; j <= n; j += i)
            st[j] = true;
    }
}

// 2.埃氏筛法
void get_primes2(int n)
{
    for (int i = 2; i <= n; i++)
    {
        //如果没有筛过则是质数
        if (!st[i])
        {
            primes[cnt++] = i;
            //将i得倍速删除
            for (int j = i + i; j <= n; j += i)
                st[j] = true;
        }
    }
}

// 3.线性筛法
void get_primes3(int n)
{
    for (int i = 2; i <= n; i++)
    {
        //如果没有筛过则是质数
        if (!st[i])
            primes[cnt++] = i;

        // n只有最小质因子筛掉
        //对于一个合数x,假设primes[j]是x的最小质因子，当i枚举到x/primes[j]的时候
        for (int j = 0; primes[j] <= n / i; j++)
        {
            st[primes[j] * i] = true;
            // 1.当i % primes[j] == 0
            if (i % primes[j] == 0)
                // primes[j]一定是i的最小质因子
                // primes[j]一定是primes[j]*i的最小质因子
                break;
            // 2.i % primes[j] ！= 0
            // primes[j]一定小于i的所有质因子
            // primes[j]也一定是primes[j]*i的最小质因子
        }
    }
}

int main()
{
    int n;
    cin >> n;
    get_primes(n);
    cout << cnt << endl;
    return 0;
}
```



### 2.约数

#### 2.1 试除法求约数

**AcWing 869. 试除法求约数**

**[题目：]()**

**题目描述**

给定 $n$ 个正整数 $a_i$，对于每个整数 $a_i$，请你按照从小到大的顺序输出它的所有约数。

**输入格式**

第一行包含整数 $n$。

接下来 $n$ 行，每行包含一个整数 $a_i$。


**输出格式**

输出共 $n$ 行，其中第 $i$ 行输出第 $i$ 个整数 $a_i$ 的所有约数。

**数据范围**

$1≤n≤100$,

$2≤ai≤2×10^9$

**输入样例：**

```r
2
6
8
```

**输出样例：**

```
1 2 3 6 
1 2 4 8 
```

**题解：**

- **性质：如果 $d|n$ （$d$ 能整除 $n$），那么显然 $\frac{n}{d}|n$，也就是说，约数总是成对出现的（$d$,$\frac{n}{d})$**

- 所以也只需要枚举到 $\sqrt n$ 即可

- 时间复杂度为 $O(\sqrt n)$

> 做数论题时，很重要的事情就是需要每步都算一算时间复杂度，只有每一步都不超时，才可以做

>Q：那排序的时间复杂度呢？
>A：一个数 $n$​ 的约数个数，用类似筛法的过程来看，即 $1 \sim n$​ 当中总共约数个数（即每个数有多少约数） 和 $1 \sim n$​ 当中总共倍数个数（即有多少数是当前数的倍数） 是相同的
>那么 $1$​ 的倍数有 $n$​ 个、$2$​ 的倍数 有 $\frac{n}{2}$​ 个、……、$n$ 的倍数有 $\frac{n}{n}$​​ 个，故总共有 $n \ln n \approx n \log n$​​ 个倍数，那么平均下来每个数大约有 $\log n$​ 个约数
>故排序的时间复杂度为 $O(\log n \log \log n)$，其一般是小于 $O(\sqrt n)$​​ 的；故在算时间复杂度时，只取 $O(\sqrt n)$

> `int` 范围内，约数个数最多的一个数，其约数个数大约在 $1500$​​ 个左右
> 根据约数的性质，可以发现约数是成对出现的，所以一个数的约数个数的上限为 $2\sqrt n$​​ 

**代码：**

```c
#include <bits/stdc++.h>

using namespace std;

vector<int> get_divisors(int n)
{
    vector<int> res;

    //从小到大枚举最小约数
    for (int i = 1; i <= n / i; i++)
    {
        if (n % i == 0)
        {
            res.push_back(i);
            //边界情况:如果i*i=n则只加一个
            if (i != n / i)
                res.push_back(n / i);
        }
    }
    sort(res.begin(), res.end());
    return res;
}

int main()
{
    int n;
    cin >> n;
    while (n--)
    {
        int x;
        cin >> x;
        auto res = get_divisors(x);
        for (auto item : res)
            cout << item << " ";
        cout << endl;
    }
    return 0;
}
```



#### 2.2 约数个数与约数之和

**约数个数**

- 约数个数是基于算数基本定理的

- **算数基本定理：任何一个大于 $1$ 的正整数都能唯一分解为有限个质数的乘积，可写作：$N=P_1^{c_1}P_2^{c_2}\cdots P_m^{c_m}$​，其中 $c_i$ 都是正整数， $P_i$ 都是质数且满足 $P_1 < P_2 < \cdots < P_m$​**

- 则约数个数即为 $(c_1+1)(c_2+1)\cdots (c_m+1)$​

> 因为对于 $N$的任意一个约数 $d=P_1^{\beta_1}P_2^{\beta_2}\cdots P_m^{\beta_m}$，都有 $0 \leq \beta_i \leq c_i$​​，​​​​并且每一项的指数 $\beta_i$ 不同，则约数 $d$​ 也不同；故$d$ 的个数和 $\beta_1 \sim \beta_k$ 的取法的个数是一样的

**约数之和**

- 约数之和为 $(P_1^0+P_1^1+\cdots+P_1^{c_1})\cdots(P_m^0+P_m^1+\cdots+P_m^{c_m})$

> 直接用乘法分配律展开，展开完之后一共有 约数个数  项，在每个括号中选取一项相乘，得到的就是一个约数

---



**AcWing 870. 约数个数** 

**[题目：]()**

**题目描述**

给定 $n$ 个正整数 $a_i$，请你输出这些数的乘积的约数个数，答案对 $10^9+7$ 取模。

**输入格式**

第一行包含整数 $n$。

接下来 $n$ 行，每行包含一个整数 $a_i$。

**输出格式**

输出一个整数，表示所给正整数的乘积的约数个数，答案需对 $10^9+7$ 取模。

**数据范围**

$1≤n≤100$,

$1≤a_i≤2×10^9$

**输入样例：**

```r
3
2
6
8
```

**输出样例：**

```
12
```

**题解：**

- 求每个数的乘积的质因数分解的结果 $a_1 \times a_2 \times \cdots \times a_n=P_1^{c_1}P_2^{c_2}\cdots P_m^{c_m}$​

- 可以先将每个数单独分解质因数，将每个结果的指数累加即可 $(c_1+1)(c_2+1)\cdots (c_m+1)$

- 可以用 `map` 存储某个质因子的指数是多少$map[p_i]+=C_i$

**代码：**

```c
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int mod = 1e9 + 7;

int main()
{
    int n;
    cin >> n;
    // primes存储所有的质因子及其指数
    unordered_map<int, int> primes;
    while (n--)
    {
        int x;
        cin >> x;
        for (int i = 2; i <= x / i; i++)
            while (x % i == 0)
            {
                x /= i;
                primes[i]++;
            }
        //最后需要特判一下
        if (x > 1)
            primes[x]++;
    }

    //可以先将每个数单独分解质因数
    //将每个结果的指数累加即可 (c_1+1)(c_2+1)(c_m+1)
    LL res = 1;
    for (auto prime : primes)
        res = res * (prime.second + 1) % mod;
    cout << res << endl;
    return 0;
}
```



**AcWing 871. 约数之和**

**[题目：]()**

**题目描述**

给定 $n$ 个正整数 $a_i$，请你输出这些数的乘积的约数之和，答案对 $10^9+7$ 取模。

**输入格式**

第一行包含整数 $n$。

接下来 $n$ 行，每行包含一个整数 $a_i$。

**输出格式**

输出一个整数，表示所给正整数的乘积的约数之和，答案需对 $10^9+7$ 取模。

**数据范围**

$1≤n≤100$,

$1≤a_i≤2×10^9$

**输入样例：**

```r
3
2
6
8
```

**输出样例：**

```
252
```

**题解：**

- 在处理出来每个质因子和其指数后，需要计算 $P^0+P^1+\cdots+P^c$
- 则令 $t=P\times t+1$

> 第一次 $t=P^1+1$​
> 第二次 $t=P^2+P^1+1$​
> 第三次 $t=P^3+P^2+P^1+1$​
> 故只需要乘 $c$​ 次即可得到 $P^0+P^1+\cdots+P^c$​

>Q：求和不用快速幂吗？
>A：其实是不需要的，因为快速幂的时间复杂度为 $O(\log k)$​，其中 $k$​ 为指数；假如一共有 $n$​ 项，每项的指数为 $n$​，则总的时间复杂度为 $O(n \log n)$​；但如果使用上述的方法，只需要求 $n$​ 次即可，时间复杂度为 $O(n)$​，比快速幂更快
>不过 $P^0+P^1+\cdots+P^c$​ 是有 时间复杂度为 $O(\log c)$​ 的时间复杂度的做法的，基本思想是分治
>
>某一步的要求不高时，没有必要使用一些复杂的算法，即没有必要优化不是算法瓶颈的部分

**代码：**

```c
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int mod = 1e9 + 7;

int main()
{
    int n;
    cin >> n;
    // primes存储所有的质因子及其指数
    unordered_map<int, int> primes;
    while (n--)
    {
        int x;
        cin >> x;
        for (int i = 2; i <= x / i; i++)
            while (x % i == 0)
            {
                x /= i;
                primes[i]++;
            }
        //最后需要特判一下
        if (x > 1)
            primes[x]++;
    }

    LL res = 1;
    for (auto prime : primes)
    {
        /*约数之和
        在处理出来每个质因子和其指数后，需要计算 P^0+P^1+....+P^c
        也可以等比数列求和
        */
        // P表示质因子，a表示指数
        int p = prime.first, a = prime.second;
        LL t = 1;
        while (a--)
            t = (t * p + 1) % mod;
        res = res * t % mod;
    }
    cout << res << endl;
    return 0;
}
```



####  2.3 最大公约数——欧几里得算法（辗转相除法）

- **性质：$d|a,d|b \Rightarrow d|a+b \Rightarrow d|ax+by$​**​

> 即若 $d$ 能整除 $a$，$d$ 又能整除 $b$，则 $d$ 能整除 $a+b$，进一步 $d$ 能整除 $a$ 的倍数$+$ $b$ 的倍数

- **定理：$gcd(a,b)=gcd(b,a \mod b)$​​**

> $gcd(a,b)$ 表示的即为 $a$ 和 $b$ 的最大公约数，即最大的 $d=gcd(a,b)$ 使得 $d|a,d|b$ 同时成立
>
> $a \mod b=a-\lfloor \frac{a}{b} \rfloor \times b=a-c \times b$​​​​​ 其中 $c=\lfloor \frac{a}{b} \rfloor$​​​​​ 
> 那么原定理就可以写成 $gcd(a,b)=gcd(b,a-c\times b)$​​​​
> 对于 $a,b$​​ 的公约数 $d$​​​​ 来说，其既能整除 $a$​​​​ ，又能整除 $b$​​​​，则它就一定能整除 $a-c\times b$​​​（$-c$​​ 也算 $b$​​​ 的倍数）​​
> 同样地，对于 $b,a-c\times b$​ 的公约数 $d$​ 来说，其既能整除 $b$​，又能整除 $a-c\times b$​，则它一定能整除 $a-c\times b + c\times b=a$​​
> 故 左式的任何一个公约数 都是 右式的任何一个公约数，反之也成立

- 收束条件为：$gcd(a,0)=a$​
- 欧几里得算法的时间复杂度为 $O(log(a+b))$



**AcWing 872. 最大公约数**

**[题目：]()**

**题目描述**

给定 $n$ 对正整数 $a_i,b_i$，请你求出每对数的最大公约数。

**输入格式**

第一行包含整数 $n$。

接下来 $n$ 行，每行包含一个整数对 $a_i,b_i$。

**输出格式**

输出共 $n$ 行，每行输出一个整数对的最大公约数。

**数据范围**

$1≤n≤10^5$,

$1≤a_i,b_i≤2×10^9$

**输入样例：**

```r
2
3 6
4 6
```

**输出样例：**

```
3
2
```

**代码：**

```c
#include <bits/stdc++.h>
using namespace std;

int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}

int main()
{
    int n;
    cin >> n;
    while (n--)
    {
        int a, b;
        cin >> a >> b;
        cout << gcd(a, b) << endl;
    }
    return 0;
}
```



### 3.欧拉函数

- **互质：若 $gcd(a,b)=1$ 则称 $a,b$ 互质**

- **欧拉函数的定义**

>$1∼N$ 中与 $N$ 互质的数的个数被称为欧拉函数，记为 $ϕ(N)$。
>若在算数基本定理中，$N=P_1^{a_1}P_2^{a_2}\cdots P_k^{a_k}$，则：$ϕ(N) = N \times \frac{P_1-1}{P_1} \times \frac{P_2-1}{P_2} \times\cdots \times \frac{P_k-1}{P_k} $
>
>（这里的除法都是整除）

- $ϕ(N) = N \times \frac{P_1-1}{P_1} \times \frac{P_2-1}{P_2} \times\cdots \times \frac{P_k-1}{P_k} $
>例：$1\sim 6$ 中与 $6$ 互质的数有 $1,5$，则 $\phi(6)=6(1-\frac{1}{2})(1-\frac{1}{3})=2$
>
>证明：利用 **容斥原理**，$N$ 的质因子只有 $P_1 \sim P_k$ 这 $k$ 个
>
>①从 $1 \sim N$ 中去掉 $P_1 \sim P_k$ 的所有倍数，即 $N-\frac{N}{P_1}-\frac{N}{P_2}- \cdots - \frac{N}{P_k}$，这里面就会多去掉了一部分，比如一些数即是 $P_1$ 的倍数，也是 $P_2$ 的倍数
>②加上所有 $P_i*P_j$ 的倍数（$i,j$ 都是 $1 \sim k$ 中任选的两个数，$i\not=j$），即 $+\frac{N}{P_1P_2}+\frac{N}{P_1P_3}+\cdots$，但如果一个数是 $P_1,P_2,P_3$ 的倍数，它会被去掉三次，而它会被 $P_1P_2,P_1P_3,P_2P_3$ 加上三次，效果是没有减没有加，但其实这个数应该被去掉
>③减去所有$P_i*P_j*P_k$ 的倍数，即 $-\frac{N}{P_1P_2P_3}-\frac{N}{P_1P_2P_4}-\cdots$，随后依次类推 $+\frac{N}{P_1P_2P_3P_4}+\cdots - \frac{N}{P_1P_2P_3P_4P_5}- \cdots$
>
>这样，实际上公式的展开就是证明的过程中得到的各项，每项都可以提出来一个 $N$
>通过验证各项系数来推导正确性：
>$\frac{N}{P_1}$ 的系数为第一个括号内选 $-\frac{1}{P_1}$，其余括号内选 $1$，得  $-\frac{N}{P_1}$
>$\frac{N}{P_1P_2}$ 的系数为第一个括号内选 $-\frac{1}{P_1}$，第二个括号内选 $-\frac{N}{P_2}$，其余括号内选 $1$，可以得到 $+\frac{N}{P_1P_2}$
>以此类推，即可得证

---

####  3.1 欧拉函数

**[题目：AcWing 873. 欧拉函数]()**

**题目描述**

给定 $n$ 个正整数 $a_i$，请你求出每个数的欧拉函数。

**输入格式**

第一行包含整数 $n$。

接下来 $n$ 行，每行包含一个正整数 $a_i$​。

**输出格式**

输出共 $n$ 行，每行输出一个正整数 $a_i$ 的欧拉函数。

**数据范围**

$1≤n≤100$,

$1≤a_i≤2×10^9$

**输入样例：**

```r
3
3
6
8
```

**输出样例：**

```
2
2
4
```

**代码：**

```c
#include <bits/stdc++.h>

using namespace std;

int main()
{
    int n;
    cin >> n;
    while (n--)
    {
        int x;
        cin >> x;

        int res = x;
        for (int i = 2; i <= x / i; i++)
        {
            if (x % i == 0)
            {
                // res=res*(1-1/i);由于需要整除，等价下面写法才对
                res = res / i * (i - 1);
                while (x % i == 0)
                    x /= i;
            }
        }
        // x有大的质因子
        if (x > 1)
            res = res / x * (x - 1);

        cout << res << endl;
    }
    return 0;
}
```

#### 3.2 筛法求欧拉函数

**[题目：AcWing 874. 筛法求欧拉函数]()**

**题目描述**

给定一个正整数 $n$，求 $1∼n$ 中每个数的欧拉函数之和。

**输入格式**

共一行，包含一个整数 $n$。

**输出格式**

共一行，包含一个整数，表示 $1∼n$ 中每个数的欧拉函数之和。

**数据范围**

$1≤n≤10^6$

**输入样例：**

```r
6
```

**输出样例：**

```
12
```



**题解：**

- 如果每个数都用公式来做，则时间复杂度会达到 $O(n\sqrt n)$，是不理想的
- 借用线性筛法求素数的代码，可以达到 $O(n)$ 的时间复杂度求每个数的欧拉函数的效果

```c++
for(int i=2;i<=n;++i){
	if(!st[i]) primes[cnt++]=i;
	for(int j=0;primes[j]<=n/i;++j){
		st[primes[j]*i]=true;
		if(i%primes[j]==0) break;
}
```

>线性筛法这个代码是很好用的，它能顺便求出来很多东西，不光可以求欧拉函数

- 根据数据范围 $1≤n≤10^6$，则欧拉函数的和可能会很大（达到越 $n^2$ 的数量级），所以答案应该用 `long long` 存储

- 如果一个数 $P$ 是质数，则它的欧拉函数应为 $P-1$，即 $1 \sim P-1$ 都与其互质

- 当 `i%primes[j]==0` 时，$\phi($`i*primes[j]`$)$ 应该为多少？

  - 从公式的角度有 `primes[j]` 是 `i` 的一个质因子，所以 $\phi($`i`$)$ 已经乘过 $(1-\frac{1}{primes[j]})$ 了，所以 $\phi($`i`$)$ 中形如的 $(1-\frac{1}{P})$ 的式子和 $\phi($`i*primes[j]`$)$ 中是一模一样的

  >或者从分解质因数的角度，`i*primes[j]` 分解质因数后的结果只是比 `i` 多乘了一个 `primes[j]` ，故不考虑指数的情况下，`i*primes[j]` 和 `i` 的质因子是相同的

  - 即，假设 $\phi($`i`$)=i\times (1-\frac{1}{P_1})\times \cdots \times (1-\frac{1}{P_k})$，则 $\phi($`i*primes[j]`$)=i\times primes[j] \times (1-\frac{1}{P_1})\times \cdots \times (1-\frac{1}{P_k})$ ，可以发现 $\phi($`i*primes[j]`$)$= $\phi($`i`$)\times$`primes[j]` 

- 当 `i%primes[j]!=0` 时，$\phi($`i*primes[j]`$)$ 应该为多少？
  - 由线性筛法可知，`primes[j]` 是 `i*primes[j]` 的最小质因子，而且 `priems[j]` 是不包含在 `i` 的质因子当中的
  - 假设 $\phi($`i`$)=i\times (1-\frac{1}{P_1})\times \cdots \times (1-\frac{1}{P_k})$
  - 即 $\phi($`i*primes[j]`$)=i\times primes[j] \times (1-\frac{1}{P_1})\times \cdots \times (1-\frac{1}{P_k})\times (1-\frac{1}{primes[j]})$ 
  - 可以发现，$\phi($`i*primes[j]`$)=i\times (1-\frac{1}{P_1})\times \cdots \times (1-\frac{1}{P_k})\times(primes[j]-1)=\phi($`i`$)\times($`primes[j]`$-1)$ 

- 特殊地，从定义出发，不要忘记 $\phi(1)=1$

**代码：**

```c
#include <bits/stdc++.h>

using namespace std;
typedef long long LL;
const int N = 1000010;
// primes表示每一个质数，cnt表示质数下标
int primes[N], cnt;
int phi[N]; //欧拉函数
bool st[N];

LL get_eulers(int n)
{
    phi[1] = 1;
    //先筛法求质数
    for (int i = 2; i <= n; i++)
    {
        //如果还没筛过,则是质数，将其记录下来
        if (!st[i])
        {
            primes[cnt++] = i;
            //如果是质数，其欧拉函数是i-1
            phi[i] = i - 1;
        }
        // 将n用最小质因子筛掉
        for (int j = 0; primes[j] <= n / i; j++)
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0)
            {
                /*
                1.当i mod primes[j]==0 时(primes[j]是i的一个质因子)
                phi(i)的质因子都出现在phi(primes[j]*i)中
                其欧拉函数phi(primes[j]*i)=primes[j]*phi(i)
                2.当i mod primes[j]!=0 时(primes[j]是i*primes[j]的最小质因子)
                phi(primes[j]*i)=phi(i)*primes[j]*(1-phi(i)/primes[j])
                                =phi(i)*(primes[j]-1)
                */
                phi[primes[j] * i] = phi[i] * primes[j];
                break; // 优化
            }
            phi[primes[j] * i] = phi[i] * (primes[j] - 1);
        }
    }
    LL res = 0;
    for (int i = 1; i <= n; i++)
        res += phi[i];
    return res;
}

int main()
{
    int n;
    cin >> n;

    cout << get_eulers(n) << endl;
    return 0;
}
```



#### 3.3 欧拉定理

**欧拉定理**：若 $a$​​ 与 $n$​​ 互质，则有 $a^{\phi(n)} \equiv 1  \; (mod \;n)$​​，即 $a$​​ 的 $\phi(n)$​​ 次方与 $n$​​​ 互质​

> 如 $a=5,n=6$​​，则 $\begin{aligned} &5^{\phi(6)} \mod 6 \\ = & 5^2 \mod 6\\= &25 \mod 6 \\=&1\end{aligned}$​​​

>同余的定义来自《具体数学》第二版
>**$\equiv$​​ 为同余符号，$a \mod m=b \mod m \Rightarrow a \equiv b \;(mod \; m)$​​，其中右式可以读成“ $a$​​ 关于模 $m$​​ 与 $b$​​ 同余”**
>满足**自反律 $a\equiv a$​​、对称律 $a \equiv b \Rightarrow b \equiv a$​​ 以及传递律 $a \equiv b \equiv c \Rightarrow a \equiv c$**​
>所有这些性质都容易证明，因为对某个函数 $f$​ 满足 $a\equiv b \Leftrightarrow f(a)=f(b)$​ 的任何关系 $\equiv$​ 都是一个等价关系
>（在我们的情形中，$f(x)=x\mod m$​）
>此外，我们**将同余的元素相加和相减，仍保持同余关系；乘法同样有效，只要处理的对象是整数**
>这样一来，我们对方程所习惯做的大多数代数运算对同余式都可以运用
>注意，**除法运算显然不在其中，如果 $ad \equiv bd \;(mod \;m)$​，我们不能断言有 $a\equiv b$**​
>然而，在 $d$​ 与 $m$​​​​​ 互质的这一常见情形中，我们可以挽救这一消元性质
>（具体证明和更多内容可以参考原书）


**证明**

- 假设 $1 \sim n$ 中所有与 $n$​​ 互质的数为 $a_1,a_2,\cdots,a_{\phi(n)}$，一共 $\phi(n)$ 个​

- 由于 $a$​​ 和 $n$​​ 是互质的，所以 $a\times a_1,a\times a_2,\cdots ,a\times a_{\phi(n)}$​​​​ 也都是和​ $n$​​​​​ 互质的，且这些数两两互不相同（在都  $mod \; n$​ 的情况下）

>证明：使用反证法，若 $a\times a_i \equiv a\times a_j \; (mod \; n)$
>则 $\begin{aligned}a\times (a_i-a_j)\equiv 0 \;(mod \; n) \\ a_i-a_j \equiv 0 \;(mod \; n)\\ a_i \equiv a_j\;(mod \; n)\end{aligned}$​，但 $a_i,a_j$ 都是小于 $n$ 且与 $n$ 互质的数，理应它们模 $n$ 都是本身才对，所以矛盾

- 有 $a_1 * a_2 * \cdots *a_{\phi(n)}\equiv a\times a_1 * a\times a_2 * \cdots * a\times a_{\phi(n)} \equiv a^{\phi(n)}a_1*\cdots*a_{\phi(n)}$​

> 因为 $a\times a_i$​ 两两互不相同，且与 $n$​ 互质，实际上 $a\times a_i$​ 就是对 $a_i$​ 的一次重新排序，自然与其乘积同余
> 进一步讲，$1 \sim n$​ 中和 $n$​ 互质的数就只有 $a_i$​ 这 $\phi(n)$​ 个，那么 $a\times a_i \mod n$​ 后两两互不相同，自然就成立

- 由于 $a_1 \sim a_{\phi(n)}$ 与 $n$​ 互质，所以 $a_1*\cdots *a_{\phi(n)}$ 也与 $n$ 互质，故可以直接除去，则有 $a^{\phi(n)}\equiv 1 \;(mod \;n)$



**推论（费马小定理）：**当 $P$​​​​​ 为质数时，$a^{\phi(P)} \equiv 1 \; mod \; P \Rightarrow a^{P-1}\equiv1 \; mod\;P \Rightarrow a\times a^{P-2}\equiv 1 \mod P$​​​​​

>考试的时候肯定不会考证明，但是如果会证明就可以把整个来龙去脉整的更加清楚，而且也可以装逼了

---



### 4.快速幂

- 快速幂（欧拉降幂）可以在 $O(\log k)$ 的时间复杂度内求出 $a^k \mod p$​ 的结果

> 也就是说，其中 $a,p,k$ 都可以在 $10^9$ 的范围内

- **反复平方法**：预处理出来 $a^{2^0}\mod p,a^{2^1}\mod p,\cdots,a^{2^{\log k}}\mod p$​​ 共 $\log k+1$ 个结果

- 如何把 $a^k$ 组合出来呢？

  - 将 $a^k$​​​ 拆成 $a^{2^{x_1}}\times a^{2^{x_2}}\times \cdots \times a^{2^{x_t}}$​​​​​​ 这样的结果，即 $a^k=a^{2^{x_1}+2^{x_2}+\cdots+2^{x_t}}$

  - 实际上就是将 $k$​​ 进行二进制拆分

  >若 $k_{(10)}=110110_{(2)}$，则 $k$ 就可以拆成 $k=2^1+2^2+2^4+2^5$​
  >即二进制表示中​所有是 $1$​ 的位，就拆出对应位的 $2$ 的对应次方即可

- 如何预处理出来这 $\log k+1$ 个数呢？

  - $a^{2^0}=a^1=a$
  - $a^{2^1}=a^{2^0*2}=(a^{2^0})^2$
  - $a^{2^2}=(a^{2^1})^2$
  - $\cdots$
  - $a^{2^{\log k}}=(a^{2^{\log k \;-1}})^2$​

  - 所以每一个数都是上一个数的平方 $mod \; p$​​，所以从前往后平方 $k$​ 次就可以把这些数预处理出来了​

> 例：求 $4^5\mod 10$​​​​
> 先预处理出来 $4^{2^0}=4\;(mod\;10),4^{2^1}=6,4^{2^2}=6$​
> $5_{(10)}=101_{(2)}$​
>
> $\begin{aligned}4^5 &=4^{101_{(2)}}\\&=4^{2^0}+4^{2^2}\\&=4 \times 6\\&=4 (mod\;10)\end{aligned}$

> 快速幂是用的非常多的一个函数，是数论的常客



#### 4.1 快速幂

**[题目：AcWing 875. 快速幂]()**

**题目描述**

给定 $n$ 组 $a_i,b_i,p_i$，对于每组数据，求出 $a^{b_i}_i \mod p_i$ 的值。

**输入格式**

第一行包含整数 $n$。

接下来 $n$ 行，每行包含三个整数 $a_i,b_i,p_i$。

**输出格式**

对于每组数据，输出一个结果，表示  $a^{b_i}_i \mod p_i$ 的值。

每个结果占一行。

**数据范围**

$1≤n≤100000$,

$1≤a_i,b_i,p_i≤2×10^9$

**输入样例：**

```r
2
3 2 5
4 3 9
```

**输出样例：**

```
4
1
```

**题解：**

``` 
两个 10^9 相乘可能爆 int，所以适用 long long 储存
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

// a^k%p
int qmi(int a, int k, int p)
{
    int res = 1;
    //先求的二进制表示
    while (k)
    {
        //取出k的二进制表示的末尾
        if (k & 1)
            res = (LL)res * a % p;
        //删除k的二进制最后一位
        k >>= 1;
        a = (LL)a * a % p;
    }
    return res;
}

int main()
{
    int n;
    cin >> n;
    while (n--)
    {
        int a, k, p;
        cin >> a >> k >> p;
        cout << qmi(a, k, p) << endl;
    }
    return 0;
}
```



#### 4.2 快速幂应用求逆元

**[题目：AcWing 876. 快速幂求逆元]()**

**题目描述**

给定 $n$ 组 $a_i,p_i$，其中 $p_i$ 是质数，求 $a_i$ 模 $p_i$ 的乘法逆元，若逆元不存在则输出 `impossible`。

注意：请返回在 $0∼p−1$ 之间的逆元。

**乘法逆元的定义**

>若整数 $b，m$​ 互质，并且对于任意的整数 $a$​，如果满足 $b|a$​，则存在一个整数 $x$​，使得 $\frac{a}{b}≡a、times x(mod\; m)$​，则称 $x$​ 为 $b$​ 的模 $m$​ 乘法逆元，记为 $b^{−1}(mod\;m)$​。
>$b$​ 存在乘法逆元的充要条件是 $b$​ 与模数 $m$​ 互质。当模数 $m$​ 为质数时，$b^{m−2}$ 即为 $b$ 的乘法逆元。

**输入格式**

第一行包含整数 $n$。

接下来 $n$​ 行，每行包含一个数组 $a_i,p_i$，数据保证 $p_i$ 是质数。

**输出格式**

输出共 $n$ 行，每组数据输出一个结果，每个结果占一行。

若 $a_i$ 模 $p_i$ 的乘法逆元存在，则输出一个整数，表示逆元，否则输出 `impossible`。

**数据范围**

$1≤n≤10^5$,

$1≤a_i,p_i≤2∗10^9$

**输入样例：**

```r
3
4 3
8 5
6 3
```

**输出样例：**

```
1
2
impossible
```

**题解：**

``` 
费马定理+快速幂
a^(p-1)=a*a^(p-2) mod p
b是质数p的倍数的时候就不能用费马小定理
```

**代码：**

```c
#include <bits/stdc++.h>

using namespace std;
typedef long long LL;
int qmi(int a, int k, int p)
{
    int res = 1;
    while (k)
    {
        if (k & 1)
            res = (LL)res * a % p;
        k >>= 1;
        a = (LL)a * a % p;
    }
    return res;
}

int main()
{
    int n;
    cin >> n;
    while (n--)
    {
        int a, p;
        cin >> a >> p;
        // b是质数p的倍数的时候就不能用费马小定理,一定无解
        int res = qmi(a, p - 2, p);
        if (a % p)
            cout << res << endl;
        else
            puts("impossible");
    }
    return 0;
}
```



### 5.扩展欧几里得算法

- 裴蜀定理

> 对任意正整数$a、b$，那么一定存在非$0$整数$x、y$,使得$ax+by=gcd(a,b)$
>

>
> 注意：$a$和$b$的最大公约数就是$a$和$b$能凑出来的最小正整数
>
> 证明：存在$ax+by=d$，$d$一定是$a$和$b$最大公约数的倍数
>
> 扩展欧几里得算法能求出对任意正整数$a、b$，那么一定存在非$0$整数$x、y$,满足上式子
> 

>欧几里得：$(a,b)=(b,a   \ mod  \ b)$
>$a \mod b=a-\lfloor \frac{a}{b} \rfloor \times b=a-c \times b$ 其中 $c=\lfloor \frac{a}{b} \rfloor$ 

>递归边界：$(a,0)≡ a$ 使得$a*x+0*y=a$,则可以得到一组解答$x=1,y=0$
>
>递归结束时：$b*y+(a \mod b)*x=(b,a \mod b)=(a,b)=d$
>
>​      				$b*y+(a \mod b)*x=d$
>
>​					 $b*y+(a-\lfloor \frac{a}{b} \rfloor \times b)*x=b*y+(a-c \times b)*x=d$
>
>​					  $a*x+b*(y-\lfloor \frac{a}{b} \rfloor \times x)=d$
>
>记上面求出的$x$和$y$为$x_0$和$y_0$
>
>则$a*x_0+b*y_0=d$
>
>通解：
>
>$x=x_0-\frac{a}{b}\times k$
>
>$y=y_0+\frac{a}{b}\times k$



#### 5.1 扩展欧几里得算法

**[题目：877. 扩展欧几里得算法]()**

**题目描述**

给定 $n$ 对正整数 $ai,bi$对于每对数，求出一组 $xi,yi$，使其满足 $ai×xi+bi×yi=gcd(ai,bi)$。

**输入格式**

第一行包含整数 $n$。

接下来 $n$ 行，每行包含两个整数 $ai,bi$。

**输出格式**

输出共 $n$ 行，对于每组 $ai,bi$，求出一组满足条件的 $xi,yi$，每组结果占一行。

本题答案不唯一，输出任意满足条件的 $xi,yi$均可。

**数据范围**

$1≤n≤10^5$,

$1≤a_i,b_i≤2×10^9$

**输入样例：**

```r
2
4 6
8 18
```

**输出样例：**

```
-1 1
-2 1
```



**代码：**

```c
#include <bits/stdc++.h>

using namespace std;

int exgcd(int a, int b, int &x, int &y)
{
    // 0和任意数a的最大公约数都是a
    if (!b)
    {
        x = 1, y = 0;
        return a;
    }
    //反转
    int d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}

int main()
{
    int n;
    cin >> n;
    while (n--)
    {
        int a, b, x, y;
        cin >> a >> b;
        exgcd(a, b, x, y);
        cout << x << " " << y << endl;
    }
    return 0;
}
```



#### 5.2 应用求线性同余方程

**[题目：878. 线性同余方程]()**

**题目描述**

给定 $n $组数据$ a_i,b_i,m_i$，对于每组数求出一个 $xi$，使其满足 $a_i×x_i≡b_i(mod \ m_i)$，如果无解则输出 `impossible`。

**输入格式**

第一行包含整数 $n$。

接下来 $n $行，每行包含一组数据$ a_i,b_i,m_i$。

**输出格式**

输出共 $n $行，每组数据输出一个整数表示一个满足条件的 $x_i$，如果无解则输出 `impossible`。

每组数据结果占一行，结果可能不唯一，输出任意一个满足条件的结果均可。

输出答案必须在 int 范围之内。

**数据范围**

$1≤n≤10^5$,

$1≤a_i,b_i,m_i≤2×10^9$

**输入样例：**

```r
2
2 3 6
4 3 5
```

**输出样例：**

```
impossible
-3
```

**题解：**

 $a_i×x_i≡b_i(mod \ m_i)$等价于存在整数$y_i$使得 $a_i×x_i=m_i*y_i+b_i$

$a_i×x_i-m_i*y_i=b_i$

令$y^`=-y$

$a_i×x_i+m_i*y^`_i=b_i$

上面式子有解充分必要条件：

$(a,m)|b$   即a和m的最大公约数是b的倍数

**代码：**

```c
#include <bits/stdc++.h>
using namespace std;

typedef long long LL;

int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}

int main()
{
    int n;
    cin >> n;
    while (n--)
    {
        int a, b, m;
        cin >> a >> b >> m;
        int x, y;
        int d = exgcd(a, m, x, y);
        if (b % d)
            puts("Impossible");
        else
            cout << (LL)x * (b / d) % m << endl;
    }
}
```



### 6.中国剩余定理

**[题目：204. 表达整数的奇怪方式]()**

**题目描述**

给定 $2n$ 个整数 $a_1,a_2,…,a_n$ 和 $m1,m2,…,mn$，求一个最小的非负整数 $x$，满足 $∀i∈[1,n],x≡m_i(mod \ a_i)$。

**输入格式**

第 `1` 行包含整数 $n$。

第$ 2…n+1$ 行：每 $i+1 $行包含两个整数 $a_i$ 和 $m_i$，数之间用空格隔开。

**输出格式**

输出最小非负整数 $x$，如果 $x$ 不存在，则输出 −1。
如果存在 $x$，则数据保证 $x$ 一定在 `64` 位整数范围内。

**数据范围**

$1≤a_i≤2^{31}−1$,

$0≤m_i<a_i$,

$1≤n≤25$

**输入样例：**

```r
2
8 7
11 9
```

**输出样例：**

```
31
```

**题解：**

``` 

```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;


LL exgcd(LL a, LL b, LL &x, LL &y)
{
    if (!b)
    {
        x = 1, y = 0;
        return a;
    }

    LL d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}


int main()
{
    int n;
    cin >> n;

    LL x = 0, m1, a1;
    cin >> m1 >> a1;
    for (int i = 0; i < n - 1; i ++ )
    {
        LL m2, a2;
        cin >> m2 >> a2;
        LL k1, k2;
        LL d = exgcd(m1, m2, k1, k2);
        if ((a2 - a1) % d)
        {
            x = -1;
            break;
        }

        k1 *= (a2 - a1) / d;
        k1 = (k1 % (m2/d) + m2/d) % (m2/d);

        x = k1 * m1 + a1;

        LL m = abs(m1 / d * m2);
        a1 = k1 * m1 + a1;
        m1 = m;
    }

    if (x != -1) x = (a1 % m1 + m1) % m1;

    cout << x << endl;

    return 0;
}

```



### 7.高斯消元

>如无特殊说明，所有数均为正整数

- **高斯消元是用来解方程的**，可以在 $O(n^3)$​ 时间复杂度内求解一个 $n$ 个方程 $n$ 个未知数 的多元线性方程组

- 方程组的解有三种情况：①无解、②无穷多组解、③唯一解

- 样例方程组为 $\begin{cases}x_1+2x_2-x_3=-6\\2x_1+x_2-3x_3=-9\\-x_1-x_2+2x_3=7\end{cases}$​​​，答案为​ $\begin{cases}x_1=1\\x_2=-2\\x_3=3\end{cases}$

- 高斯消元法应用了线性代数中矩阵的初等行变换

>这里一些比较复杂的线性代数知识就不涉及了，只介绍高斯消元的做法和原理
>虽然有线性代数的术语，但是所运用的原理还是初中和小学的知识

- 将系数抽出来，得到一个 $n\times (n+1)$​​ 的系数矩阵，对系数矩阵可以做一些初等行变换的操作

- 样例方程组的系数矩阵为 $\begin{pmatrix}1 & 2 & -1 & -6\\2 & 1 & -3 & -9\\-1 & -1 & 2 & 7\end{pmatrix}$​​

- 初等行变换一共有三种，**这三种行列变换可以保证不影响整个方程组的解**

  1. 某一行乘一个非零的数（等价于方程两边乘一个相同的数）
  2. 交换某两行（等价于把方程组中某两个数交换一下位置）
  3. 把某行的若干倍加到另一行上去（等价于某个方程的若干倍加到另一个方程上去）

- 通过这三种基本操作，把矩阵化简为一个上三角的形式$\left\{\begin{aligned}a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_n=b_1 \\ a_{22}x_2+\cdots+a_{2n}x_n=b_2 \\ \cdots\\ a_{nn}x_n=b_n\end{aligned}\right.$​​

> 变成上三角有什么好处呢？
> 首先 $x_n$​ 可以直接求出
> $x_{n-1}$​ 的方程为 $a_{n-1,n}x_{n-1}+a_{nn}x_n=b_{n-1}$​，通过 $x_n$ 就可以推出 $x_{n-1}$ 的值
> 以此类推，就可求出 所有未知数的值了

- 什么情况会没有解？
  - 如果通过化简，矩阵恰好是一个完美的阶梯型（即 $a_{ii}$​ 都存在），**完美阶梯型**就会有**唯一解**
  - 如果是不完美的阶梯型，而且出现类似 $0=b_i$​​​ 的方程，则**无解**
  - 如果是不完美的阶梯型，而且出现类似 $0=0$​​ 的方程，则**有无穷多组解**

**具体算法**

- 高斯消元是一个迭代的过程，需要枚举 $1\sim n-1$​ 列，假设当前枚举到第 $c$​ 列​​​​

  1. 找到第 $c$ 中绝对值最大的一行
  2. 将该行换到第 $c$ 行上去
  3. 将该行第一个数变成 $1$​
  4. 将下面所有行的第 $c$ 列都消成 $0$

- 遍历到第 $1$ 列：

  $\begin{pmatrix}1 & 2 & -1 & -6\\2 & 1 & -3 & -9\\-1 & -1 & 2 & 7\end{pmatrix} \overset{1.2.}{\to} \begin{pmatrix}2 & 1 & -3 & -9\\1 & 2 & -1 & -6\\-1 & -1 & 2 & 7\end{pmatrix} \overset{3.}{\to} \begin{pmatrix}1 & 0.5 & -1.5 & -4.5\\1 & 2 & -1 & -6\\-1 & -1 & 2 & 7\end{pmatrix} \overset{4.}{\to} \begin{pmatrix}1 & 0.5 & -1.5 & -4.5\\0 & 1.5 & 0.5 & -1.5\\0 & -0.5 & 0.5 & 2.5\end{pmatrix}$​​


- 遍历到第 $2$​ ​列：
  - $\begin{pmatrix}1 & 0.5 & -1.5 & -4.5\\0 & 1.5 & 0.5 & -1.5\\0 & -0.5 & 0.5 & 2.5\end{pmatrix} \overset{3.}{\to} \begin{pmatrix}1 & 0.5 & -1.5 & -4.5\\0 & 1 & \frac{1}{3} & -1\\0 & -0.5 & 0.5 & 2.5\end{pmatrix} \overset{4.}{\to} \begin{pmatrix}1 & 0.5 & -1.5 & -4.5\\0 & 1 & \frac{1}{3} & -1\\0 & 0 & \frac{2}{3} & 2\end{pmatrix}$​​
- 遍历到第 $3$​ 列：
  - $\begin{pmatrix}1 & 0.5 & -1.5 & -4.5\\0 & 1 & \frac{1}{3} & -1\\0 & 0 & \frac{2}{3} & 2\end{pmatrix}\overset{3.}{\to} \begin{pmatrix}1 & 0.5 & -1.5 & -4.5\\0 & 1 & \frac{1}{3} & -1\\0 & 0 & 1 & 3\end{pmatrix}$​


- 到此为止，系数矩阵就变为了上三角，现在开始求唯一解
- $\begin{pmatrix}1 & 0.5 & -1.5 & -4.5\\0 & 1 & \frac{1}{3} & -1\\0 & 0 & 1 & 3\end{pmatrix}\to \begin{pmatrix}1 & 0.5 & -1.5 & -4.5\\0 & 1 & 0 & -1\\0 & 0 & 1 & 3\end{pmatrix}\to \begin{pmatrix}1 & 0 & 0 & 1\\0 & 1 & 0 & -1\\0 & 0 & 1 & 3\end{pmatrix}$​​
- 换成方程的形式，即得 $\begin{cases}x_1=1\\x_2=-2\\x_3=3\end{cases}$​


---



**[题目：AcWing 883. 高斯消元解线性方程组]()**

**题目描述**

输入一个包含 $n$ 个方程 $n$ 个未知数的线性方程组。

方程组中的系数为实数。

求解这个方程组。

如下为一个包含 $m$ 个方程 $n$ 个未知数的线性方程组示例：

$\begin{cases}a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_n=b_1 \\ a_{21}x_1+a_{22}x_2+\cdots+a_{2n}x_n=b_2\\ \cdots \\a_{n1}x_1+a_{n2}x_2+\cdots+a_{nn}x_n=b_n\end{cases}$

**输入格式**

第一行包含整数 $n$。

接下来 $n$ 行，每行包含 $n+1$ 个实数，表示一个方程的 $n$ 个系数以及等号右侧的常数。

**输出格式**

如果给定线性方程组存在唯一解，则输出共 $n$ 行，其中第 $i$ 行输出第 $i$ 个未知数的解，结果保留两位小数。

如果给定线性方程组存在无数解，则输出 `Infinite group solutions`。

如果给定线性方程组无解，则输出 `No solution`。

**数据范围**

$1≤n≤100$,
所有输入系数以及常数均保留两位小数，绝对值均不超过 $100$。

**输入样例：**

```r
3
1.00 2.00 -1.00 -6.00
2.00 1.00 -3.00 -9.00
-1.00 -1.00 2.00 7.00
```

**输出样例：**

```
1.00
-2.00
3.00
```

**代码：**

```c
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cmath>

using namespace std;

const int N = 110;
const double eps = 1e-8;

int n;
double a[N][N];

int gauss() // 高斯消元，答案存于a[i][n]中，0 <= i < n
{
    int c, r;
    //从第0行第0列开始枚举,按照列c枚举
    for (c = 0, r = 0; c < n; c++)
    {
        int t = r;
        // 1.找到当前列绝对值最大的一行
        for (int i = r; i < n; i++) // 找绝对值最大的行
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;

        if (fabs(a[t][c]) < eps)
            continue;

        // 2.将最大的一行换到最上面去
        for (int i = c; i <= n; i++)
            swap(a[t][i], a[r][i]); // 将绝对值最大的行换到最顶端

        // 3.将该行第一个数变为1,倒着来不然覆盖了
        for (int i = n; i >= c; i--)
            a[r][i] /= a[r][c]; // 将当前行的首位变成1

        // 4.将下面所有行的第 c 列都消成 0
        for (int i = r + 1; i < n; i++) // 用当前行将下面所有的列消成0
            if (fabs(a[i][c]) > eps)
                for (int j = n; j >= c; j--)
                    a[i][j] -= a[r][j] * a[i][c];

        r++;
    }

    if (r < n)
    {
        for (int i = r; i < n; i++)
            if (fabs(a[i][n]) > eps)
                return 2; // 无解
        return 1;         // 有无穷多组解
    }
    //倒着推导答案
    for (int i = n - 1; i >= 0; i--)
        for (int j = i + 1; j < n; j++)
            a[i][n] -= a[i][j] * a[j][n];

    return 0; // 有唯一解
}

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n + 1; j++)
            scanf("%lf", &a[i][j]);

    int t = gauss();
    if (t == 2)
        puts("No solution");
    else if (t == 1)
        puts("Infinite group solutions");
    else
    {
        for (int i = 0; i < n; i++)
        {
            if (fabs(a[i][n]) < eps)
                a[i][n] = 0; // 去掉输出 -0.00 的情况
            printf("%.2lf\n", a[i][n]);
        }
    }

    return 0;
}
```



### 8.求组合数

#### 8.1 求组合数 I

**[题目：AcWing 885. 求组合数 I]()**

**题目描述**

给定 $n$ 组询问，每组询问给定两个整数 $a，b$，请你输出 $C^b_a\mod(10^9+7)$ 的值。

**输入格式**

第一行包含整数 $n$。

接下来 $n$ 行，每行包含一组 $a$ 和 $b$。

**输出格式**

共 $n$ 行，每行输出一个询问的解。

**数据范围**

$1≤n≤10000$,

$1≤b≤a≤2000$

**输入样例：**

```r
3
3 1
5 3
2 2
```

**输出样例：**

```
3
10
1
```

**题解：**


- $1≤n≤10000$​,$1≤b≤a≤2000$​​​，求 $C_a^b=\frac{a\times(a-1)\times \cdots \times(a-b+1)}{1\times2\times3\times\cdots\times b}=\frac{a!}{b!(a-b)!}$​

> 因为每问一次算一遍，则 $O(10000*2000=2\times10^8)$ 就会超时
> 注意到 $1≤b≤a≤2000$，不同的 $(a,b)$ 一共才 $2000^2=4\times10^6$ 对，所以可以预处理出来所有 $C_a^b$ 的值，有递推式 $C_a^b=C_{a-1}^b+C_{a-1}^{b-1}$

> 证明：从实际含义出发，$C_a^b$ 表示从 $a$ 个苹果中选出 $b$ 的方案数，把所有选法分成两种情况，即从 $a$ 个苹果中随便挑一个出来，这样所有选法就分为两类：包含这个苹果和不包含这个苹果
>
> 1. 包含这个苹果，则剩下 $b-1$​ 个苹果需要选，即 $C_{a-1}^{b-1}$​
> 2. 不包含这个苹果，则剩下 $b$ 个苹果需要选，即 $C_{a-1}^b$

- 时间复杂度为 $O(n^2)$

**代码：**

```c
#include <bits/stdc++.h>
using namespace std;

const int N = 2010, mod = 1e9 + 7;
int c[N][N];

void init()
{
    for (int i = 0; i < N; i++)
        for (int j = 0; j <= i; j++)
            //边界特判一下
            if (!j)
                //从i里面选择0个的时候
                c[i][j] = 1;
            else
                //从i里面选择j个的时候=从i-1里面选择j个加从i-1里面选择j-1个
                c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
}

int main()
{
    init();
    int n;
    cin >> n;
    while (n--)
    {
        int a, b;
        cin >> a >> b;
        cout << c[a][b] << endl;
    }
    return 0;
}
```



#### 8.2 求组合数学II

**[题目：AcWing 886. 求组合数 II]()**

**题目描述**

给定 $n$ 组询问，每组询问给定两个整数 $a，b$，请你输出 $C^b_a\mod(10^9+7)$ 的值。

**输入格式**

第一行包含整数 $n$。

接下来 $n$ 行，每行包含一组 $a$ 和 $b$。

**输出格式**

共 $n$ 行，每行输出一个询问的解。

**数据范围**

$1≤n≤10000$,

$1≤b≤a≤10^5$

**输入样例：**

```r
3
3 1
5 3
2 2
```

**输出样例：**

```
3
10
1
```

**题解：**


- 预处理 $fact[i]=i! \mod 10^9+7$​​
- 但是由于 $\frac{a}{b} \mod p \not= \frac{a\mod p}{b \mod p}$​​​ ，除相当于乘逆元，所以需要用逆元来算，即预处理 $infact[i]=(i!)^{-1}\mod p$​
- 这样就有 $C_a^b=fact[a] \times infact[a-b] \times infact[b]$

- 时间复杂度为 $O(n \log n)$

**代码：**

```c
#include <bits/stdc++.h>

using namespace std;
typedef long long LL;
const int N = 10010, mod = 1e9 + 7;

int fact[N], infact[N];
int qmi(int a, int k, int p)
{
    int res = 1;
    while (k)
    {
        if (k & 1)
            res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}

int main()
{
    // 0的阶乘为1，1/1为1
    fact[0] = infact[0] = 1;
    for (int i = 1; i < N; i++)
    {
        fact[i] = (LL)fact[i - 1] * i % mod;
        //求逆元,如果这里mod不是一个质数的话就需要通过exgcd来求逆元
        infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
    }

    int n;
    cin >> n;
    while (n--)
    {
        int a, b;
        cin >> a >> b;
        cout << (LL)fact[a] * infact[b] % mod * infact[a - b] % mod << endl;
    }
    return 0;
}
```



#### 8.3 求组合数 III

**Lucas定理**

> 没有特殊说明，除法操作均为整数

- $C_a^b \equiv C_{a\mod p}^{b\mod p}\times C_{\frac{a}{p}}^{\frac{b}{p}}\;(mod\;p)$​​

**证明**


- 将 $a,b$ 变成类似于 $p$ 进制

- 即 $a=a_k*p^k+a_{k-1}*p^{k-1}+\cdots+a_0*p^0$​​​

- 则 $b=b_k*p^k+b_{k-1}*p^{k-1}+\cdots+b_0*p^0$​​

- 则 Lucas定理又可以写成 $C_a^b=C_{a_k}^{b_k}*C_{a_{k-1}}^{b_{k-1}}*\cdots*C_{a_0}^{b_0}$

> 实际上Lucas定理类似于一个递归式（因为 $\frac{b}{p},\frac{a}{p}$ 还是有可能 $>p$，这时就需要再执行一次定理）
> 即现在仅需要证明 $C_a^b=C_{a_k}^{b_k}*C_{a_{k-1}}^{b_{k-1}}*\cdots*C_{a_0}^{b_0}$ 即可得到 $C_a^b=C_{a\mod p}^{b\mod p}\times C_{\frac{a}{p}}^{\frac{b}{p}}\;(mod\;p)$


- 利用 **生成函数** 证明
- $(1+x)^p=C_p^01+C_p^1x+C_p^2x^2+\cdots+C_p^p x^p$​​​
- 由于 $p$ 是质数，$p$ 是没有小于 $p$​​ 的质因子的，且 $C_a^b=\frac{a!}{b!(a-b)!}$
- 故所有中间项的分子中有 $p$ ，分母中不含 $p$，则所有中间项 $\mod p=0$
- $(1+x)^p \equiv 1+C_p^px^p \equiv 1+x^p\;(mod\;p)$​​

>可以用同样的道理证明出来 $(1+x)^{p^k}\equiv 1+x^{p^k}$

- $\begin{aligned}(1+x)^a & =(1+x)^{a_0}((1+x)^p)^{a_1}((1+x)^{p^2})^{a_2}\cdots((1+x)^{p^k})^{a_k}\\ & \equiv (1+x)^{a_0}(1+x^p)^{a_1}(1+x^{p^2})^{a_2}\cdots(1+x^{p^k})^{a_k} \;(mod\;p)\end{aligned}$​​

>这里是 $a=a_k*p^k+a_{k-1}*p^{k-1}+\cdots+a_0*p^0$​ 得出后，再与上式联立得到的

- 对比同余式两边 $x^b$​ 项的系数，有 $C_a^b=C_{a_k}^{b_k}*C_{a_{k-1}}^{b_{k-1}}*\cdots*C_{a_0}^{b_0}$​

>由二项式定理可知，$C_a^b$​​​​​ 即为 $(1+x)^a$​​​​​ 中 $x^b$​​​​​ 的系数，同理
>$C_{a_0}^{b_0}$​​​​​ 即为 $(1+x)^{a_0}$​​​​​ 中  $x^{b_0*p^0}$​​​​​ 的系数
>$C_{a_1}^{b_1}$​​​​​ 即为 $(1+x^{p^1})^{a_1}$​​​​​ 中  $x^{b_1*p^1}$​​​​​ 的系数
>$\cdots$​​​​​
>$C_{a_k}^{b_k}$​​​​​ 即为 $(1+x^{p^k})^{a_k}$​​​​​ 中  $x^{b_k*p^k}$​​​​​ 的系数
>将 $C_{a_0}^{b_0}x^{b_0*p^0},C_{a_1}^{b_1}x^{b_1*p^1},\cdots,C_{a_k}^{b_k}x^{b_k*p^k}$​​​​​ 相乘
>因为  $b=b_k*p^k+b_{k-1}*p^{k-1}+\cdots+b_0*p^0$​​​​​ 可得 $C_{a_k}^{b_k}*C_{a_{k-1}}^{b_{k-1}}*\cdots*C_{a_0}^{b_0}x^b$​​​​​
>注意到可能出现 $b_i>a_i$​​​​​ 的情况，但如果出现这种情况，则等式右边是不存在 $x^{b_i*p^i}$​​​​​ 的系数的，左边系数也是 $0$​​​​​

> 证明链接：https://blog.csdn.net/qq_40679299/article/details/80489761

**[题目：AcWing 887. 求组合数 III]()**

**题目描述**

给定 $n$ 组询问，每组询问给定三个整数 $a,b,p$，其中 $p$ 是质数，请你输出 $C^b_a\mod p$ 的值。

**输入格式**

第一行包含整数 $n$。

接下来 $n$ 行，每行包含一组 $a,b,p$。

**输出格式**

共 $n$ 行，每行输出一个询问的解。

**数据范围**

$1≤n≤20$,

$1≤b≤a≤10^{18}$,

$1≤p≤10^5$

**输入样例：**

```r
3
5 3 7
3 1 5
6 4 13
```

**输出样例：**

```
3
3
2
```

**题解：**

- 可以根据Lucas定理，可以将时间复杂度变为 $O(\log_p n \times p \times \log p \approx p \log n \log p)\approx 10^5\times 20 \approx 2\times 10^6$​
- 最后还要乘 $20$​ 组数据​，故总时间复杂度达到了 $4\times 10^7$

>$\log_p n$​​​ 可以理解为要把 $a,b$​​​ 变成 $p$​​​进制，$p \times \log p$​​​​​ 表示预处理 $p$​​ 以内的阶乘
>但因为 $\log_p n,\log p$​​ 不可能同时取最值，如果 $p$​​ 很大则 $\log_p n$​​ 理应很小，反之 $\log p$​​ 很小，所以忽略掉 $\log n=64$ 这个极限值

**代码：**

```c
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
int p;

int qmi(int a, int k)
{
    int res = 1;
    while (k)
    {
        if (k & 1)
            res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}

int C(int a, int b)
{
    int res = 1;
    // a!/(b!(a-b)!)
    for (int i = 1, j = a; i <= b; i++, j--)
    {
        res = (LL)res * j % p;
        res = (LL)res * qmi(i, p - 2) % p;
    }
    return res;
}

int lucas(LL a, LL b)
{
    if (a < p && b < p)
        return C(a, b);
    return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}

int main()
{
    int n;
    cin >> n;
    while (n--)
    {
        LL a, b;
        cin >> a >> b >> p;
        cout << lucas(a, b) << endl;
    }
    return 0;
}
```



#### 8.4 求组合数 IV

**[题目：AcWing 888. 求组合数 IV]()**

**题目描述**

输入 $a,b$，求 $C^b_a$ 的值。

注意结果可能很大，需要使用高精度计算。

**输入格式**

共一行，包含两个整数 $a$ 和 $b$ 。

**输出格式**

共一行，输出 $C^b_a$ 的值。

**数据范围**

$1≤b≤a≤5000$

**输入样例：**

```r
5 3
```

**输出样例：**

```
10
```

**题解：**

- 从定义出发 $1≤b≤a≤5000$​​​，求 $C_a^b=\frac{a\times(a-1)\times \cdots \times(a-b+1)}{1\times2\times3\times\cdots\times b}=\frac{a!}{b!(a-b)!}$​
- 先将 $C_a^b$ 分解质因数$=P_1^{a1}*P_2^{a2}....$，这样就只需要实现高精度乘法即可
- 即先求出分子分解质因数后的指数，再减去分母分解质因数后的指数即可
- 如何求阶乘中包含多少个因子 $p$ 呢？$a!$​ 中有 $\lfloor \frac{a}{p} \rfloor+\lfloor \frac{a}{p^2} \rfloor+\lfloor \frac{a}{p^3} \rfloor+\cdots$​ 个

> 即包含 $p$​ 的倍数的一共有 $\lfloor \frac{a}{p} \rfloor$​ 个
> 包含 $p^2$​ 的倍数的一共有 $\lfloor \frac{a}{p^2} \rfloor$​​ 个，虽然同时它们肯定都是 $p$ 的倍数，但是它们要比单纯只是 $p$ 的倍数的数多贡献一个因子
> 只是统计是多少倍数的数有多少个，并不会计算重复

**代码：**

```c
#pragma GCC optimize(2)
#include <bits/stdc++.h>
using namespace std;
const int N = 5010;

int primes[N], cnt;
int sum[N]; //没一个质数的次数
bool st[N];

void get_primes(int n)
{
    for (int i = 2; i <= n; i++)
    {
        if (!st[i])
            primes[cnt++] = i;
        for (int j = 0; primes[j] <= n / i; j++)
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0)
                break;
        }
    }
}

//求n!里面包含p的个数
int get(int n, int p)
{
    int res = 0;
    while (n)
    {
        res += n / p;
        n /= p;
    }
    return res;
}

vector<int> mul(vector<int> a, int b)
{
    vector<int> c;
    int t = 0;
    for (int i = 0; i < a.size(); i++)
    {
        t += a[i] * b;
        c.push_back(t % 10);
        t /= 10;
    }
    while (t)
    {
        c.push_back(t % 10);
        t /= 10;
    }
    return c;
}

int main()
{
    int a, b;
    cin >> a >> b;
    get_primes(a);
    for (int i = 0; i < cnt; i++)
    {
        int p = primes[i];
        sum[i] = get(a, p) - get(b, p) - get(a - b, p);
    }
    //高精度将所有的因子乘起来
    vector<int> res;
    res.push_back(1);
    //枚举所有的质数
    for (int i = 0; i < cnt; i++)
    {
        for (int j = 0; j < sum[i]; j++)
        {
            res = mul(res, primes[i]);
        }
    }
    //输出
    for (int i = res.size() - 1; i >= 0; i--)
        printf("%d", res[i]);
    puts("");
    return 0;
}
```

#### 8.5 卡特兰数

**[题目：AcWing 889. 满足条件的01序列]()**

**题目描述**

给定 $n$ 个 $0$ 和 $n$ 个 $1$，它们将按照某种顺序排成长度为 $2n$ 的序列，求它们能排列成的所有序列中，能够满足任意前缀序列中 $0$ 的个数都不少于 $1$ 的个数的序列有多少个。

输出的答案对 $10^9+7$取模。

**输入格式**

共一行，包含整数 $n$。

**输出格式**

共一行，包含一个整数，表示答案。

**数据范围**

$1≤n≤10^5$

**输入样例：**

```r
3
```

**输出样例：**

```
5
```

**题解：**

- 算法标签：组合数学 组合计数 卡特兰数 逆元 快速幂 费马小定理

> 坐标系下面：
>
> 0：表示向右走一格
>
> 1：表示向上走一格
>
> 求从（0，0）走到（i，j）的路径有多少条？可以将任何路径转换为01的排列
>
> 任何前缀里面0的个数大于1的个数等价任意路径中x>=y,在坐标轴对角线的下面区域，要严格在y=x+1下面
>
> 每次第一个不满足条件的节点，就是与y=x+1的第一个交点，找到其关于y=x+1的终点的对称点，也就是点（n-1,n+1）

>$C_{2n}^n-C_{2n}^{n-1}$=$ \frac{1}{n+1} C_{2n}^n$

**代码：**

```c
#include <bits/stdc++.h>
using namespace std;
const int mod = 1e9 + 7;
typedef long long LL;

//快速幂求逆元
int qmi(int a, int k, int p)
{
    int res = 1;
    while (k)
    {
        if (k & 1)
            res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}

int main()
{
    int n;
    cin >> n;
    int a = 2 * n, b = n;
    int res = 1;

    for (int i = a; i > a - b; i--)
        res = (LL)res * i % mod;
    for (int i = 1; i <= b; i++)
        res = (LL)res * qmi(i, mod - 2, mod) % mod;
    res = (LL)res * qmi(n + 1, mod - 2, mod) % mod;
    cout << res << endl;
    return 0;
}
```

### 9.容斥原理

**[题目：AcWing 890. 能被整除的数]()**

**题目描述**

给定一个整数 $n$ 和 $m$ 个不同的质数 $p_1,p_2,\cdots,p_m$。

请你求出 $1∼n$ 中能被 $p_1,p_2,\cdots,p_m$ 中的至少一个数整除的整数有多少个。

**输入格式**

第一行包含整数 $n$ 和 $m$。

第二行包含 $m$ 个质数。

**输出格式**

输出一个整数，表示满足条件的整数的个数。

**数据范围**

$1≤m≤16$,

$1≤n,p_i≤10^9$

**输入样例：**

```r
10 2
2 3
```

**输出样例：**

```
7
```

**题解：**

奇加偶减(s1+s2+s3-s1∩s2-s2∩s3-s1∩s3+s1∩s2∩s3)

韦恩图

从n个数中选任意多个数的方案数

$C_n^0+C_n^2+....C_n^n=2^n$

时间复杂度$O(2^m)$

用位运算表示，二进制数上面是1表示这个数选择了，为0表示这个数没有选择

**代码：**

```c
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 20;

int n, m;
int p[N];

int main()
{
    cin >> n >> m;
    for (int i = 0; i < m; i++)
        cin >> p[i];
    int res = 0;
    //枚举所有集合，用位运算来枚举，从n个集合里面选择任意多个集合有2^n-1个
    for (int i = 1; i < 1 << m; i++)
    {
        //把i看作m位，不足在高位补0
        // t表示所有质数的乘积，cnt表示当前选法里面包含几个1
        int t = 1, cnt = 0;
        //如果当前位为1
        for (int j = 0; j < m; j++)
        {
            // i的j位是否为1
            if (i >> j & 1)
            {
                cnt++;
                //不用算，标记一下
                if ((LL)t * p[j] > n)
                {
                    t = -1;
                    break;
                }
                t *= p[j];
            }
        }
        //几个质数的乘积是<=n的，需要算
        if (t != -1)
        {
            //集合个数奇数加上，偶数减去
            if (cnt % 2)
                res += n / t;
            else
                res -= n / t;
        }
    }
    cout << res << endl;
    return 0;
}
```



### 10.博弈论

>以下内容摘自《算法竞赛进阶指南》（第6次印刷）

**NIM博弈**

给定 $n$ 堆物品，第 $i$ 堆物品有 $A_i$ 个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手能否必胜

我们把这种游戏称为**NIM博弈**。把游戏过程中面临的状态称为**局面**。整局游戏第一个行动的称为**先手**，第二个行动的称为**后手**。

若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面**必败**。所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对手面临必败局面，则优先采取该行动。同时，这样的局面被称为**必胜**。

>先手必胜状态：可以走到某一个必败状态
>先手必败状态：走不到任何一个必败状态

我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。NIM博弈不存在平局，只有**先手必胜**和**先手必败**两种情况。

**定理：NIM博弈先手必胜，当且仅当 $A_1 \;xor\; A_2\;xor\;\cdots\;xor\;A_n \not=0$​**

**证明**

所有物品都被取光是一个必败局面（对手取走最后一个物品，已经获得胜利），此时显然有 $A_1 \;xor\; A_2\;xor\;\cdots\;xor\;A_n =0$

对于任意一个局面，如果 $A_1 \;xor\; A_2\;xor\;\cdots\;xor\;A_n =x \not =0$​，设 $x$​ 的二进制表示下最高位的 $1$​ 在第 $k$​ 位，那么至少存在一堆石子 $A_i$​，它的第 $k$​ 位是 $1$​，显然 $A_i \; xor \; x< A_i$​，我们就从 $A_i$​ 堆中取走若干石子，使其变为 $A_i \; xor \; x$​，就得到了一个各堆石子数异或起来等于 $0$​ 的局面

对于任意一个局面，如果 $A_1 \;xor\; A_2\;xor\;\cdots\;xor\;A_n =0$，那么无论如何取石子，得到的局面下各堆石子异或起来都不等于 $0$。可用反证法证明，假设 $A_i$ 被取成了 $A_i'$，并且 $A_1 \;xor\; A_2\;xor\;\cdots \;xor A_i \; xor\; \cdots \;xor\;A_n =0$。由异或运算的消去律得 $A_i=A_i'$，与 "不能不取石子" 的规则矛盾

综上所诉，再由数学归纳法可知，$A_1 \;xor\; A_2\;xor\;\cdots\;xor\;A_n \not=0$ 为必胜局面，一定存在一种行动让对手面临 “各堆石子异或起来等于 $0$”。$A_1 \;xor\; A_2\;xor\;\cdots\;xor\;A_n =0$ 为必败局面，无论如何行动，都会让对手面临一个 "各堆石子异或起来不等于 $0$​" 的必胜局面

证毕

> 可以了解一下巴什博弈，推荐博客：https://www.cnblogs.com/Khada-Jhin/p/9609561.html



**公平组合游戏ICG**

若一个游戏满足：

1. 由两名玩家交替行动
2. 在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关
3. 不能行动的玩家判负

这称该游戏为一个公平组合游戏

>NIM博弈属于公平组合游戏，但常见的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3



**有向图游戏**

给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿着有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为**有向图游戏**

任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从 每个局面 向 沿着合法行动能够到达的下一个局面 连有向边



**Mex运算**

设 $S$ 表示一个非负整数集合。定义 $mex(S)$ 为求出**不属于集合 $S$ 的最小非负整数**的运算，即 $mex(S)=min_{x\in N,x \notin S}\{x\}$



**SG函数**

在有向图游戏中，对于每个节点 $x$，设从 $x$ 出发共有 $k$ 条有向边，分别到达节点 $y_1,y_2,\cdots,y_k$，定义 $SG(x)$ 为 $x$ 的后继节点 $y_1,y_2,\cdots,y_k$ 的 $SG$ 函数值构成的集合再执行 $mex$ 运算的结果，即 $SG(x)=mex(\{SG(y_1),SG(y_2),\cdots,SG(y_k)\})$

特别地，整个有向图游戏 $G$ 的 $SG$ 函数值被定义为有向图游戏起点 $s$ 的 $SG$ 函数值，即 $SG(G)=SG(s)$

>$SG($​终点$)=0$​
>$SG(x)=mex(\{SG(y_1),SG(y_2),\cdots,SG(y_k)\})$​
>
>**有 $SG(x)=0$​ 必败， $SG(x)\not=0$​ 必胜**
>因为如果 $SG(x)\not=0$​，则说明 $x$​ 是可以到达 $0$​ 的，而如果 $SG(x)=0$​ 则说明 $x$​ 是到不了 $0$​​​ 的（往下有进一步的证明)
>
>Q：那既然 $SG(x)\not=0$ 就必胜，为什么不定义非 $0$ 即为 $1$ 呢？
>A：如果只有一个图，那确实是可以的；但对于复杂的问题就不行了



**有向图游戏的和**

设 $G_1,G_2,\cdots,G_m$ 是 $m$ 个有向图游戏。定义有向图游戏 $G$，它的行动规则是任选某个有向图游戏 $G_i$，并在 $G_i$ 上行动一步。 $G$ 被称为有向图游戏 $G_1,G_2,\cdots,G_m$ 的和

有向图游戏的和的 $SG$ 函数值等于它包含的各个子游戏 $SG$ 函数值的异或和

即 $SG(G)= SG(G_1) \; xor\; SG(G_2) \; xor \; \cdots \;xor \; SG(G_m)$

> $=0$​ 必败，$\not=0$​ 必胜

**定理**

有向图游戏的某个局面必胜，当且仅当该局面对应节点的 $SG$ 函数值大于 $0$
有向图游戏的某个局面必败，当且仅当该局面对应节点的 $SG$ 函数值等于 $0$

我们不再详细证明该定理。读者可以这样理解：

在一个没有出边的节点上，棋子不能移动，它的 $SG$ 值为 $0$，对应必败局面

若一个节点的某个后继节点 $SG$ 值为 $0$，在 $mex$ 运算后，该节点的 $SG$ 值大于 $0$。这等价于，若一个局面的后继局面中存在必败局面，则当前局面为必胜局面

若一个节点的后继节点 $SG$ 值均不为 $0$，在 $mex$ 运算后，该节点的 $SG$ 值为 $0$。这等价于，若一个局面的后继局面全部为必胜局面，则当前局面为必败局面

对于若干个有向图游戏的和，其证明方法与NIM博弈类似

>①若 所有的$SG(x_i)=0$ ，则 $SG(G)= SG(G_1) \; xor\; SG(G_2) \; xor \; \cdots \;xor \; SG(G_m)=0$，先手必败
>
>②若 $SG(G)= SG(G_1) \; xor\; SG(G_2) \; xor \; \cdots \;xor \; SG(G_m) = x \not=0$，则会存在 $SG(x_i) \;xor\;x<SG(x_i)$，就一定可以走到 $SG(x_i) \;xor\;x$ 这一局面，使 $SG(G)= SG(G_1) \; xor\; SG(G_2) \; xor \; \cdots \;xor \; SG(G_m)=0$
>
>③若 $SG(G)= SG(G_1) \; xor\; SG(G_2) \; xor \; \cdots \;xor \; SG(G_m)=0$，利用反证法，通过消去律得到 $SG(x_i)=k \to SG(x_i)'=k$，但$SG(x_i)$ 自己都等于 $k$ 了，不可能再走到 $k$ 这一局面，所以不论怎么变，都会使 $SG(G)= SG(G_1) \; xor\; SG(G_2) \; xor \; \cdots \;xor \; SG(G_m)\not=0$​


---

#### 10.1 NIM博弈-（Nim游戏）

**[题目：AcWing 891. Nim游戏]()**

**题目描述**

给定 $n$ 堆石子，两位玩家轮流操作，每次操作可以从任意一堆石子中拿走任意数量的石子（可以拿完，但不能不拿），最后无法进行操作的人视为失败。

问如果两人都采用最优策略，先手是否必胜。

**输入格式**

第一行包含整数 $n$。

第二行包含 $n$ 个数字，其中第 $i$ 个数字表示第 $i$ 堆石子的数量。

**输出格式**

如果先手方必胜，则输出 `Yes`。

否则，输出 `No`。

**数据范围**

$1≤n≤10^5$,

$1≤$每堆石子数$≤10^9$

**输入样例：**

```r
2
2 3
```

**输出样例：**

```
Yes
```

**代码：**

```c
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int n;
    int res = 0;

    cin >> n;
    while (n--)
    {
        int x;
        cin >> x;
        res ^= x;
    }
    if (res)
        puts("Yes");
    else
        puts("No");
    return 0;
}
```

#### 10.2  台阶-Nim游戏

**[题目：AcWing 892. 台阶-Nim游戏]()**

**题目描述**

现在，有一个 $n$ 级台阶的楼梯，每级台阶上都有若干个石子，其中第 $i$ 级台阶上有 $a_i$ 个石子（$i≥1$）。

两位玩家轮流操作，每次操作可以从任意一级台阶上拿若干个石子放到下一级台阶中（不能不拿）。

已经拿到地面上的石子不能再拿，最后无法进行操作的人视为失败。

问如果两人都采用最优策略，先手是否必胜。

**输入格式**

第一行包含整数 $n$。

第二行包含 $n$ 个整数，其中第 $i$ 个整数表示第 $i$ 级台阶上的石子数 $a_i$。

**输出格式**

如果先手方必胜，则输出 `Yes`。

否则，输出 `No`。

**数据范围**

$1≤n≤10^5$,

$1≤a_i≤10^9$

**输入样例：**

```r
3
2 1 3
```

**输出样例：**

```
Yes
```

**题解：**

``` 

```

**代码：**

```c

```

#### 10.3  **SG函数**-（集合-Nim游戏）

**[题目：AcWing 893. 集合-Nim游戏]()**

**题目描述**

给定 $n$ 堆石子以及一个由 $k$ 个不同正整数构成的数字集合 $S$。

现在有两位玩家轮流操作，每次操作可以从任意一堆石子中拿取石子，每次拿取的石子数量必须包含于集合 $S$，最后无法进行操作的人视为失败。

问如果两人都采用最优策略，先手是否必胜。

**输入格式**

第一行包含整数 $k$，表示数字集合 $S$ 中数字的个数。

第二行包含 $k$ 个整数，其中第 $i$ 个整数表示数字集合 $S$ 中的第 $i$ 个数 $s_i$。

第三行包含整数 $n$。

第四行包含 $n$ 个整数，其中第 $i$ 个整数表示第 $i$ 堆石子的数量 $h_i$。

**输出格式**

如果先手方必胜，则输出 `Yes`。

否则，输出 `No`。

**数据范围**

$1≤n,k≤100$,

$1≤s_i,h_i≤10000$

**输入样例：**

```r
2
2 5
3
2 4 7
```

**输出样例：**

```
Yes
```

**题解：**

``` 

```

**代码：**

```c
#include <bits/stdc++.h>
using namespace std;
const int N = 110, M = 10010;
int n, m;
int s[N], f[M];

int sg(int x)
{
    if (f[x] != -1)
        return f[x];
    //存所有能到的局面
    unordered_set<int> S;
    for (int i = 0; i < m; i++)
    {
        //当前数的个数
        int sum = s[i];
        if (x >= sum)
            S.insert(x - sum);
    }

    for (int i = 0;; i++)
    {
        if (!S.count(i))
            return f[x] = i;
    }
}

int main()
{
    cin >> m;
    for (int i = 0; i < m; i++)
        cin >> s[i];

    cin >> n;
    //记忆化搜索
    memset(f, -1, sizeof f);

    int res = 0;
    for (int i = 0; i < n; i++)
    {
        int x;
        cin >> x;
        res ^= sg(x);
    }
    if (res)
        puts("Yes");
    else
        puts("No");
    return 0;
}
```

#### 10.4  拆分-Nim游戏

**[题目：AcWing 894. 拆分-Nim游戏]()**

**题目描述**

给定 $n$ 堆石子，两位玩家轮流操作，每次操作可以取走其中的一堆石子，然后放入两堆规模更小的石子（新堆规模可以为 $0$，且两个新堆的石子总数可以大于取走的那堆石子数），最后无法进行操作的人视为失败。

问如果两人都采用最优策略，先手是否必胜。

**输入格式**

第一行包含整数 $n$。

第二行包含 $n$ 个整数，其中第 $i$ 个整数表示第 $i$ 堆石子的数量 $a_i$。

**输出格式**

如果先手方必胜，则输出 `Yes`。

否则，输出 `No`。

**数据范围**

$1≤n,a_i≤100$

**输入样例：**

```r
2
2 3
```

**输出样例：**

```
Yes
```

**题解：**

``` 

```

**代码：**

```c

```



## 五.动态规划

```
DP  1.状态(一个集合)表示
		二维：f(i,j)
		1.1 集合：所有选法
				条件：（1）只从前i个物品中选
					 （2）总体积<=j
		1.2 属性：max值,min值,元素数量
	2.状态计算:一步一步的将状态计算出来
		集合的划分,不重复（不一定需要必须满足），不遗漏
		f(i,j)集合划分为若干个更小的子集，每个子集都能求出答案
		（1）选法不包含i：f(i-1,j)
			所有从1-i中选，总体积<=j，不包含i中选择
			所有从1~i-1中选，总体积<=j选法
		（2）选法包含i: f(i-1,j-Vi)+Wi
			所有从1-i中选，总体积<=j，包含i中选择
		  =>将Vi拿走结果不变
		  =>所有从1~i-1中选，总体积<=j-Vi，包含i中选择:f(i-1,j-Vi)+Wi
		  
		  最终f(i,j)=max(f(i-1,j),f(i-1,j-Vi)+Wi)
	3.dp优化
		对dp的代码和计算方程进行变形
```

### 1.背包问题

```
1.01背包 ： 每件物品最多只能用一次
2.完全背包 ： 每件物品有无限个
3.多重背包及优化版本：每个物品有有限个，告诉限制个数
4.分组背包 ： 有N组，每组里面有若干元素，每组里面最多选择一个物品
```



#### 1.1  01背包问题

**[题目：AcWing 2. 01背包问题]()**

**题目描述**

有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。

第 i 件物品的体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

**输入格式**

第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。

接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

$0 < N,V ≤ 1000$

$0<vi,wi≤1000$

**输入样例：**

```c
4 5
1 2
2 4
3 4
4 5
```

**输出样例：**

```c
8
```

**题解：**

``` c
每件物品最多只能用一次
DP  1.状态(一个集合)表示
		二维：f(i,j)
		1.1 集合：所有选法
				条件：（1）只从前i个物品中选
					 （2）总体积<=j
    
		1.2 属性：max值
    
	2.状态计算:一步一步的将状态计算出来
		集合的划分,不重复（不一定需要必须满足），不遗漏
		f(i,j)集合划分为若干个更小的子集，每个子集都能求出答案
		（1）选法不包含i：f(i-1,j)
			所有从1-i中选，总体积<=j，不包含i
		  =>所有从1~i-1中选，总体积<=j选法
		（2）选法包含i: f(i-1,j-V[i])+Wi
			所有从1-i中选，总体积<=j，包含i中选择
		  =>将V[i]拿走,求不包含V[i]的答案，在加上V[i]的值w[i]
		  =>所有从1~i-1中选，总体积<=j-V[i]，包含i中选择:f(i-1,j-V[i])+W[i]
		  
		  最终f(i,j)=max(f(i-1,j),f(i-1,j-V[i])+W[i])
    3.优化
    	(1)f(i,j)=max(f(i-1,j),f(i-1,j-V[i])+W[i])每个阶段的i的状态只用到了i-1的状态，
            利用“滚动数组”优化，第二维要么是j要么是j-Vi都<=j;
			f[i][j] = f[i - 1][j];
		  =>f[i&1][j] = f[(i - 1)&1][j];

			f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
          =>f[i&1][j] = max(f[i&1][j], f[(i - 1)&1][j - v[i]] + w[i]);
			
			f[n][j]
          =>f[n&1][j]
            i的状态用i&1替代，当i为奇数的时候,i&1=1；当i为偶数的时候，i&1==0
            这样的话dp的状态就相当于在f[1][]和f[0][]两个数组中交替转化，O(NM)变为O(M)
            
            每个阶段实际上是执行了一次从f[i-1][]到f[i][]的拷贝操作，进一步省去f[i]
                
        (2)如果j从小往大遍历，后面的dp[j]可能已经被前面的更新了，相当于dp[i][j - v[i]]
        (3)所以让j从大到小倒序遍历。当j的时候，f数组的后半部分f[j~m]处于i阶段，就是放入第i个物品的情况；前半部分f[0~j-1]处于第i-1阶段，也就是没有i的更新；j减小就是用i-1状态去更新i状态。
        (4)如果是正序遍历j的话，可能会覆盖，产生矛盾
            
    4.注意：
    	(1)初值：f[0,0]=0,其余为负无穷
                
```

**代码：**

```c
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 1010;
int n, m;
int v[N], w[N];
int f[N][N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> v[i] >> w[i];
    // f[0~n][0~m]
    // f[0][0~m]=0，一件物品也没有选，都为0,所以不用枚举
    for (int i = 1; i <= n; i++)
    {
        // j=0表示一共选了体积为0的物体
        for (int j = 0; j <= m; j++)
        {
            //选法不包含i
            f[i][j] = f[i - 1][j];
            //选法包含i,第i件物品体积小于等于背包总容量
            if (j >= v[i])
                f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
        }
    }
    cout << f[n][m] << endl;
    return 0;
}
```

**优化后代码：**

```c
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 1010;
int n, m;
int v[N], w[N];
int f[N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> v[i] >> w[i];
    // f[0~n][0~m]
    // f[0][0~m]=0，一件物品也没有选，都为0,所以不用枚举
    for (int i = 1; i <= n; i++)
    {
        // j=0表示一共选了体积为0的物体	
        for (int j = m; j >= v[i]; j--)
        {
            f[j] = max(f[j], f[j - v[i]] + w[i]);
        }
    }
    cout << f[m] << endl;
    return 0;
}
```



#### 1.2 完全背包问题

**[题目：AcWing 3. 完全背包问题]()**

**题目描述**

有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。

第 i 种物品的体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

**输入格式**

第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。

接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 种物品的体积和价值。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

$0 < N,V ≤ 1000$

$0 < vi,wi ≤ 1000$

**输入样例：**

```c
4 5
1 2
2 4
3 4
4 5
```

**输出样例：**

```c
10
```

**题解：**

> **结论**：
>
> 将0-1背包中j的循环顺序改成从小到大，就变成了完全背包。
>
> 0-1背包：`dp[i][j] = max(dp[i-1][j], dp[i-1][j-vi]+wi)`
>
> 完全背包：`dp[i][j] = max(dp[i-1][j], dp[i][j-vi]+wi)`
>
> 0-1背包是从 i-1 转移过去的（从大到小枚举的），完全背包是从 i 转移过去的（从小到大枚举）

``` c
每件物品有无限个
DP 1.状态表示f(i,j)
    	1.1 集合
    		所有只考虑前i个物品，且总体积不大于j的所有选法
    	1.2 属性
    		Max
   2.状态计算
    	集合的划分:分若干组，按照第i个物品选多少个分
            0 1 2 3 4 5 ....k-1 k  第i个物品选了0~k个
            f(i,j)表示选第i个物品，总体积不超过j
    	(1)第i个物品不选，只考虑前1~i-1的话用f(i-1,j)表示
            当k=0,f(i-1,j)=f(i-1,j-k*v[i])+k*w[i]
        (2)第i个物品选，选k个
            1)去掉k个物品i
            2)求MAX,f(i-1,j-k*v[i])
            3)再加回来k个物品i
            =>f(i-1,j-k*v[i])+k*w[i]
     	=>f(i,j)=f(i-1,j-v[i]*k)+w[i]*k
            
   3.优化
   	f(i,j)=max(f(i-1,j) ,f(i-1,j-v)+w ,f(i-1,j-2*v)+2w ,f(i-1,j-3*v)+3w ,..,f(i-1,j-(k-1)*v)+(k-1)*v ,f(i-1,j-k*v)+k*v)
    f(i,j-v)=max(        f(i-1,j-v)   ,f(i-1,j-2*v)+ w ,f(i-1,j-3*v)+2w ,..,f(i-1,j-(k-1)*v)+(k-2)*v ,f(i-1,j-k*v)+(k-1)*v)       
            =>f(i,j)=max(f(i-1,j),f(i-1,j-v)+w)
        
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;
const int N = 1010;

int n, m;
int v[N], w[N];
int f[N][N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> v[i] >> w[i];

    for (int i = 1; i <= n; i++)
        for (int j = 0; j <= m; j++)
            for (int k = 0; k * v[i] <= j; k++)
                f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);
    cout << f[n][m] << endl;
    return 0;
}
```

**优化代码**

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;
const int N = 1010;

int n, m;
int v[N], w[N];
int f[N][N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> v[i] >> w[i];

    for (int i = 1; i <= n; i++)
        for (int j = 0; j <= m; j++)
        {
            f[i][j] = f[i - 1][j];
            if (j >= v[i])
                f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]);
        }

    cout << f[n][m] << endl;
    return 0;
}
```

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;
const int N = 1010;

int n, m;
int v[N], w[N];
int f[N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> v[i] >> w[i];

    for (int i = 1; i <= n; i++)
        for (int j = v[i]; j <= m; j++)
            f[j] = max(f[j], f[j - v[i]] + w[i]);

    cout << f[m] << endl;
    return 0;
}
```



#### 1.3 多重背包问题

**[题目：AcWing 4. 多重背包问题 I]()**

**题目描述**

有 N 种物品和一个容量是 V 的背包。

第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。

**输入格式**

第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。

接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

$0 < N,V ≤ 100$

$0 < vi,wi,si ≤ 100$

**输入样例：**

```c
4 5
1 2 3
2 4 1
3 4 3
4 5 2
```

**输出样例：**

```c
10
```

**题解：**

``` c
DP 1.状态表示f(i,j)
    1.1 集合
    	所有从前i个物品中选，并且总体积不超过j的选法
    
    1.2 属性
    	Max，总价值的最大值
    
    2.状态计算
    	集合的划分:分若干组，按照第i个物品选多少个分(完全背包类似)
            0 1 2 3 4 5 .... s[i]  第i个物品选了0~k个
            
		状态转移方程：f(i,j)=max(f[i][j],f[i-1][j-v[i]*k]+w[i]*k)  k=0,1,2.....s[i]
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 110;

int n, m;
int v[N], w[N], s[N];
int f[N][N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> v[i] >> w[i] >> s[i];

    for (int i = 1; i <= n; i++)
        for (int j = 0; j <= m; j++)
            for (int k = 0; k <= s[i] && k * v[i] <= j; k++)
                f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);

    cout << f[n][m] << endl;
    return 0;
}
```



**[题目：AcWing 5. 多重背包问题 II]()**

**题目描述**

有 N 种物品和一个容量是 V 的背包。

第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。

输出最大价值。

**输入格式**

第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。

接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

$0 < N ≤ 1000$

$0 < V ≤ 2000$

$0 < vi,wi,si ≤ 2000$

**输入样例：**

```c
4 5
1 2 3
2 4 1
3 4 3
4 5 2
```

**输出样例：**

```c
10
```

**题解：**

``` c
DP 1.状态表示f(i,j)
    1.1 集合
    	所有从前i个物品中选，并且总体积不超过j的选法
    
    1.2 属性
    	Max，总价值的最大值
    
    2.状态计算
    	集合的划分:分若干组，按照第i个物品选多少个分(完全背包类似)
            0 1 2 3 4 5 .... s[i]  第i个物品选了0~k个
            
		状态转移方程：f(i,j)=max(f[i][j],f[i-1][j-v[i]*k]+w[i]*k)  k=0,1,2.....s[i]
    3.优化
    f(i,j)=max(f(i,j),f(i-1,j-v)+w,f(i-1,j-2v)+2w,......f(i-1,j-sv)+sw)
    f(i,j-v)=max(     f(i-1,j-v),  f(i-1,j-2v)+w, ......f(i-1,j-sv)+(s-1)w ,f(i-1,j-(s+1)v)+sw);
		
	二进制优化 
        有s个物品：
        1，2，4，8，.....2^k,C
        C< 2^(k+1)
        所以可以凑出来C~C+2^(k+1)-1的数
```

**代码**

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 110;

int n, m;
int v[N], w[N], s[N];
int f[N][N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> v[i] >> w[i] >> s[i];

    for (int i = 1; i <= n; i++)
        for (int j = 0; j <= m; j++)
            for (int k = 0; k <= s[i] && k * v[i] <= j; k++)
                f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);

    cout << f[n][m] << endl;
    return 0;
}
```

**代码优化：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

// 1000 * log(2000) 开数据
const int N = 25000, M = 2010;

int n, m;
int v[N], w[M];
int f[N];

int main()
{
    cin >> n >> m;

    int cnt = 0;

    for (int i = 1; i <= n; i++)
    {
        int a, b, s;
        cin >> a >> b >> s;
        //小于S的时候一直减了凑：1+2+4+8+...+2^k+c <= s
        int k = 1;
        while (k <= s)
        {
            cnt++;
            v[cnt] = a * k;
            w[cnt] = b * k;
            s -= k;
            k *= 2;
        }
        //此时c == s
        if (s > 0)
        {
            cnt++;
            v[cnt] = a * s;
            w[cnt] = b * s;
        }
    }
    n = cnt;
    for (int i = 1; i <= n; i++)
        for (int j = m; j >= v[i]; j--)
            f[j] = max(f[j], f[j - v[i]] + w[i]);
    cout << f[m] << endl;
    return 0;
}
```

#### 1.4 分组背包问题

**[题目：AcWing 9. 分组背包问题]()**

**题目描述**

有 N 组物品和一个容量是 V 的背包。

每组物品有若干个，同一组内的物品最多只能选一个。

每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。

求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。

输出最大价值。

**输入格式**

第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。

接下来有 N 组数据：

- 每组数据第一行有一个整数 Si，表示第 i 个物品组的物品数量；
- 每组数据接下来有 Si 行，每行有两个整数 vij,wij，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值；

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

$0 < N,V ≤ 100$

$0 < Si ≤ 100$

$0 < vij,wij ≤ 100$

**输入样例：**

```c
3 5
2
1 2
2 4
1
3 4
1
4 5
```

**输出样例：**

```c
8
```

**题解：**

``` c
DP 1.状态表示f(i,j)
    1.1 集合
    	所有从前i组物品中选，并且总体积不大于j的选法
    
    1.2 属性
    	Max，总价值的最大值
    
   2.状态计算
    	集合的划分:分若干组，按照第i个物品选多少个分(完全背包类似)
            0 1 2 3 4 5 .... s[i]  选第i组的第k个物品选了0~k个
        (1)第i组的一个都不选
            f(i-1,j)
        (2)第i组物品选第k个物品
            f(i-1,j-v[i,k])+w[i,k]
           
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 110;
int n, m;
// s存每组的个数
int v[N][N], w[N][N], s[N];
int f[N];

int main()
{
    cin >> n >> m;

    for (int i = 1; i <= n; i++)
    {
        cin >> s[i];
        for (int j = 0; j < s[i]; j++)
            cin >> v[i][j] >> w[i][j];
    }

    for (int i = 1; i <= n; i++)
    {
        for (int j = m; j >= 0; j--)
        {
            for (int k = 0; k < s[i]; k++)
            {
                if (v[i][k] <= j)
                    f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);
            }
        }
    }
    cout << f[m] << endl;
    return 0;
}
```



### 2.线性DP

#### (1) 数字三角形

**[题目：AcWing 898. 数字三角形]()**

**题目描述**

给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。

```r
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
```

**输入格式**

第一行包含整数n，表示数字三角形的层数。

接下来n行，每行包含若干整数，其中第 i 行表示数字三角形第 i 层包含的整数。

**输出格式**

输出一个整数，表示最大的路径数字和。

**数据范围**

$1≤n≤500,$
$−10000$≤三角形中的整数≤$10000$

**输入样例：**

```c
5
7
3 8
8 1 0 
2 7 4 4
4 5 2 6 5
```

**输出样例：**

```c
30
```

**题解：**

``` c
DP
    1.状态表示
    	1.1 集合：所有从起点，走到(i,j)的路径
    	1.2 属性: 所有路径上的数字之和的最大值Max
            
    2.状态计算：f(i,j)
        (1)来自左上方
            f(i-1,j-1)+a[i][j]
        (2)来自上面
            f(i-1,j)+a[i][j]
        (3)状态转移方程：f(i,j)=max(f(i-1,j-1)+a[i][j],f(i-1,j)+a[i][j])
        (4)时间复杂度=状态数量X转移的计算量  
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 510, INF = 1e9;
int n;
int a[N][N];
int f[N][N];

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= i; j++)
            cin >> a[i][j];

    //为了不处理边界，将f状态数组置为负无穷,从0开始,每行初始化为i+1个
    for (int i = 0; i <= n; i++)
        for (int j = 0; j <= i + 1; j++)
            f[i][j] = -INF;

    f[1][1] = a[1][1];

    for (int i = 2; i <= n; i++)
        for (int j = 1; j <= i; j++)
            f[i][j] = max(f[i - 1][j - 1] + a[i][j], f[i - 1][j] + a[i][j]);

    int res = -INF;

    for (int i = 1; i <= n; i++)
        res = max(res, f[n][i]);

    cout << res << endl;

    return 0;
}
```

#### (2) 最长上升子序列

**[题目：AcWing 895. 最长上升子序列]()**

**题目描述**

给定一个长度为N的数列，求数值严格单调递增的子序列的长度最长是多少。

**输入格式**

第一行包含整数N。

第二行包含N个整数，表示完整序列。

**输出格式**

输出一个整数，表示最大长度。

**数据范围**

$1≤N≤1000，$

$−10^9≤数列中的数≤10^9$

**输入样例：**

```c
7
3 1 2 1 8 5 6
```

**输出样例：**

```c
4
```

**题解：**

``` c
DP
    1.状态表示 f[i]
    	1.1 集合:所有以第i个数结尾的上升子序列的集合
    	1.2 属性：集合里面每一个上升子序列的长度的最大值Max
    2.状态计算
        集合划分f[i]:0 1 2 3 ....i-1
        (1)集合里面没有数
        (2)集合里面以第1个数结尾，以第2个数结尾，以第3个数结尾，...
        状态转移方程:a[i]=max(f[i],f[j]+1)  a[j]<a[i]  j=0,1,2,..i-1
        时间复杂度=状态数量X转移的计算量=n*n
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 1010;

int n;
int a[N], f[N];

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    for (int i = 1; i <= n; i++)
    {
        f[i] = 1; //以i结尾的只有一个数a[i]
        for (int j = 1; j < i; j++)
        {
            if (a[j] < a[i])
                f[i] = max(f[i], f[j] + 1);
        }
    }

    int res = 0;
    for (int i = 1; i <= n; i++)
        res = max(res, f[i]);
    cout << res << endl;
    return 0;
}
```

**保存序列（存下状态转移）**

```c
//保存下来序列
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 1010;

int n;
int a[N], f[N], g[N];

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    for (int i = 1; i <= n; i++)
    {
        f[i] = 1; //以i结尾的只有一个数a[i]
        g[i] = 0; //表示只有一个数
        for (int j = 1; j < i; j++)
        {
            if (a[j] < a[i])
            {
                if (f[i] < f[j] + 1)
                {
                    f[i] = f[j] + 1;
                    //记录每个状态是从哪里转移来的
                    g[i] = j;
                }
            }
        }
    }

    //最优解下标
    int k = 1;
    for (int i = 1; i <= n; i++)
        if (f[k] < f[i])
            k = i;

    cout << f[k] << endl;
    for (int i = 0, le = f[k]; i < le; i++)
    {
        cout << a[k] << " ";
        k = g[k];
    }
    return 0;
}
```

#### (3)最长公共子序列

**[题目：AcWing 897. 最长公共子序列]()**

**题目描述**

给定两个长度分别为N和M的字符串A和B，求既是A的子序列又是B的子序列的字符串长度最长是多少。

**输入格式**

第一行包含两个整数N和M。

第二行包含一个长度为N的字符串，表示字符串A。

第三行包含一个长度为M的字符串，表示字符串B。

字符串均由小写字母构成。

**输出格式**

输出一个整数，表示最大长度。

**数据范围**

$1≤N,M≤1000$

**输入样例：**

```c
4 5
acbd
abedc
```

**输出样例：**

```c
3
```

**题解：**

``` c
DP
    1.状态表示f(i,j)
    	1.1 集合
    		所有在第一个序列的前i个字母中出现，且在第二个序列的前j个字母中出现的子序列
    	1.2 属性
    		所有长度的最大值Max
    		(1)求最大最小值答案可以重复，max(a,b)和max(b,c)得到max(a,b,c)
    		(2)求数量答案一定不能重复
    
    2.状态计算
    	集合划分：a[i],b[j]是否包含在子序列中
    			选a[i]选b[j],不选a[i]选b[j],选a[i]不选b[j],不选a[i]不选b[j]
    	(1)00 不选a[i]不选b[j]   f(i-1,j-1)这个序列一般不写，已经包含在了01和10的情况里面
    	(2)01 不选a[i]选b[j]	 f(i-1,j)不一定包含b[j],一定包含01的情况
    	(3)10 选a[i]不选b[j]	 f(i,j-1)
    	(4)11 选a[i]选b[j] 	  f(i-1,j-1)+1当a[i]==b[j]的时候
    	===>f(i,j)=max(01,10,11)
    	
```

**代码：**

```c
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;
const int N = 1010;

int n, m;
char a[N], b[N];
int f[N][N];

int main()
{
    scanf("%d%d", &n, &m);
    scanf("%s%s", a + 1, b + 1);
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            f[i][j] = max(f[i - 1][j], f[i][j - 1]);
            if (a[i] == b[j])
                f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1);
        }
    }
    printf("%d\n", f[n][m]);
    return 0;
}
```



### 3.区间DP

**[题目：AcWing 282. 石子合并]()**

**题目描述**

设有N堆石子排成一排，其编号为1，2，3，…，N。

每堆石子有一定的质量，可以用一个整数来描述，现在要将这N堆石子合并成为一堆。

每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。

例如有4堆石子分别为 1 3 5 2， 我们可以先合并1、2堆，代价为4，得到4 5 2， 又合并 1，2堆，代价为9，得到9 2 ，再合并得到11，总代价为4+9+11=24；

如果第二步是先合并2，3堆，则代价为7，得到4 7，最后一次合并代价为11，总代价为4+7+11=22。

问题是：找出一种合理的方法，使总的代价最小，输出最小代价。

**输入格式**

第一行一个数N表示石子的堆数N。

第二行N个数，表示每堆石子的质量(均不超过1000)。

**输出格式**

输出一个整数，表示最小代价。

**数据范围**

$1≤N≤300$

**输入样例：**

```c
4
1 3 5 2
```

**输出样例：**

```c
22
```

**题解：**

``` c
DP
    1.状态表示f(i,j)
    	1.1 集合：所有将第i堆石子到第j堆石子合并成一堆石子的合并方式
    	1.2 属性：所有合并方式的代价Min值
    2.状态计算
    	集合划分：以最后一次分界线的位置来划分，i到j有k=j-i+1个数
    	左边范围[i,k]，右边范围[k+1,j],将所有里面的最后一个数去了,加所有石子最后一次的总和代价
    	(1)左边1个，右边k-1个
    	(2)左边2个，右边k-2个
    		........
    	(k)左边k-1个，右边1个
    	==>f(i,j)=Min(f(i,k)+f(k+1,j)+s[j]-s[i-1])  k=i,i+1,...j-1
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 310;

int n;
int s[N];
int f[N][N];

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> s[i];
    //求前缀和
    for (int i = 1; i <= n; i++)
        s[i] += s[i - 1];

    //先枚举长度,当区间长度是1的话代价为0，所以从0开始
    for (int len = 2; len <= n; len++)
    {
        //枚举起点
        for (int i = 1; i + len - 1 <= n; i++)
        {
            int l = i, r = i + len - 1;
            f[l][r] = 1e8;
            for (int k = l; k < r; k++)
            {
                f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]);
            }
        }
    }
    cout << f[1][n] << endl;
    return 0;
}
```



### 4.计数类DP

**[题目：AcWing 900. 整数划分]()**

**题目描述**

一个正整数 n 可以表示成若干个正整数之和，形如：$n=n_1+n_2+…+nk_n$，其中 $n_1≥n_2≥…≥n_k,k≥1$。

我们将这样的一种表示称为正整数 n 的一种划分。

现在给定一个正整数 n，请你求出 n 共有多少种不同的划分方法。

**输入格式**

共一行，包含一个整数 n。

**输出格式**

共一行，包含一个整数，表示总划分数量。

由于答案可能很大，输出结果请对 $10^9+7$ 取模。

**数据范围**

$1≤n≤1000$

**输入样例：**

```c
5
```

**输出样例：**

```c
7
```

**题解：**

``` c
分情况讨论：
    count(n,x):表示1~n中x出现的次数
    求[a,b]中0~9的个数：count(b,x)-count(a-1,x)
    
    eg:1~n,x=1,n=abcdefg
    分别求出1在每一位上出现的次数
    
    求1在第4位上出现的次数
    1<=xxx1yyy<=abcdefg
    (1)前三位xxx = 000~abc-1，yyy=000~999    abc*1000个
    (2)xxx=abc
        2.1 d<1 ,abc1yyy>abc0efg      0个
        2.2 d=1 ,yyy=000~efg		  efg+1个
        2.3 d>1 ,yyy=000~999          1000个
    (3)考虑边界情况
        3.1 1出现在第一位的时候，(1)不存在不用考虑，只需要
        3.2 0出现在(1)中的时候
```

**代码：**

```c

```



### 5.数位统计DP

**[题目：AcWing 338. 计数问题]()**

**题目描述**

给定两个整数 a 和 b，求 a 和 b 之间的所有数字中 0∼9 的出现次数。

例如，a=1024，b=1032，则 a 和 b 之间共有 9 个数如下：

```
1024 1025 1026 1027 1028 1029 1030 1031 1032
```

其中 `0` 出现 10 次，`1` 出现 10 次，`2` 出现 7 次，`3` 出现 3 次等等…

**输入格式**

输入包含多组测试数据。

每组测试数据占一行，包含两个整数 a 和 b。

当读入一行为 `0 0` 时，表示输入终止，且该行不作处理。

**输出格式**

每组数据输出一个结果，每个结果占一行。

每个结果包含十个用空格隔开的数字，第一个数字表示 `0` 出现的次数，第二个数字表示 `1` 出现的次数，以此类推。

**数据范围**

$0<a,b<100000000$

**输入样例：**

```c
1 10
44 497
346 542
1199 1748
1496 1403
1004 503
1714 190
1317 854
1976 494
1001 1960
0 0
```

**输出样例：**

```c
1 2 1 1 1 1 1 1 1 1
85 185 185 185 190 96 96 96 95 93
40 40 40 93 136 82 40 40 40 40
115 666 215 215 214 205 205 154 105 106
16 113 19 20 114 20 20 19 19 16
107 105 100 101 101 197 200 200 200 200
413 1133 503 503 503 502 502 417 402 412
196 512 186 104 87 93 97 97 142 196
398 1375 398 398 405 499 499 495 488 471
294 1256 296 296 296 296 287 286 286 247
```

**题解：**

``` c

```

**代码：**

```c

```



### 6.状态压缩DP 

**[题目：AcWing 291. 蒙德里安的梦想]()**

**题目描述**

求把 N×M的棋盘分割成若干个 1×2的长方形，有多少种方案。

例如当 N=2，M=4时，共有 5 种方案。当 N=2，M=3 时，共有 3 种方案。

如下图所示：

![2411_1.jpg](https://www.acwing.com/media/article/image/2019/01/26/19_4dd1644c20-2411_1.jpg)

**输入格式**

输入包含多组测试用例。

每组测试用例占一行，包含两个整数 N 和 M。

当输入用例 N=0，M=0时，表示输入终止，且该用例无需处理。

**输出格式**

每个测试用例输出一个结果，每个结果占一行。

**数据范围**

$1≤N,M≤11$

**输入样例：**

```c
1 2
1 3
1 4
2 2
2 3
2 4
2 11
4 11
0 0
```

**输出样例：**

```c
1
0
1
2
3
5
144
51205
```

**题解：**

``` c
f(i,j)表示第i列，j存上一列伸出来的小方格，伸出来表示为1，没有出来为0，用二进制表示
    先横着存放，那么状态所对应的部分空出来的位置，一定是偶数个的格子，不然不能填充
    f(i,j)的第i列伸出来的用j表示
    f(i-1,k)的第i-1列伸出来的用k表示
    状态要能从f(i,j)转移到f(i-1,k)需要满足：
    1.j和k不能冲突(用位运算判断) j&k==0
    2.j|k的结果里面不存在连续奇数个0
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
const int N = 12, M = 1 << N;
int n, m;
long long f[N][M];

bool st[M];

int main()
{
    while (cin >> n >> m, n || m)
    {
        memset(f, 0, sizeof f);
        for (int i = 0; i < 1 << n; i++)
        {
            //假设是成立的
            st[i] = true;
            //当前这一段连续0的个数
            int cnt = 0;

            for (int j = 0; j < n; j++)
            {
                //当前这一位是1，则表示上一段结束了
                if (i >> j & 1)
                {
                    //判断上一段0的个数是否是奇数个,不是奇数不合法
                    if (cnt & 1)
                        st[i] = false;
                    //这段结束了，重新开始清为0
                    cnt = 0;
                }
                else
                {
                    cnt++;
                }
            }
            //判断最后一段是否是1
            if (cnt & 1)
                st[i] = false;
        }
        //第一列前面没有出来的状态，是1
        f[0][0] = 1;
        //枚举所有的列
        for (int i = 1; i <= m; i++)
        {
            //枚举i列所有的状态
            for (int j = 0; j < 1 << n; j++)
            {
                //枚举第i-1列的状态
                for (int k = 0; k < 1 << n; k++)
                {
                    if ((j & k) == 0 && st[j | k])
                        f[i][j] += f[i - 1][k];
                }
            }
        }
        cout << f[m][0] << endl;
    }
    return 0;
}
```

**[题目：AcWing 91. 最短Hamilton路径]()**  

**题目描述**

给定一张 n 个点的带权无向图，点从 0∼n−1标号，求起点 0 到终点 n−1的最短 Hamilton 路径。

Hamilton 路径的定义是从 0 到 n−1不重不漏地经过每个点恰好一次。

**输入格式**

第一行输入整数 n。

接下来 n 行每行 n 个整数，其中第 i 行第 j 个整数表示点 i 到 j 的距离（记为$ a[i,j]$）。

对于任意的$ x,y,z$，数据保证 $a[x,x]=0，a[x,y]=a[y,x] $并且 $a[x,y]+a[y,z]≥a[x,z]$。

**输出格式**

输出一个整数，表示最短 Hamilton 路径的长度。

**数据范围**

$1≤n≤20$
$0≤a[i,j]≤10^7$

**输入样例：**

```c
5
0 2 4 5 1
2 0 6 5 3
4 6 0 8 3
5 5 8 0 5
1 3 3 5 0
```

**输出样例：**

```c
18
```

**题解：**

``` c
DP
    1.状态表示f(i,j)
    	(1)集合：所有从0到j,中间走过的所有点是i的所有路径，i是二进制数，每一位是表示当前点是否走过了
    	(2)属性：Min
    2.状态计算
    	倒数第二个点分类，倒数第二个点是0，1，2,.....n-1
    	(1)0---->k---->j
    	0--->k  f(i-[j],k)
    	k--->j  a(k,j)    	
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 20, M = 1 << N;

int n;
//存距离
int w[N][N];
int f[M][N];

int main()
{
    cin >> n;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            cin >> w[i][j];
    //初始化
    memset(f, 0x3f, sizeof(f));
    f[1][0] = 0;

    //枚举所有转移的状态
    for (int i = 0; i < 1 << n; i++)
        for (int j = 0; j < n; j++)
            if (i >> j & 1)
                //转移状态
                for (int k = 0; k < n; k++)
                    // i除去j这个点
                    if ((i - (1 << j)) >> k & 1)
                        f[i][j] = min(f[i][j], f[i - (1 << j)][k] + w[k][j]);
    cout << f[(1 << n) - 1][n - 1] << endl;
    return 0;
}
```



### 7.树形DP

**[题目：AcWing 285. 没有上司的舞会]()**

**题目描述**

Ural 大学有 $N$ 名职员，编号为$ 1∼N$。

他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。

每个职员有一个快乐指数，用整数 $H_i$给出，其中 $1≤i≤N$。

现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。

在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。

**输入格式**

第一行一个整数 $N$。

接下来 $N $行，第 $i $行表示 $i $号职员的快乐指数 $H_i$。

接下来 $N−1$ 行，每行输入一对整数 $L,K,$表示 $K$ 是 $L $的直接上司。

**输出格式**

输出最大的快乐指数。

**数据范围**

$1≤N≤6000,$
$−128≤H_i≤127$

**输入样例：**

```c
7
1
1
1
1
1
1
1
1 3
2 3
6 4
7 4
4 5
3 5
```

**输出样例：**

```c
5
```

**题解：**

``` c
DP
    1.状态表示 f(u,0)，f(u,1)
    	(1)集合：所有从以u为根的子树中选择，并且不选u这个点的方案f(u,0)
    			所有从以u为根的子树中选择，并且选则u这个点的方案f(u,1)
    	(2)属性：Max
    
    2.状态计算
    	u
       / \
      s1 s2
    f(u,0)  f(u,1)
    f(s1,0) f(s1,1)
    f(s2,0) f(s2,1)
    	
    f(u,0)+max(f(s1,0),f(s2,0))
    f(u,1)+Σ (f(si,0)
    
    f(u,0)=Σ max(f(si,0),f(si,1))
    f(u,1)=Σ f(si,0)
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 6010;
int n;
int happy[N];
int h[N], e[N], ne[N], idx;
int f[N][2];
bool has_father[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

void dfs(int u)
{
    //选择的话加上happy
    f[u][1] = happy[u];
    //遍历儿子
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        dfs(j);

        f[u][0] += max(f[j][0], f[j][1]);
        f[u][1] += f[j][0];
    }
}

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> happy[i];

    memset(h, -1, sizeof(h));
    for (int i = 0; i < n - 1; i++)
    {
        int a, b;
        cin >> a >> b;
        // a的父节点为b，a标记为true
        has_father[a] = true;
        add(b, a);
    }
    int root = 1;
    while (has_father[root])
        root++;
    dfs(root);
    cout << max(f[root][0], f[root][1]);
    return 0;
}
```



### 8.记忆化搜索

**[题目：AcWing 901. 滑雪]()**

**题目描述**

给定一个 $R $行 $C$列的矩阵，表示一个矩形网格滑雪场。

矩阵中第 $i $行第 $j $列的点表示滑雪场的第 $i$ 行第 $j$ 列区域的高度。

一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。

当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。

下面给出一个矩阵作为例子：

```
 1  2  3  4 5

16 17 18 19 6

15 24 25 20 7

14 23 22 21 8

13 12 11 10 9
```

在给定矩阵中，一条可行的滑行轨迹为 $24−17−2−1$。

在给定矩阵中，最长的滑行轨迹为$25−24−23−…−3−2−1$，沿途共经过 $25$ 个区域。

现在给定你一个二维矩阵表示滑雪场各区域的高度，请你找出在该滑雪场中能够完成的最长滑雪轨迹，并输出其长度(可经过最大区域数)。

**输入格式**

第一行包含两个整数 R 和 C。

接下来 R 行，每行包含 C 个整数，表示完整的二维矩阵。

**输出格式**

输出一个整数，表示可完成的最长滑雪长度。

**数据范围**

$1≤R,C≤300,$
$0≤矩阵中整数≤10000$

**输入样例：**

```c
5 5
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
```

**输出样例：**

```c
25
```

**题解：**

``` c
DP
    1.状态表示f(i,j)
    	(1)集合:所有从(i,j)开始滑的路径
    	(2)属性：Max
    2.状态计算
    	f(i,j)按照不同方向分为四类
    	上 (i,j)--->(i-1,j)+1
    	下 (i,j)--->(i+1,j)+1
    	左 (i,j)--->(i,j-1)+1
    	右 (i,j)--->(i,j+1)+1
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;
const int N = 310;
int n, m;
//表示高度
int h[N][N];
//状态
int f[N][N];

int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0 - 1};

int dp(int x, int y)
{
    //表示状态,状态已经算过则直接返回
    int &v = f[x][y];
    if (v != -1)
        return v;

    // 否则算一下，先初始v最少为1
    v = 1;
    for (int i = 0; i < 4; i++)
    {
        int a = x + dx[i], b = y + dy[i];
        if (a >= 1 && a <= n && b >= 1 && b <= m && h[a][b] < h[x][y])
            v = max(v, dp(a, b) + 1);
    }
    return v;
}

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            cin >> h[i][j];
    //-1表示没有被算过
    memset(f, -1, sizeof(f));

    int res = 0;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            res = max(res, dp(i, j));
    cout << res << endl;
    return 0;
}
```



## 六.贪心

### 1.区间问题

[题目：AcWing 905. 区间选点]()

**题目描述**

给定N个闭区间[ai,bi]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。

输出选择的点的最小数量。

位于区间端点上的点也算作区间内。

**输入格式**

第一行包含整数N，表示区间数。

接下来N行，每行包含两个整数ai,bi，表示一个区间的两个端点。

**输出格式**

输出一个整数，表示所需的点的最小数量。

**数据范围**

$1≤N≤10^5,$

$−10^9≤ai≤bi≤10^9$

**输入样例：**

```c
3
-1 1
2 4
3 5
```

**输出样例：**

```c
2
```

**题解：**

``` c
1.将每个区间按照右端点从小到大排序
2.从前往后依次枚举每一个区间（单峰的时候可以用贪心）
    如果当前区间已经包含点，则直接pass
    否则，选择当前区间的右端点
3.可行解里面的最小值ans<=当前满足的可行解cnt
4.ans>=cnt
5.ans=cnt
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <string>

using namespace std;

const int N = 100010;

int n;
//按照右区间排序
struct Range
{
    int l, r;
    bool operator<(const Range &W) const
    {
        return r < W.r;
    }
} range[N];

int main()
{
    cin >> n;
    for (int i = 0; i < n; i++)
    {
        int l, r;
        cin >> l >> r;
        range[i] = {l, r};
    }
    sort(range, range + n);
    // res表示当前选择点的数量，ed表示上一个点的下标
    int res = 0, ed = -2e9;
    for (int i = 0; i < n; i++)
    {
        if (range[i].l > ed)
        {
            res++;
            //优先选择右端点
            ed = range[i].r;
        }
    }
    cout << res << endl;
    return 0;
}
```



**[题目：AcWing 908. 最大不相交区间数量]()**

**题目描述**

给定N个闭区间[ai,bi]，请你在数轴上选择若干区间，使得选中的区间之间互不相交（包括端点）。

输出可选取区间的最大数量。

**输入格式**

第一行包含整数N，表示区间数。

接下来N行，每行包含两个整数ai,bi，表示一个区间的两个端点。

**输出格式**

输出一个整数，表示可选取区间的最大数量。

**数据范围**

$1≤N≤10^5,$

$−10^9≤ai≤bi≤10^9$

**输入样例：**

```c
3
-1 1
2 4
3 5
```

**输出样例：**

```c
2
```

**题解：**

``` c
1.将每个区间按照右端点从小到大排序
2.从前往后依次枚举每一个区间（单峰的时候可以用贪心）
    当上一个区间的r和当前区间l没有交集的时候才能选择
    
3.所有可行方案的最大值ans>=当前的可行方案cnt
4.ans<=cnt
    反证法：
    假设ans>cnt,可以选择cnt更多的ans答案，因为当前已经选择了cnt个点，如果有大于ans的点，所以需要选择ans个点才能覆盖区间，实际cnt个点就可以覆盖了，则矛盾了
    
5.ans=cnt
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

struct Range
{
    int l, r;
    bool operator<(const Range &W) const
    {
        return r < W.r;
    }
} range[N];
int n;

int main()
{
    cin >> n;
    for (int i = 0; i < n; i++)
    {
        int l, r;
        cin >> l >> r;
        range[i] = {l, r};
    }
    sort(range, range + n);
    // res表示当前选择点的数量，ed表示上一个点的下标
    int res = 0, ed = -2e9;
    for (int i = 0; i < n; i++)
    {
        //当两个区间不相交的时候
        if (ed < range[i].l)
        {
            res++;
            ed = range[i].r;
        }
    }
    cout << res << endl;
    return 0;
}
```



**[题目：AcWing 906. 区间分组]()**

**题目描述**

给定 N 个闭区间$ [a_i,b_i]，$请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。

输出最小组数。

**输入格式**

第一行包含整数 N，表示区间数。

接下来 N 行，每行包含两个整数 $a_i,b_i$，表示一个区间的两个端点。

**输出格式**

输出一个整数，表示最小组数。

**数据范围**

$1≤N≤105$,

$−10^9≤ai≤bi≤10^9$

**输入样例：**

```c
3
-1 1
2 4
3 5
```

**输出样例：**

```c
2
```

**题解：**

``` c
1.将每个区间按照左端点从小到大排序
    
2.从前往后依次枚举每一个区间（单峰的时候可以用贪心）
    判断能否将其放到某个现有的组中l>max_r:
        (1)如果不存在这样的组，当前区间左端点l是否小于某个组的max_r
            则当前区间是和前面的都冲突，则开一个新的组，然后再将其放进去
        (2)如果存在这样的组，l>max_r
            随便选一个将其放进去，并且更新当前组的max_r

3.证明：
	(1)ans<=cnt
    (2)ans>=cnt
    (3)ans==cnt
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;
const int N = 100010;
int n;
struct Range
{
    int l, r;
    bool operator<(const Range &W) const
    {
        return l < W.l;
    }
} range[N];

int main()
{
    cin >> n;
    for (int i = 0; i < n; i++)
    {
        int l, r;
        cin >> l >> r;
        range[i] = {l, r};
    }
    sort(range, range + n);
    //定义小根堆
    priority_queue<int, vector<int>, greater<int>> heap;
    for (int i = 0; i < n; i++)
    {
        auto r = range[i];
        //如果小根堆里面没有或者如果不存在这样的组
        //则当前区间是和前面的都冲突，则开一个新的组，然后再将其放进去
        if (heap.empty() || heap.top() >= r.l)
            heap.push(r.r);
        //如果存在这样的组，l>max_r
        //随便选一个将其放进去，并且更新当前组的max_r
        else
        {
            //放到最小值里面的组
            int t = heap.top();
            heap.pop();
            heap.push(r.r);
        }
    }
    cout << heap.size() << endl;
    return 0;
}
```



**[题目：AcWing 907. 区间覆盖]()**

**题目描述**

给定 N 个闭区间$ [a_i,b_i]$ 以及一个线段区间 $[s,t]$，请你选择尽量少的区间，将指定线段区间完全覆盖。

输出最少区间数，如果无法完全覆盖则输出 −1。

**输入格式**

第一行包含两个整数 $s $和 $t$，表示给定线段区间的两个端点。

第二行包含整数$ N$，表示给定区间数。

接下来$ N$ 行，每行包含两个整数 $a_i,b_i$，表示一个区间的两个端点。

**输出格式**

输出一个整数，表示所需最少区间数。

如果无解，则输出 −1。

**数据范围**

$1≤N≤10^5$,
$−10^9≤a_i≤b_i≤10^9$,
$−10^9≤s≤t≤10^9$

**输入样例：**

```c
1 5
3
-1 3
2 4
3 5
```

**输出样例：**

```c
2
```

**题解：**

``` c
	1-----------5
   start		end
1.将所有的区间按照左端点从小到大排序
2.从前往后依次枚举每个区间，在所有能覆盖start的区间当中，选择右端点最大的区间
  然后将start更新成右端点的最大值
3.证明：ans最优解，cnt可行解
	(1)ans<=cnt
    (2)ans>=cnt
        (√)将任何一个最优解通过调整法得到
        (x)反证法：
        假设存在一个方案  ans<cnt
        将ans和cnt的左端点排序，从前往后找到ans和cnt中第一个不相同的区间，可以将ans的区间变为cnt的区间的;后面同样的道理，可以将ans后面的区间都替换为cnt的区间
    (3)ans==cnt
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;
int n;

struct Range
{
    int l, r;
    bool operator<(const Range &W) const
    {
        return l < W.l;
    }
} range[N];
int main()
{
    //目标区间
    int st, ed;
    cin >> st >> ed;
    cin >> n;
    for (int i = 0; i < n; i++)
    {
        int l, r;
        cin >> l >> r;
        range[i] = {l, r};
    }
    int res = 0;
    sort(range, range + n);
    bool success = false; // 找出了方案
    for (int i = 0; i < n; i++)
    {
        // r表示当前最大值,选择满足左端点，右端点尽量大
        int j = i, r = -2e9;
        //遍历所有左端点在st左边，r最大的区间
        while (j < n && range[j].l <= st)
        {
            r = max(r, range[j].r);
            j++;
        }
        if (r < st)
        {
            res = -1;
            break;
        }
        res++;
        if (r >= ed)
        {
            success = true;
            break;
        }
        st = r;
        i = j - 1;
    }

    if (!success)
        res = -1;
    cout << res << endl;
    return 0;
}
```

### 2.Huffman数

**[题目：AcWing 148. 合并果子]()**

**题目描述**

在一个果园里，达达已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。

达达决定把所有的果子合成一堆。

每一次合并，达达可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。

可以看出，所有的果子经过 $n−1$ 次合并之后，就只剩下一堆了。

达达在合并果子时总共消耗的体力等于每次合并所耗体力之和。

因为还要花大力气把这些果子搬回家，所以达达在合并果子时要尽可能地节省体力。

假定每个果子重量都为 1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使达达耗费的体力最少，并输出这个最小的体力耗费值。

例如有 3 种果子，数目依次为 $1，2，9$。

可以先将 $1、2$ 堆合并，新堆数目为 3，耗费体力为 3。

接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12，耗费体力为 12。

所以达达总共耗费体力=3+12=15。

可以证明 15 为最小的体力耗费值。

**输入格式**

输入包括两行，第一行是一个整数 n，表示果子的种类数。

第二行包含 n 个整数，用空格分隔，第 i 个整数 $a_i$ 是第 i 种果子的数目。

**输出格式**

输出包括一行，这一行只包含一个整数，也就是最小的体力耗费值。

输入数据保证这个值小于$2^31$。

**数据范围**

$1≤n≤10000$,
$1≤a_i≤20000$

**输入样例：**

```c
3 
1 2 9 
```

**输出样例：**

```c
15
```

**题解：**

``` c
 1.所有的树里面，权值最小的两个点，深度一定最深，并且可以互为兄弟
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

int main()
{
    int n;
    cin >> n;
    priority_queue<int, vector<int>, greater<int>> heap;
    while (n--)
    {
        int x;
        cin >> x;
        heap.push(x);
    }
    int res = 0;
    while (heap.size() > 1)
    {
        int a = heap.top();
        heap.pop();
        int b = heap.top();
        heap.pop();
        res += a + b;
        heap.push(a + b);
    }
    cout << res << endl;
    return 0;
}
```



### 3. 排列不等式

**[题目：AcWing 913. 排队打水]()**

**题目描述**

有 n 个人排队到 1 个水龙头处打水，第 i 个人装满水桶所需的时间是 $t_i$，请问如何安排他们的打水顺序才能使所有人的等待时间之和最小？

**输入格式**

第一行包含整数 n。

第二行包含 n 个整数，其中第 i 个整数表示第 i 个人装满水桶所花费的时间 $t_i$。

**输出格式**

输出一个整数，表示最小的等待时间之和。

**数据范围**

$1≤n≤10^5,$
$1≤t_i≤10^4$

**输入样例：**

```c
7
3 6 1 4 2 5 7
```

**输出样例：**

```c
56
```

**题解：**

``` c
总时间=t1*(n-1)+t2*(n-2)+t3*(n-3)......
按照从小到大的顺序排队，总时间最小
证明：
如果t[i]>t[i+1]
	交换两个数的位置
    交换前：t[i]*(n-i)+t[i+1]*(n-i-1)
    交换后：t[i+1]*(n-i)+t[i]*(n-i-1)
    交换前-交换后=t[i]-t[i+1]>0
    
```

**代码：**

```c
#include <iostream>
#include <algorithm>

typedef long long ll;
using namespace std;
const int N = 100010;

int n;
int t[N];

int main()
{
    cin >> n;
    for (int i = 0; i < n; i++)
        cin >> t[i];

    sort(t, t + n);
    ll res = 0;
    for (int i = 0; i < n; i++)
        res += t[i] * (n - i - 1);
    cout << res << endl;
    return 0;
}
```



### 4. 绝对值不等式

**[题目：AcWing 104. 货仓选址]()**

**题目描述**

在一条数轴上有 N 家商店，它们的坐标分别为 $A_1∼A_N$。

现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。

为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。

**输入格式**

第一行输入整数 N。

第二行 N 个整数 $A_1∼A_N$。

**输出格式**

输出一个整数，表示距离之和的最小值。

**数据范围**

$1≤N≤100000$,
$0≤A_i≤40000$

**输入样例：**

```c
4
6 2 9 1
```

**输出样例：**

```c
12
```

**题解：**

``` c
把仓库位置记为x
    f(x)=|x1-x|+|x2-x|+|x3-x|+.....+|xn-x|
    x为中位数
    当N为奇数的时候是中间，为偶数的时候两个数任意一个都可以
    f(x)=(|x1-x|+|xn-x|)+(|x2-x|+|xn-1-x|)+....
    	>=(xn-x1)+(xn-1-x2)+....
```

**代码：**

```c
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 100010;

int n;
int a[N];

int main()
{
    cin >> n;
    for (int i = 0; i < n; i++)
        cin >> a[i];
    sort(a, a + n);
    int res = 0;

    for (int i = 0; i < n; i++)
        res += abs(a[i] - a[n / 2]);
    cout << res << endl;
    return 0;
}
```



### 5. 推公式

**[题目：AcWing 125. 耍杂技的牛]()**

**题目描述**

农民约翰的 N 头奶牛（编号为 $1..N$）计划逃跑并加入马戏团，为此它们决定练习表演杂技。

奶牛们不是非常有创意，只提出了一个杂技表演：

叠罗汉，表演时，奶牛们站在彼此的身上，形成一个高高的垂直堆叠。

奶牛们正在试图找到自己在这个堆叠中应该所处的位置顺序。

这 N 头奶牛中的每一头都有着自己的重量 $W_i$ 以及自己的强壮程度 $S_i$。

一头牛支撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。

您的任务是确定奶牛的排序，使得所有奶牛的风险值中的最大值尽可能的小。

**输入格式**

第一行输入整数 N，表示奶牛数量。

接下来 N 行，每行输入两个整数，表示牛的重量和强壮程度，第 i 行表示第 i 头牛的重量 $W_i$ 以及它的强壮程度 $S_i$。

**出格式**

输出一个整数，表示最大风险值的最小可能值。

**数据范围**

$1≤N≤50000$,
$1≤W_i≤10,000,$
$1≤S_i≤1,000,000,000$

**输入样例：**

```c
3
10 3
2 5
3 3
```

**输出样例：**

```c
2
```

**题解：**

``` c
按照wi+si从小到大的顺序排序，最大的危险系数一定是最小的
证明：
    1.贪心得到的答案一定是>=最优解
    2.贪心得到的答案一定是<=最优解
    	wi+si>w(i+1)+s(i+1)
    (1)交换第i和i+1的牛:
    			第i个位置的牛     	第i+1个位置的牛
  	交换前	 w1+w2+...+w(i-1)-si   w1+...+wi-s(i+1)
    交换后  w1+...w(i-1)-s(i+1)   w1+...+w(i-1)+w(i+1)-si
    (2)去掉公共部分的w1+w2+...+w(i-1)
                第i个位置的牛     	第i+1个位置的牛
  	交换前	 		-si   				wi-s(i+1)
    交换后  		-s(i+1)   			w(i+1)-si
    (3)同时加+si+s(i+1)
                 第i个位置的牛     	第i+1个位置的牛
  	交换前	 	 -si+si+s(i+1)   		wi-s(i+1)+si+s(i+1)
    交换后  	-s(i+1)+si+s(i+1)   	w(i+1)-si+si+s(i+1)
    (4)得到结果
                 第i个位置的牛     	第i+1个位置的牛
  	交换前	 	 	s(i+1)   			wi+si
    交换后  		 si  			 w(i+1)+s(i+1)
                   
    所以只要存在逆序wi+si>w(i+1)+s(i+1)则交换之后不会变大，小于等于最优解
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
typedef pair<int, int> PII;

const int N = 50010;

int n;
PII cow[N];

int main()
{
    cin >> n;
    for (int i = 0; i < n; i++)
    {
        int w, s;
        cin >> w >> s;
        cow[i] = {w + s, w};
    }
    sort(cow, cow + n);
    // sum表示每头牛上面的w总和
    int res = -2e9, sum = 0;
    for (int i = 0; i < n; i++)
    {
        int w = cow[i].second, s = cow[i].first - w;
        res = max(res, sum - s);
        sum += w;
    }
    cout << res << endl;
    return 0;
}
```



## 7.由数据范围反推算法复杂度以及算法内容

一般ACM或者笔试题的时间限制是1秒或2秒。
在这种情况下，$C++$代码中的操作次数控制在 $10^7$ ~$10^8$为最佳。

下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：

1. $n≤30$, 指数级别,$ dfs+$剪枝，状态压缩$dp$
2. $n≤100 => O(n^3)$，$floyd$，$dp$，高斯消元
3. $n≤1000 => O(n^2)，O(n^2logn)$，$dp$，二分，朴素版$Dijkstra$、朴素版$Prim$、$Bellman-Ford$
4. $n≤10000 => O(n∗\sqrt{n})$，块状链表、分块、莫队
5. $n≤100000 => O(nlogn)$ => 各种$sort$，线段树、树状数组、$set/map$、$heap$、拓扑排序、$dijkstra+heap$、 $prim+heap$、$Kruskal$、$spfa$、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树
6. $n≤1000000 => O(n)$, 以及常数较小的$ O(nlogn)$ 算法 => 单调队列、$hash$、双指针扫描、并查集，$kmp$、$AC$自动机，常数比较小的$ O(nlogn)$的做法：$sort$、树状数组、$heap$、$dijkstra$、$spfa$
7. $n≤10000000 => O(n)$，双指针扫描、$kmp$、$AC$自动机、线性筛素数
8. $n≤10^9 => O(\sqrt{n})$，判断质数
9. $n≤10^{18} => O(logn)$，最大公约数，快速幂，数位$DP$
10. $n≤10^{1000} => O((logn)^2)$，高精度加减乘除
11. $n≤10^{100000} => O(logn×loglogn)$，k表示位数 ，高精度加减、$FFT/NTT$

空间分析

1 Byte = 8 bit

1KB =  1024 Byte

1MB = 1024 * 1024 Byte

1GB = 1024 * 1024 * 1024 Byte

int 4 Byte

char 1 Byte

double,long long 8 Byte

 64MB=2^26 Byte

2^26 /4=2^24,16000000







