## 一、DP

### 1.数字三角形模型（路径DP）

#### 1.1  摘花生

**[题目：AcWing1015. 摘花生](https://www.acwing.com/activity/content/problem/content/1256/)**

**题目描述**

Hello Kitty想摘点花生送给她喜欢的米老鼠。

她来到一片有网格状道路的矩形花生地(如下图)，从西北角进去，东南角出来。

地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。

Hello Kitty只能向东或向南走，不能向西或向北走。

问Hello Kitty最多能够摘到多少颗花生。

![](https://cdn.acwing.com/media/article/image/2019/09/12/19_a8509f26d5-1.gif)

**输入格式**

第一行是一个整数T，代表一共有多少组数据。

接下来是T组数据。

每组数据的第一行是两个整数，分别代表花生苗的行数R和列数 C。

每组数据的接下来R行数据，从北向南依次描述每行花生苗的情况。每行数据有C个整数，按从西向东的顺序描述了该行每株花生苗上的花生数目M。

**输出格式**

对每组输入数据，输出一行，内容为Hello Kitty能摘到得最多的花生颗数。

**数据范围**

$1≤T≤100$,
$1≤R,C≤100$,
$0≤M≤1000$

**输入样例：**

```c
2
2 2
1 1
3 4
2 3
2 3 4
1 6 5
```

**输出样例：**

```c
8
16
```

**题解：**

``` c
DP  1.状态(一个集合)表示
		二维：f(i,j)
		1.1 集合：所有选法
				条件：（1）所有从(1,1)走到(i,j)的所有路线
					 （2）所有路线的最大值max
    
		1.2 属性：max值
    
	2.状态计算:一步一步的将状态计算出来
		(1)总结：
        	1)集合的划分原则：
        		a.重复(不一定需要必须满足)
        		b.不遗漏(必须满足)
        	2)很重要的划分依据"最后",大部分题目依据最后一步来划分
        
		(2)f(i,j)集合划分为若干个更小的子集，每个子集都能求出答案
            1)最后一步是从上面下来的
        		(1,1)-->(i-1,j)-->(i,j)
        		f[i-1][j]+w[i][j]
            2)最后一步是从左边下来的
        		(1,1)-->(i,j-1)-->(i,j)
        		f[i][j-1]+w[i][j]
		  
		最终f[i][j]=max(f[i-1][j]+w[i][j],f[i][j-1]+w[i][j])
    3.优化
    4.注意       
```

**代码：**

```c
#include <bits/stdc++.h>
using namespace std;
const int N = 110;
int w[N][N];
int f[N][N];

int main()
{
  int T;
  scanf("%d",&T);
  while(T--){
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
      for(int j=1;j<=m;j++){
        scanf("%d",&w[i][j]);
      }
    }
    for(int i=1;i<=n;i++){
      for(int j=1;j<=m;j++){
        f[i][j]=max(f[i-1][j],f[i][j-1])+w[i][j];
      }
    }
    printf("%d\n",f[n][m]);
  }
  return 0;
}
```

#### 1.2 最低通行费

**[题目：AcWing1018. 最低通行费](https://www.acwing.com/problem/content/1020/)**

**题目描述**

一个商人穿过一个 N×N 的正方形的网格，去参加一个非常重要的商务活动。

他要从网格的左上角进，右下角出。

每穿越中间 1个小方格，都要花费 1个单位时间。

商人必须在 (2N−1)个单位时间穿越出去。

而在经过中间的每个小方格时，都需要缴纳一定的费用。

这个商人期望在规定时间内用最少费用穿越出去。

请问至少需要多少费用？

注意：不能对角穿越各个小方格（即，只能向上下左右四个方向移动且不能离开网格）。

**输入格式**

第一行是一个整数，表示正方形的宽度 N。

后面 N 行，每行 N 个不大于 100 的正整数，为网格上每个小方格的费用。

**输出格式**

输出一个整数，表示至少需要的费用。

**数据范围**

1≤N≤100

**输入样例：**

```c
5
1  4  6  8  10
2  5  7  15 17
6  8  9  18 20
10 11 12 19 21
20 23 25 29 33
```

**输出样例：**

```c
109
```

**样例解释:**

样例中，最小值为 109=1+2+5+7+9+12+19+21+33。

**题解：**

``` c
DP  1.状态(一个集合)表示
		二维：f(i,j)
		1.1 集合：所有选法
				条件：（1）所有从(1,1)走到(i,j)的所有路线
    				 （2）2n-1步等价于不能走回头路
					 （3）所有路线的最小值Min
    
		1.2 属性：max值
    
	2.状态计算:一步一步的将状态计算出来
		(1)总结：
        	1)集合的划分原则：
        		a.重复(不一定需要必须满足)
        		b.不遗漏(必须满足)
        	2)很重要的划分依据"最后",大部分题目依据最后一步来划分
        
		(2)f(i,j)集合划分为若干个更小的子集，每个子集都能求出答案
            1)最后一步是从上面下来的
        		(1,1)-->(i-1,j)-->(i,j)
        		f[i-1][j]+w[i][j]
            2)最后一步是从左边下来的
        		(1,1)-->(i,j-1)-->(i,j)
        		f[i][j-1]+w[i][j]
		  
		最终f[i][j]=min(f[i][j],f[i-1][j]+w[i][j],f[i][j-1]+w[i][j])
    3.优化
    4.注意       
```

**代码：求最小值需要考虑边界问题**

```c
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 110,INF = 1e9;

int n;
int w[N][N];
int f[N][N];

int main() {
  scanf("%d",&n);
  for(int i = 1; i <= n; i++) {
    for(int j = 1; j <= n; j++){
      scanf("%d",&w[i][j]);
    }
  }

  for(int i = 1; i <= n; i++) {
    for(int j = 1; j <= n; j++) {
      //特判下第一行和第一列
      if(i==1 && j==1) f[i][j] = w[i][j];  //特判左上角
      else {
        f[i][j] = INF;
        //只有不在第一行的时候，才可以从上面过来
        if(i>1) f[i][j] = min(f[i][j],f[i-1][j] + w[i][j]); 
        //只有不在第一列的时候，才可以从左边过来
        if(j>1) f[i][j] = min(f[i][j],f[i][j-1] + w[i][j]);
      }
    }
  }
  printf("%d\n",f[n][n]);
  return 0;
}
```



#### 1.3  方格取数

**[题目：AcWing.1027方格取数](https://www.acwing.com/problem/content/1029/)**

**题目描述**

设有 N×N 的方格图，我们在其中的某些方格中填入正整数，而其它的方格中则放入数字0。如下图所示：

![](https://cdn.acwing.com/media/article/image/2019/09/12/19_764ece6ed5-2.gif)

某人从图中的左上角 A 出发，可以向下行走，也可以向右行走，直到到达右下角的 B 点。

在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。

此人从 A 点到 B 点共走了两次，试找出两条这样的路径，使得取得的数字和为最大。

**输入格式**

第一行为一个整数N，表示 N×N 的方格图。

接下来的每行有三个整数，第一个为行号数，第二个为列号数，第三个为在该行、该列上所放的数。

行和列编号从 1 开始。

一行“0 0 0”表示结束。

**输出格式**

输出一个整数，表示两条路径上取得的最大的和。

**数据范围**

$N≤10$

**输入样例：**

```c
8
2 3 13
2 6 6
3 5 7
4 4 14
5 2 21
5 6 4
6 3 15
7 2 14
0 0 0
```

**输出样例：**

```c
67
```

**题解：**

``` c
如何处理同一个格子不能被重复选择？
    只有在ii+j1 == i2+j2时候，两条路径才可能重合
    
DP  1.状态(一个集合)表示
		四维：f(i1,j1,i2,j2)
    		 只有在ii+j1 == i2+j2时候，两条路径才可能重合
    		 f(k,i1,i2)表示所有从(1,1),(1,1)分别走到(i1,k-i1),(i2,k-i2)的路径的最大值
    		 k = i1+j1 = i2+j2
    
		1.1 集合：所有选法
				条件：（1）从(1,1),(1,1)分别走到(i1,k-i1),(i2,k-i2)的路径的最大值
					 （2）路线的最大值max
    
		1.2 属性：max值
    
	2.状态计算:一步一步的将状态计算出来
		(1)总结：
        	1)集合的划分原则：
        		a.重复(不一定需要必须满足)
        		b.不遗漏(必须满足)
        	2)很重要的划分依据"最后",大部分题目依据最后一步来划分
        
		(2)f(k,i1,i2)集合划分为若干个更小的子集，每个子集都能求出答案
            1)第一条路线向下走，第二条路线向下走
        		第一条路线:(1,1)->(i1-1,j1)->(i1,j1)
        		第二条路线:(1,1)->(i2-1,j2)->(i2,j2)
                ①前部部分的状态;f(k-1,i1-1,i2-1)
                ②后面部分判断(i1,j1)和(i2,j2)是否重合
                    重合则加 w(i1,j1)
                    不重合加 w(i1,j1)+w(i2,j2)
 
            2)第一条路线向下走，第二条路线向右走
        
        	3)第一条路线向右走，第二条路线向下走
        
        	4)第一条路线向右走，第二条路线向右走
        		
		最终4种情况取最大值
    3.优化
    4.注意       
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 15;

int n;
int w[N][N];
int f[N*2][N][N];

int main() {
  scanf("%d",&n);

  int a,b,c;
  while(cin>>a>>b>>c, a || b || c) w[a][b] = c;

  for(int k  =2; k <=n+n; k++) {
    for(int i1 = 1; i1 <= n; i1++){
      for(int i2 = 1; i2 <= n; i2++) {
        int j1 = k - i1, j2 = k - i2;
        if(j1 >=1 && j1 <=n && j2>=1 && j2<=n) {
          int t = w[i1][j1];
          if(i1!=i2 && j1!=j2) t+=w[i2][j2];
          // f[k][i1][i2] = max(f[k][i1][i2],f[k-1][i1-1][i2-1]+t);
          int &x = f[k][i1][i2];
          x = max(x,f[k-1][i1-1][i2-1] + t);
          x = max(x,f[k-1][i1-1][i2] + t);
          x = max(x,f[k-1][i1][i2-1] + t);
          x = max(x,f[k-1][i1][i2] + t);
        }
      }
    }
  }
  printf("%d",f[n*2][n][n]);
  return 0;
}
```



#### 1.4 传纸条(todo)

[Acwing275. 传纸条](https://www.acwing.com/problem/content/277/)

**题目描述**

小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。

一次素质拓展活动中，班上同学安排坐成一个 m 行 n 列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。

幸运的是，他们可以通过传纸条来进行交流。

纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标 (1,1)，小轩坐在矩阵的右下角，坐标 (m,n)。

从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。 

在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。

班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙，反之亦然。 

还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用 00 表示），可以用一个 0∼100 的自然数来表示，数越大表示越好心。

小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度之和最大。

现在，请你帮助小渊和小轩找到这样的两条路径。

**输入格式**

第一行有 2 个用空格隔开的整数 m 和 n，表示学生矩阵有 m 行 n 列。

接下来的 m 行是一个 m×n 的矩阵，矩阵中第 i 行 j 列的整数表示坐在第 i 行 j 列的学生的好心程度，每行的 n 个整数之间用空格隔开。

**输出格式**

输出一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。

**数据范围**

$1≤n,m≤50$

**输入样例：**

```c
3 3
0 3 9
2 8 5
5 7 0
```

**输出样例：**

```c
34
```

**题解：**

``` c

```

**代码：**

```c
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 55;

int n, m;
int g[N][N];
int f[N * 2][N][N];

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            scanf("%d", &g[i][j]);

    for (int k = 2; k <= n + m; k ++ )
        for (int i = max(1, k - m); i <= n && i < k; i ++ )
            for (int j = max(1, k - m); j <= n && j < k; j ++ )
                for (int a = 0; a <= 1; a ++ )
                    for (int b = 0; b <= 1; b ++ )
                    {
                        int t = g[i][k - i];
                        if (i != j || k == 2 || k == n + m) // 除了起点和终点之外，其余每个格子只能走一次
                        {
                            t += g[j][k - j];
                            f[k][i][j] = max(f[k][i][j], f[k - 1][i - a][j - b] + t);
                        }
                    }

    printf("%d\n", f[n + m][n][n]);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/120225/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



### 2、最长上升子序列模型(LIS)（序列DP）

**[题目：AcWing 1017. 怪盗基德的滑翔翼  ](https://www.acwing.com/activity/content/problem/content/1259/)**

#### 2.1 怪盗基德的滑翔翼

**题目描述**

怪盗基德是一个充满传奇色彩的怪盗，专门以珠宝为目标的超级盗窃犯。

而他最为突出的地方，就是他每次都能逃脱中村警部的重重围堵，而这也很大程度上是多亏了他随身携带的便于操作的滑翔翼。

有一天，怪盗基德像往常一样偷走了一颗珍贵的钻石，不料却被柯南小朋友识破了伪装，而他的滑翔翼的动力装置也被柯南踢出的足球破坏了。

不得已，怪盗基德只能操作受损的滑翔翼逃脱。

假设城市中一共有N幢建筑排成一条线，每幢建筑的高度各不相同。

初始时，怪盗基德可以在任何一幢建筑的顶端。

他可以选择一个方向逃跑，但是不能中途改变方向（因为中森警部会在后面追击）。

因为滑翔翼动力装置受损，他只能往下滑行（即：只能从较高的建筑滑翔到较低的建筑）。

他希望尽可能多地经过不同建筑的顶部，这样可以减缓下降时的冲击力，减少受伤的可能性。

请问，他最多可以经过多少幢不同建筑的顶部(包含初始时的建筑)？

**输入格式**

输入数据第一行是一个整数K，代表有K组测试数据。

每组测试数据包含两行：第一行是一个整数N，代表有N幢建筑。第二行包含N个不同的整数，每一个对应一幢建筑的高度h，按照建筑的排列顺序给出。

**输出格式**

对于每一组测试数据，输出一行，包含一个整数，代表怪盗基德最多可以经过的建筑数量。

**数据范围**

$1≤K≤100,$
$1≤N≤100$,
$0<h<10000$

**输入样例：**

```c
3
8
300 207 155 299 298 170 158 65
8
65 158 170 298 299 155 207 300
10
2 1 3 4 5 6 7 8 9 10
```

**输出样例：**

```c
6
6
9
```

**题解：**

``` c
当确定方向和起点之后，最长的距离是多少？
    起点:a[i]
    最长距离：以a[i]记为的最长上升子序列
    步骤：选择向左的时候，从左到a[i]求LIS；选择向右的时候，从结尾到a[i]求LIS
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;

int n;
int a[N],f[N];

int main() {
  int T;
  scanf("%d",&T);
  while(T--) {
    scanf("%d",&n);
    for(int i = 1; i <= n; i++) scanf("%d",&a[i]);

    //先正向求解LIS问题
    int res = 0;
    for(int i = 1; i <= n; i++) {
      f[i] = 1;
      for(int j = 1; j< i; j++) {
        if(a[i] > a[j]){
          f[i] = max(f[i],f[j]+1);
        }
      }
      res = max(res,f[i]);
    }

    // 反向求解LIS问题
    for(int i = n; i ; i--) {
      f[i] = 1;
      for(int j = n; j > i; j--) {
        if(a[i] > a[j]) {
          f[i] = max(f[i],f[j] + 1);
        }
      }
      res = max(res, f[i]);
    }

    printf("%d\n",res);
  }
  return 0;
}
```



**[题目：AcWing 1014. 登山  ](https://www.acwing.com/problem/content/1016/)**

#### 2.2 登山

**题目描述**

五一到了，ACM队组织大家去登山观光，队员们发现山上一共有N个景点，并且决定按照顺序来浏览这些景点，即每次所浏览景点的编号都要大于前一个浏览景点的编号。

同时队员们还有另一个登山习惯，就是不连续浏览海拔相同的两个景点，并且一旦开始下山，就不再向上走了。

队员们希望在满足上面条件的同时，尽可能多的浏览景点，你能帮他们找出最多可能浏览的景点数么？

**输入格式**

第一行包含整数N，表示景点数量。

第二行包含N个整数，表示每个景点的海拔。

**输出格式**

输出一个整数，表示最多能浏览的景点数。

**数据范围**

$2≤N≤1000$

**输入样例：**

```c
8
186 186 150 200 160 130 197 220
```

**输出样例：**

```c
4
```

**题解：**

``` c
条件1：按照编号递增的顺序来浏览，也就是必须是子序列
条件2：相邻两个景点不能相同
条件3：一旦开始下降，就不能上升了
形状：先严格单调上升，后单调下降的路线(存在一个峰值a[k])
目标：求最多能浏览多少景点
目标：所有形状是上面这种子序列长度的最大值
    
    
集合划分：以 a[1],a[2],a[3],a[4]..a[k]..a[n-1],a[n] 这些点为峰值
    左边以a[k]为结尾的最长上升子序列，记为f[i]，右边以a[k]为开始到结尾的最长下降子序列,记为g[i]
    最后的答案f[k]+g[k]-1（中间的a[k]算了两次）
    
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 1010;
int n;
int a[N],f[N],g[N];

int main() {
  scanf("%d",&n);
  for(int i = 1; i <= n; i++) scanf("%d",&a[i]);

  for(int i = 1; i <= n; i++) {
    f[i] = 1;
    for(int j = 1; j < i; j++){
      if(a[j] < a[i]) {
        f[i] = max(f[i],f[j]+1);
      }
    }
  } 

  for(int i = n; i ; i--) {
    g[i] = 1;
    for(int j = n; j > i; j--) {
      if(a[j] < a[i]) {
        g[i] = max(g[i],g[j]+1);
      }
    }
  }

  int res = 0;
  for(int i = 1; i <= n; i++) res = max(res, f[i]+g[i]-1);
  printf("%d",res);
  return 0;
}
```



**[题目：AcWing 482. 合唱队形  ](https://www.acwing.com/problem/content/484/)**

#### 2.3 合唱队形

**题目描述**

$N$ 位同学站成一排，音乐老师要请其中的$(N−K)$位同学出列，使得剩下的 $K$位同学排成合唱队形。     

合唱队形是指这样的一种队形：设 $K$ 位同学从左到右依次编号为 $1，2…，K$，他们的身高分别为$T_1，T_2，…，T_K$，  则他们的身高满足 $T_1<…< T_i >T_{i+1}>…> T_K (1≤i≤K)$。     

你的任务是，已知所有 $N$ 位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。

**输入格式**

输入的第一行是一个整数 $N$，表示同学的总数。

第二行有 $N$ 个整数，用空格分隔，第 i 个整数 $T_i$是第 $i$ 位同学的身高(厘米)。

**输出格式**

输出包括一行，这一行只包含一个整数，就是最少需要几位同学出列。

**数据范围**

$2≤N≤100$,
$130≤Ti≤230$

**输入样例：**

```c
8
186 186 150 200 160 130 197 220
```

**输出样例：**

```c
4
```

**题解：**

``` c
同登山
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 110;
int n;
int a[N],f[N],g[N];

int main() {
  scanf("%d",&n);
  for(int i = 1; i <= n; i++) scanf("%d",&a[i]);

  for(int i = 1; i <= n; i++) {
    f[i] = 1;
    for(int j = 1; j < i; j++){
      if(a[j] < a[i]) {
        f[i] = max(f[i],f[j]+1);
      }
    }
  } 

  for(int i = n; i ; i--) {
    g[i] = 1;
    for(int j = n; j > i; j--) {
      if(a[j] < a[i]) {
        g[i] = max(g[i],g[j]+1);
      }
    }
  }

  int res = 0;
  for(int i = 1; i <= n; i++) res = max(res, f[i]+g[i]-1);
  printf("%d",n-res);
  return 0;
}
```



**[题目：AcWing 1012. 友好城市  ](https://www.acwing.com/problem/content/1014/)**

#### 2.4 友好城市（问题转化？）

**题目描述**

Palmia国有一条横贯东西的大河，河有笔直的南北两岸，岸上各有位置各不相同的N个城市。

北岸的每个城市有且仅有一个友好城市在南岸，而且不同城市的友好城市不相同。

每对友好城市都向政府申请在河上开辟一条直线航道连接两个城市，但是由于河上雾太大，政府决定避免任意两条航道交叉，以避免事故。

编程帮助政府做出一些批准和拒绝申请的决定，使得在保证任意两条航线不相交的情况下，被批准的申请尽量多。

**输入格式**

第1行，一个整数N，表示城市数。

第2行到第n+1行，每行两个整数，中间用1个空格隔开，分别表示南岸和北岸的一对友好城市的坐标。

**输出格式**

仅一行，输出一个整数，表示政府所能批准的最多申请数。

**数据范围**

$1≤N≤5000$,
$0≤x_i≤10000$

**输入样例：**

```c
7
22 4
2 6
10 3
15 12
9 8
17 17
4 2
```

**输出样例：**

```c
4
```

**题解：**

``` c
条件1：每个城市上只能建立一座桥
条件2：所有的桥与桥之间不能相交
目标：最多可以建多少桥
    
集合1：所有合法的建桥方式
集合2：上升子序列
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;
typedef pair<int,int> PII;
const int N = 5010;

int n;
PII q[N];
int f[N];

int main() {
  scanf("%d",&n);
  for(int i = 0; i < n; i++) scanf("%d%d",&q[i].first,&q[i].second);
  sort(q,q+n);

  int res = 0;
  for(int i = 0; i < n; i++) {
    f[i] = 1;
    for(int j = 0; j < i; j++) {
      if(q[i].second > q[j].second) {
        f[i] = max(f[i], f[j]+1);
      }
    }
    res = max(res,f[i]);
  }
  printf("%d\n",res);
  return 0;
}
```



**[题目：AcWing 1016. 最大上升子序列和   ](https://www.acwing.com/problem/content/1018/)**

#### 2.5 最大上升子序列和 

**题目描述**

一个数的序列 $b_i$，当 $b_1<b_2<…<b_S$ 的时候，我们称这个序列是上升的。

对于给定的一个序列$(a_1,a_2,…,a_N)$，我们可以得到一些上升的子序列$(a_{i1},a_{i2},…,a_{iK})$，这里$1≤i_1<i_2<…<i_K≤N$。

比如，对于序列$(1,7,3,5,9,4,8)$，有它的一些上升子序列，如$(1,7),(3,4,8)$等等。

这些子序列中和最大为$18$，为子序列$(1,3,5,9)$的和。

你的任务，就是对于给定的序列，求出最大上升子序列和。

注意，最长的上升子序列的和不一定是最大的，比如序列$(100,1,2,3)$的最大上升子序列和为$100$，而最长上升子序列为$(1,2,3)$。

**输入格式**

输入的第一行是序列的长度$N$。

第二行给出序列中的$N$个整数，这些整数的取值范围都在$0$到$10000$(可能重复)。

**输出格式**

输出一个整数，表示最大上升子序列和。

**数据范围**

$1≤N≤1000$

**输入样例：**

```c
7
1 7 3 5 9 4 8
```

**输出样例：**

```c
18
```

**题解：**

``` c
DP
    (1)状态表示f[i]
    1)集合表示：所有以a[i]结尾的上升子序列
    2)属性:和的最大值
    
    (2)状态计算
        集合划分：
        最后一个以 ：空,a[1],a[2].....a[i-1] 结尾
        倒数第2个数是a[k],最后一个是a[i]，则求最大值 max(所有以k结尾的最长上升子序列，也就是f[k])+a[i]
        只要a[k] < a[i]就满足
        
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int n;
int a[N],f[N];

int main() {
  scanf("%d",&n);
  for(int i = 1; i <= n; i++) scanf("%d",&a[i]);

  int res = 0;
  for(int i = 1; i <= n; i++) {
    f[i] = a[i];
    for(int j = 1; j < i; j++) {
      if(a[j] < a[i]) {
        f[i] = max(f[i],f[j]+a[i]);
      }
    }
    res = max(res,f[i]);
  }
  printf("%d",res);
  return 0;
}
```



**[题目：AcWing 1010. 拦截导弹  ](https://www.acwing.com/problem/content/1012/)**

#### 2.6 拦截导弹（推荐）

**题目描述**

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。

但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。

某天，雷达捕捉到敌国的导弹来袭。

由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

输入导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数，导弹数不超过1000），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。

**输入格式**

共一行，输入导弹依次飞来的高度。

**输出格式**

第一行包含一个整数，表示最多能拦截的导弹数。

第二行包含一个整数，表示要拦截所有导弹最少要配备的系统数。

**数据范围**

雷达给出的高度数据是不大于 30000 的正整数，导弹数不超过 1000 。

**输入样例：**

```c
389 207 155 300 299 170 158 65
```

**输出样例：**

```c
6
2
```

**题解：**

``` c
389 207 155 300 299 170 158 65
第一问：389 300 299 170 158 65
第二问: 
	   207有两种选择
           选择1：接在现有的某个子序列之后
           选择2：创建一个新的系统
       贪心流程：
           从前往后扫描每个数，对于每个数：
           情况1：如果现在的子序列的结尾都小于当前数，则创建新子序列
           情况2：将当前数放到结尾大于等于它的最小的子序列后面 
           
        如何证明两个数相等？ A>=B A<=B
           A表示贪心算法得到的序列个数，B表示最优解
           B<=A
           A<=B，调整法
           		假设最优解对应的方案和当前方案不同
           		找到第一个不同的数，将贪心法和最优解不同数后面交换下，可以在有限步内将最优解调整为贪心法的序列，且交换后序列的长度不变
           		贪心法：
           		最优解：
```

**代码：**

```java
import java.util.*;
public class Main{
    static int N = 1010;
    static int n;
    static int[] f = new int[N];//存的是以第i个数结尾的最长下降子序列
    static int[] g = new int[N];//存的是每个下降子序列的最后一个数
    static int[] a = new int[N];//输入
    public static void main(String[] args){
        Scanner scan = new Scanner(System.in);
        while(scan.hasNext()){
            a[n ++ ] = scan.nextInt();
        }
        int res = 0;
        for(int i = 0 ; i < n ; i ++ ){ 
            f[i] = 1;
            for(int j = 0 ; j < i ; j ++ ){
                //后面的导弹不能高于前面的，但是可以等于
                if(a[i] <= a[j]) {
                    f[i] = Math.max(f[i],f[j] + 1);
                }
            }
            res = Math.max(res,f[i]);
        }

        System.out.println(res);

        int cnt = 0;//表示可以覆盖全部输入的下降子序列的数量
        for(int i = 0 ; i < n ; i ++ ){
            //表示从前往后枚举所有子序列,因为子序列的结尾的数是单调上升的，
            //所以只要枚举到比自己大的第一个数就可以直接替换掉这个比自己大的数
            int k = 0;
            while(k < cnt && g[k] < a[i]) k ++ ;
            //如果第一个大于当前数的就是第k个，所以直接将第k个序列的结尾替换成当前数就行
            g[k] = a[i];
            //如果枚举超过了我们的全部序列，就说明没有一个数是比我们大的，就需要新开组别
            if(k >= cnt) cnt ++ ;
        }
        System.out.println(cnt);
    }
}
```



**[题目：AcWing 187. 导弹防御系统 ](https://www.acwing.com/problem/content/189/)**

#### 2.7 导弹防御系统（回）

**题目描述**

为了对抗附近恶意国家的威胁，R 国更新了他们的导弹防御系统。

一套防御系统的导弹拦截高度要么一直 **严格单调** 上升要么一直 **严格单调** 下降。

例如，一套系统先后拦截了高度为 3 和高度为 4 的两发导弹，那么接下来该系统就只能拦截高度大于 4 的导弹。

给定即将袭来的一系列导弹的高度，请你求出至少需要多少套防御系统，就可以将它们全部击落。

**输入格式**

输入包含多组测试用例。

对于每个测试用例，第一行包含整数 n ，表示来袭导弹数量。

第二行包含 n 个**不同的**整数，表示每个导弹的高度。

当输入测试用例 n=0 时，表示输入终止，且该用例无需处理。

**输出格式**

对于每个测试用例，输出一个占据一行的整数，表示所需的防御系统数量。

**数据范围**

$1≤n≤50$

**输入样例：**

```c
5
3 5 2 4 1
0 
```

**输出样例：**

```c
2
```

**样例解释**

对于给出样例，最少需要两套防御系统。

一套击落高度为 3,4 的导弹，另一套击落高度为 5,2,1 的导弹。

**题解：**

``` c
389 207 155 300 299 170 158 65
第一问：389 300 299 170 158 65
第二问: 
	   207有两种选择
           选择1：接在现有的某个子序列之后
           选择2：创建一个新的系统
       贪心流程：
           （1）上升子序列
           从前往后扫描每个数，对于每个数：
           情况1：如果现在的子序列的结尾都小于当前数，则创建新子序列
           情况2：将当前数放到结尾大于等于它的最小的子序列后面 
           
           （2）下降子序列
           需要考虑上升子序列和下降子序列两种情况，所以使用dfs+dp的方法来处理
           
        dfs求最小步数
           （1）方式1：记一个最小步数并不断更新
           （2）方式2：迭代加深
           
        如何证明两个数相等？ A>=B A<=B
           A表示贪心算法得到的序列个数，B表示最优解
           B<=A
           A<=B，调整法
           		假设最优解对应的方案和当前方案不同
           		找到第一个不同的数，将贪心法和最优解不同数后面交换下，可以在有限步内将最优解调整为贪心法的序列，且交换后序列的长度不变
           		贪心法：
           		最优解：
```

**代码：**

```c
/*
 * @Descripttion: 
 * @version: 
 * @Author: ZKYAAA
 * @Date: 2023-07-21 21:36:02
 * @LastEditors: 请叫我ZK谕啊啊啊
 * @LastEditTime: 2023-07-21 21:57:37
 */
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 55;

int n;
int q[N];
int up[N],down[N];  //  up表示上升子序列的结尾，down表示下降子序列结尾
int ans;

/*
u:表示当前枚举到的位置
su:表示上升子序列的个数
sd:表示下降子序列的个数
*/
void dfs(int u, int su,int sd) {
    //剪纸1:当目前的方案是已经大于ans则直接返回
    if(su+sd >= ans) return ;
    //当枚举的位置已经到最后了，则更新答案
    if(u==n){
        ans = su+sd;
        return;
    }

    //情况1：将当前数放到上升子序列中
    int k = 0;
    while(k < su && up[k]>=q[u]) k++;
    int t = up[k];  //备份现场
    up[k] = q[u];
    if(k < su) dfs(u+1,su,sd);  //不需要开辟
    else dfs(u+1,su+1,sd); //开辟上升子序列
    up[k] = t;  //恢复现场
    
    //情况2：将当前数放到下降子序列中
    k = 0;
    while(k < sd && down[k]<=q[u]) k++;
    t = down[k];
    down[k] = q[u];
    if(k < sd) dfs(u+1,su,sd);
    else dfs(u+1,su,sd+1);
    down[k] = t;
}

int main() {
    while(cin>>n, n) {
        for(int i = 0; i < n; i++) cin>>q[i];

        ans = n;    //最坏的情况下是每个数字都需要一个导弹防御系统
        dfs(0,0,0);
        cout<<ans<<endl;
    }
    return 0;
}
```



**[题目：AcWing 272. 最长公共上升子序列  ](https://www.acwing.com/problem/content/274/)**

#### 2.8  最长公共上升子序列（回）

**题目描述**

熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目。

小沐沐先让奶牛研究了最长上升子序列，再让他们研究了最长公共子序列，现在又让他们研究最长公共上升子序列了。

小沐沐说，对于两个数列 A  和 B ，如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一段数是两个数列的公共上升子序列，而所有的公共上升子序列中最长的就是最长公共上升子序列了。

奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。

不过，只要告诉奶牛它的长度就可以了。

数列 A 和 B 的长度均不超过 3000 。

**输入格式**

第一行包含一个整数 N，表示数列 A，B 的长度。

第二行包含 N 个整数，表示数列 A。

第三行包含 N 个整数，表示数列 B。

**输出格式**

输出一个整数，表示最长公共上升子序列的长度。

**数据范围**

$1≤N≤3000$,序列中的数字均不超过 $2^{31}−1$。

**输入样例：**

```c
4
2 2 1 3
2 1 2 3
```

**输出样例：**

```c
2
```

**题解：**

``` c
DP
    （1）状态表示：f[i][j]
      1）集合：所有由第一个序列的前i个字母，和第二个序列的前j个字母构成的，且以b[j]结尾的公共上升子序
      2) 属性：最大值
    （2）状态计算
      1）所有包含a[i]的公共上升子序列
    	 结合是以b[j]结尾的，则a[i]==b[j],也就是序列的倒数第一个数不需要考虑
    	 进一步划分序列的倒数第二个数：
    		倒数第2个数为: 空
                1
    		倒数第2个数为: b[1]
                -----b[1]-b[j] 倒数第2个是b[1]以b[j]结尾的
                f[i-1][1]+1
            倒数第2个数为: b[2]
                -----b[2]-b[j] 倒数第2个是b[2]以b[j]结尾的
                f[i-1][2]+1
            ......
            倒数第2个数为: b[j-1]
                
            总结：f[i-1][k]+1
    		
      2）所有不包含a[i]的公共上升子序列
    	 f[i-1][j]
```

**代码：**

**暴力**

```c
/*
 * @Descripttion: 
 * @version: 
 * @Author: ZKYAAA
 * @Date: 2023-07-21 22:56:49
 * @LastEditors: 请叫我ZK谕啊啊啊
 * @LastEditTime: 2023-07-21 23:02:51
 */
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 3010;

int n;
int a[N],b[N];
int f[N][N];

int main() {
    scanf("%d",&n);
    for(int i = 1; i <= n; i++) scanf("%d",&a[i]);
    for(int i = 1; i <= n; i++) scanf("%d",&b[i]);

    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= n; j++) {
            f[i][j] = f[i-1][j];    //所有不包含a[i]的公共上升子序列
            // 所有包含a[i]的公共上升子序列
            if(a[i]==b[j]){
                f[i][j] = max(f[i][j],1);   //处理倒数第2个数为: 空
                for(int k = 1; k < j; k++) {
                    if(b[k] < b[j]) {
                        f[i][j] = max(f[i][j],f[i][k]+1);
                    }
                }
            }
        }
    }

    int res = 0;
    for(int i = 1; i <= n; i++) res = max(res,f[n][i]);
    printf("%d",res);
    return 0;
}
```

**优化**

```c
#include <iostream>

using namespace std;

const int N = 3010;

int n;
int a[N], b[N];
int f[N][N];

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i ++ ) cin >> a[i];
    for (int i = 1; i <= n; i ++ ) cin >> b[i];

    for (int i = 1; i <= n; i ++ )
    {
        int maxv = 1;
        for (int j = 1; j <= n; j ++ )
        {
            f[i][j] = f[i - 1][j];
            if (a[i] == b[j]) f[i][j] = max(f[i][j], maxv);

            if (b[j] < a[i])
                maxv = max(maxv, f[i - 1][j] + 1);
        }
    }

    int res = 0;
    for (int i = 1; i <= n; i ++ ) res = max(res, f[n][i]);
    cout << res << endl;

    return 0;
}
```



### 3、背包模型（组合类型DP）

```
当空间优化为1维之后，只有完全背包问题的体积是从小到大循环的（多重背包特殊）
for 物品
	for 体积
		for 决策(划分子集)
		
完全背包：求所有前缀和最大值
多重背包：求滑动窗口内的最大值
		
背包问题：
（1）状态表示f[i][j]
	1）集合：所有只从前i个物品中选，且总体积不超过j的选法的集合
	2）属性：max
（2）状态计算
	集合划分（划分依据：用最后一步来划分）
	1) 01背包：每个物品选或者不选(体积从大到小循环)
		① 选择第i个武平的所有方案
			-------  物品i
			-------  物品i
			-------  物品i
			。。。。。
			-------  物品i
			
			物品i的占用了Vi,所以左边部分 ------- <= J-Vi
			f[i-1][j-vi] + wi
		② 不选择第i个物品的所有的方案
			f[i-1][j]
		两种方法取最大：res = max(f[i-1][j],f[i-1][j-vi] + wi)
		
	2） 完全背包：每个物品选0，选1个，选2个....选s个
		① 选择第i个武平的所有方案
			-------  物品i选0个
				f[i-1][j]
			-------  物品i选1个
				f[i-1][j-vi] + wi
			-------  物品i选2个
				f[i-1][j-2*vi] + 2*wi
			。。。。。
			-------  物品i选s个
				f[i-1][j-s*vi] + s*wi
			
			物品i的占用了Vi,所以左边部分 ------- <= J-Vi
			f[i-1][j-vi] + wi
		② 优化
			
		两种方法取最大：
			f[i][j] = max( f[i-1][j], f[i-1][j-vi] + wi, f[i-1][j-2*vi] + 2*wi, ....,f[i-1][j-s*vi] + s*wi)
			f[i][j-vi] = max( f[i-1][j-vi], f[i-1][j-2*vi] + wi, f[i-1][j-3*vi] + 2*wi, ....,f[i-1][j-s*vi] + s*wi)
			
			f(i,j)=max(f(i-1,j) , f(i-1,j-v)+w , f(i-1,j-2*v)+2w , f(i-1,j-3*v)+3w ,.. )
            f(i,j-v)=max(         f(i-1,j-v)   , f(i-1,j-2*v)+ w , f(i-1,j-3*v)+2w ,.. )       
            		=>f(i,j)=max(f(i-1,j),f(i-1,j-v)+w)
	
	3） 多重背包(队列优化)：每个物品选0个，选1个，....选si个
		集合的划分:分若干组，按照第i个物品选多少个分(完全背包类似)
            0 1 2 3 4 5 .... s[i]  第i个物品选了0~k个
            注意：下面的式子是理想情况，当j不够的时候，边界情况需要额外考虑
            f(i,j)=max(f(i-1,j) , f(i-1,j-v)+w , f(i-1,j-2*v)+2w , f(i-1,j-3*v)+3w ,..f(i-1,j-s*v)+sw )
            f(i,j-v)=max(         f(i-1,j-v)   , f(i-1,j-2*v)+ w , f(i-1,j-3*v)+2w ,..         f(i-1,j-(s+1)*v)+sw )       
            	和完全背包不同的是第二个式子最后一项，是 -(s+1)*v，求j-v前面到j-sv的最大值
            f(i,j-2v)=max(                       f(i-1,j-2*v)     , f(i-1,j-3*v)+w ,..         f(i-1,j-(s+1)*v)+(s-1)*w...)  
            f(i,j-3v)=
            ........
            
            j,-v,j-2v,j-3v.....都是j mod v的余数
            设r为j mod v的余数
            r	    r+v	   r+2v	   r+3v	  r+4v	r+5v	.....	j-v		j
           -0*w    -1*w    -2*w    -3*w   -4*w   .....
            当求f[j]的时候，就是求f[j-v]前面n步的最大值（滑动窗口）
            		
		状态转移方程：f(i,j)=max(f[i][j],f[i-1][j-v[i]*k]+w[i]*k)  k=0,1,2.....s[i]
```

### （零）背包问题

```
DP  1.状态(一个集合)表示
		二维：f(i,j)
		1.1 集合：所有选法
				条件：（1）只从前i个物品中选
					 （2）总体积<=j
		1.2 属性：max值,min值,元素数量
	2.状态计算:一步一步的将状态计算出来
		集合的划分,不重复（不一定需要必须满足），不遗漏
		f(i,j)集合划分为若干个更小的子集，每个子集都能求出答案
		（1）选法不包含i：f(i-1,j)
			所有从1-i中选，总体积<=j，不包含i中选择
			所有从1~i-1中选，总体积<=j选法
		（2）选法包含i: f(i-1,j-Vi)+Wi
			所有从1-i中选，总体积<=j，包含i中选择
		  =>将Vi拿走结果不变
		  =>所有从1~i-1中选，总体积<=j-Vi，包含i中选择:f(i-1,j-Vi)+Wi
		  
		  最终f(i,j)=max(f(i-1,j),f(i-1,j-Vi)+Wi)
	3.dp优化
		对dp的代码和计算方程进行变形
```

```
1.01背包 ： 每件物品最多只能用一次
2.完全背包 ： 每件物品有无限个
3.多重背包及优化版本：每个物品有有限个，告诉限制个数
4.分组背包 ： 有N组，每组里面有若干元素，每组里面最多选择一个物品
```



#### 0.1  01背包问题

**[题目：AcWing 2. 01背包问题]()**

**题目描述**

有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。

第 i 件物品的体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

**输入格式**

第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。

接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

$0 < N,V ≤ 1000$

$0<vi,wi≤1000$

**输入样例：**

```c
4 5
1 2
2 4
3 4
4 5
```

**输出样例：**

```c
8
```

**题解：**

``` c
每件物品最多只能用一次
DP  1.状态(一个集合)表示
		二维：f(i,j)
		1.1 集合：所有选法
				条件：（1）只从前i个物品中选
					 （2）总体积<=j
    
		1.2 属性：max值
    
	2.状态计算:一步一步的将状态计算出来
		集合的划分,不重复（不一定需要必须满足），不遗漏
		f(i,j)集合划分为若干个更小的子集，每个子集都能求出答案
		（1）选法不包含i：f(i-1,j)
			所有从1-i中选，总体积<=j，不包含i
		  =>所有从1~i-1中选，总体积<=j选法
		（2）选法包含i: f(i-1,j-V[i])+Wi
			所有从1-i中选，总体积<=j，包含i中选择
		  =>将V[i]拿走,求不包含V[i]的答案，在加上V[i]的值w[i]
		  =>所有从1~i-1中选，总体积<=j-V[i]，包含i中选择:f(i-1,j-V[i])+W[i]
		  
		  最终f(i,j)=max(f(i-1,j),f(i-1,j-V[i])+W[i])
    3.优化
    	(1)f(i,j)=max(f(i-1,j),f(i-1,j-V[i])+W[i])每个阶段的i的状态只用到了i-1的状态，
            利用“滚动数组”优化，第二维要么是j要么是j-Vi都<=j;
			f[i][j] = f[i - 1][j];
		  =>f[i&1][j] = f[(i - 1)&1][j];

			f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
          =>f[i&1][j] = max(f[i&1][j], f[(i - 1)&1][j - v[i]] + w[i]);
			
			f[n][j]
          =>f[n&1][j]
            i的状态用i&1替代，当i为奇数的时候,i&1=1；当i为偶数的时候，i&1==0
            这样的话dp的状态就相当于在f[1][]和f[0][]两个数组中交替转化，O(NM)变为O(M)
            
            每个阶段实际上是执行了一次从f[i-1][]到f[i][]的拷贝操作，进一步省去f[i]
                
        (2)如果j从小往大遍历，后面的dp[j]可能已经被前面的更新了，相当于dp[i][j - v[i]]
        (3)所以让j从大到小倒序遍历。当j的时候，f数组的后半部分f[j~m]处于i阶段，就是放入第i个物品的情况；前半部分f[0~j-1]处于第i-1阶段，也就是没有i的更新；j减小就是用i-1状态去更新i状态。
        (4)如果是正序遍历j的话，可能会覆盖，产生矛盾
            
    4.注意：
    	(1)初值：f[0,0]=0,其余为负无穷
                
```

**代码：**

```c
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 1010;
int n, m;
int v[N], w[N];
int f[N][N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> v[i] >> w[i];
    // f[0~n][0~m]
    // f[0][0~m]=0，一件物品也没有选，都为0,所以不用枚举
    for (int i = 1; i <= n; i++)
    {
        // j=0表示一共选了体积为0的物体
        for (int j = 0; j <= m; j++)
        {
            //选法不包含i
            f[i][j] = f[i - 1][j];
            //选法包含i,第i件物品体积小于等于背包总容量
            if (j >= v[i])
                f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
        }
    }
    cout << f[n][m] << endl;
    return 0;
}
```

**优化后代码：**

```c
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 1010;
int n, m;
int v[N], w[N];
int f[N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> v[i] >> w[i];
    // f[0~n][0~m]
    // f[0][0~m]=0，一件物品也没有选，都为0,所以不用枚举
    for (int i = 1; i <= n; i++)
    {
        // j=0表示一共选了体积为0的物体	
        for (int j = m; j >= v[i]; j--)
        {
            f[j] = max(f[j], f[j - v[i]] + w[i]);
        }
    }
    cout << f[m] << endl;
    return 0;
}
```



#### 0.2 完全背包问题

**[题目：AcWing 3. 完全背包问题]()**

**题目描述**

有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。

第 i 种物品的体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

**输入格式**

第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。

接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 种物品的体积和价值。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

$0 < N,V ≤ 1000$

$0 < vi,wi ≤ 1000$

**输入样例：**

```c
4 5
1 2
2 4
3 4
4 5
```

**输出样例：**

```c
10
```

**题解：**

> **结论**：
>
> 将0-1背包中j的循环顺序改成从小到大，就变成了完全背包。
>
> 0-1背包：`dp[i][j] = max(dp[i-1][j], dp[i-1][j-vi]+wi)`
>
> 完全背包：`dp[i][j] = max(dp[i-1][j], dp[i][j-vi]+wi)`
>
> 0-1背包是从 i-1 转移过去的（从大到小枚举的），完全背包是从 i 转移过去的（从小到大枚举）

``` c
每件物品有无限个
DP 1.状态表示f(i,j)
    	1.1 集合
    		所有只考虑前i个物品，且总体积不大于j的所有选法
    	1.2 属性
    		Max
   2.状态计算
    	集合的划分:分若干组，按照第i个物品选多少个分
            0 1 2 3 4 5 ....k-1 k  第i个物品选了0~k个
            f(i,j)表示选第i个物品，总体积不超过j
    	(1)第i个物品不选，只考虑前1~i-1的话用f(i-1,j)表示
            当k=0,f(i-1,j)=f(i-1,j-k*v[i])+k*w[i]
        (2)第i个物品选，选k个
            1)去掉k个物品i
            2)求MAX,f(i-1,j-k*v[i])
            3)再加回来k个物品i
            =>f(i-1,j-k*v[i])+k*w[i]
     	=>f(i,j)=f(i-1,j-v[i]*k)+w[i]*k
            
   3.优化
   	f(i,j)=max(f(i-1,j) ,f(i-1,j-v)+w ,f(i-1,j-2*v)+2w ,f(i-1,j-3*v)+3w ,..,f(i-1,j-(k-1)*v)+(k-1)*v ,f(i-1,j-k*v)+k*v)
    f(i,j-v)=max(        f(i-1,j-v)   ,f(i-1,j-2*v)+ w ,f(i-1,j-3*v)+2w ,..,f(i-1,j-(k-1)*v)+(k-2)*v ,f(i-1,j-k*v)+(k-1)*v)       
            =>f(i,j)=max(f(i-1,j),f(i,j-v)+w)
        
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;
const int N = 1010;

int n, m;
int v[N], w[N];
int f[N][N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> v[i] >> w[i];

    for (int i = 1; i <= n; i++)
        for (int j = 0; j <= m; j++)
            for (int k = 0; k * v[i] <= j; k++)
                f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);
    cout << f[n][m] << endl;
    return 0;
}
```

**优化代码**

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;
const int N = 1010;

int n, m;
int v[N], w[N];
int f[N][N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> v[i] >> w[i];

    for (int i = 1; i <= n; i++)
        for (int j = 0; j <= m; j++)
        {
            f[i][j] = f[i - 1][j];
            if (j >= v[i])
                f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]);
        }

    cout << f[n][m] << endl;
    return 0;
}
```

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;
const int N = 1010;

int n, m;
int v[N], w[N];
int f[N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> v[i] >> w[i];

    for (int i = 1; i <= n; i++)
        for (int j = v[i]; j <= m; j++)
            f[j] = max(f[j], f[j - v[i]] + w[i]);

    cout << f[m] << endl;
    return 0;
}
```



#### 0.3 多重背包问题

**[题目：AcWing 4. 多重背包问题 I]()**

**题目描述**

有 N 种物品和一个容量是 V 的背包。

第 i 种物品最多有 $s_i$ 件，每件体积是 $v_i$，价值是 $w_i$。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。

**输入格式**

第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。

接下来有 N 行，每行三个整数 $v_i,w_i,s_i$，用空格隔开，分别表示第 i 种物品的体积、价值和数量。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

$0 < N,V ≤ 100$

$0 < vi,wi,si ≤ 100$

**输入样例：**

```c
4 5
1 2 3
2 4 1
3 4 3
4 5 2
```

**输出样例：**

```c
10
```

**题解：**

``` c
DP 1.状态表示f(i,j)
    1.1 集合
    	所有从前i个物品中选，并且总体积不超过j的选法
    
    1.2 属性
    	Max，总价值的最大值
    
    2.状态计算
    	集合的划分:分若干组，按照第i个物品选多少个分(完全背包类似)
            0 1 2 3 4 5 .... s[i]  第i个物品选了0~k个
            
		状态转移方程：f(i,j)=max(f[i][j],f[i-1][j-v[i]*k]+w[i]*k)  k=0,1,2.....s[i]
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 110;

int n, m;
int v[N], w[N], s[N];
int f[N][N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> v[i] >> w[i] >> s[i];

    for (int i = 1; i <= n; i++)
        for (int j = 0; j <= m; j++)
            for (int k = 0; k <= s[i] && k * v[i] <= j; k++)
                f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);

    cout << f[n][m] << endl;
    return 0;
}
```



**[题目：AcWing 5. 多重背包问题 II]()**

**题目描述**

有 N 种物品和一个容量是 V 的背包。

第 i 种物品最多有 $s_i$ 件，每件体积是 $v_i$，价值是 $w_i$。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。

输出最大价值。

**输入格式**

第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。

接下来有 N 行，每行三个整数 $v_i,w_i,s_i$，用空格隔开，分别表示第 i 种物品的体积、价值和数量。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

$0 < N ≤ 1000$

$0 < V ≤ 2000$

$0 < vi,wi,si ≤ 2000$

**输入样例：**

```c
4 5
1 2 3
2 4 1
3 4 3
4 5 2
```

**输出样例：**

```c
10
```

**题解：**

``` c
DP 1.状态表示f(i,j)
    1.1 集合
    	所有从前i个物品中选，并且总体积不超过j的选法
    
    1.2 属性
    	Max，总价值的最大值
    
    2.状态计算
    	集合的划分:分若干组，按照第i个物品选多少个分(完全背包类似)
            0 1 2 3 4 5 .... s[i]  第i个物品选了0~k个
            
		状态转移方程：f(i,j)=max(f[i][j],f[i-1][j-v[i]*k]+w[i]*k)  k=0,1,2.....s[i]
    3.优化
    f(i,j)=max(f(i,j),f(i-1,j-v)+w,f(i-1,j-2v)+2w,......f(i-1,j-sv)+sw)
    f(i,j-v)=max(     f(i-1,j-v),  f(i-1,j-2v)+w, ......f(i-1,j-sv)+(s-1)w ,f(i-1,j-(s+1)v)+sw);
	注意：f(i-1,j-(s+1)v)+sw 不存在	

	二进制优化 
        有s个物品：
        1，2，4，8，.....2^k,C
        C< 2^(k+1)
        所以可以凑出来C~C+2^(k+1)-1的数
```

**代码**

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 110;

int n, m;
int v[N], w[N], s[N];
int f[N][N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> v[i] >> w[i] >> s[i];

    for (int i = 1; i <= n; i++)
        for (int j = 0; j <= m; j++)
            for (int k = 0; k <= s[i] && k * v[i] <= j; k++)
                f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);

    cout << f[n][m] << endl;
    return 0;
}
```

**代码优化：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

// 1000 * log(2000) 开数据
const int N = 25000, M = 2010;

int n, m;
int v[N], w[M];
int f[N];

int main()
{
    cin >> n >> m;

    int cnt = 0;

    for (int i = 1; i <= n; i++)
    {
        int a, b, s;
        cin >> a >> b >> s;
        //小于S的时候一直减了凑：1+2+4+8+...+2^k+c <= s
        int k = 1;
        while (k <= s)
        {
            cnt++;
            v[cnt] = a * k;
            w[cnt] = b * k;
            s -= k;
            k *= 2;
        }
        //此时c == s
        if (s > 0)
        {
            cnt++;
            v[cnt] = a * s;
            w[cnt] = b * s;
        }
    }
    n = cnt;
    for (int i = 1; i <= n; i++)
        for (int j = m; j >= v[i]; j--)
            f[j] = max(f[j], f[j - v[i]] + w[i]);
    cout << f[m] << endl;
    return 0;
}
```

#### 0.4 分组背包问题

**[题目：AcWing 9. 分组背包问题]()**

**题目描述**

有 N 组物品和一个容量是 V 的背包。

每组物品有若干个，同一组内的物品最多只能选一个。

每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。

求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。

输出最大价值。

**输入格式**

第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。

接下来有 N 组数据：

- 每组数据第一行有一个整数 Si，表示第 i 个物品组的物品数量；
- 每组数据接下来有 Si 行，每行有两个整数 vij,wij，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值；

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

$0 < N,V ≤ 100$

$0 < Si ≤ 100$

$0 < vij,wij ≤ 100$

**输入样例：**

```c
3 5
2
1 2
2 4
1
3 4
1
4 5
```

**输出样例：**

```c
8
```

**题解：**

``` c
DP 1.状态表示f(i,j)
    1.1 集合
    	所有从前i组物品中选，并且总体积不大于j的选法
    
    1.2 属性
    	Max，总价值的最大值
    
   2.状态计算
    	集合的划分:分若干组，按照第i个物品选多少个分(完全背包类似)
            0 1 2 3 4 5 .... s[i]  选第i组的第k个物品选了0~k个
        (1)第i组的一个都不选
            f(i-1,j)
        (2)第i组物品选第k个物品
            f(i-1,j-v[i,k])+w[i,k]
           
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 110;
int n, m;
// s存每组的个数
int v[N][N], w[N][N], s[N];
int f[N];

int main()
{
    cin >> n >> m;

    for (int i = 1; i <= n; i++)
    {
        cin >> s[i];
        for (int j = 0; j < s[i]; j++)
            cin >> v[i][j] >> w[i][j];
    }

    for (int i = 1; i <= n; i++)
    {
        for (int j = m; j >= 0; j--)
        {
            for (int k = 0; k < s[i]; k++)
            {
                if (v[i][k] <= j)
                    f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);
            }
        }
    }
    cout << f[m] << endl;
    return 0;
}
```

### （一）01-背包应用

**[题目：AcWing 423. 采药  ](https://www.acwing.com/problem/content/425/)**

#### 3.1 采药

**题目描述**

辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。

为此，他想拜附近最有威望的医师为师。

医师为了判断他的资质，给他出了一个难题。

医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”

如果你是辰辰，你能完成这个任务吗？

**输入格式**

输入文件的第一行有两个整数 T 和 M，用一个空格隔开，T  代表总共能够用来采药的时间，M 代表山洞里的草药的数目。

接下来的 M 行每行包括两个在 1 到 100 之间（包括 1 和 100）的整数，分别表示采摘某株草药的时间和这株草药的价值。

**输出格式**

输出文件包括一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。

**数据范围**

$1≤T≤1000$,
$1≤M≤100$

**输入样例：**

```c
70 3
71 100
69 1
1 2
```

**输出样例：**

```c
3
```

**题解：**

``` c
组合数+选择问题（采摘/不采摘）+没有顺序
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 1010;

int n,m;
int f[N];

int main() {
  cin>>m>>n;
  for(int i = 0; i < n; i++) {
    int v, w;
    cin>>v>>w;
    for(int j = m; j >= v; j--) f[j] = max(f[j],f[j-v] + w);
  }

  cout<< f[m] << endl;
  return 0;
}
```



#### 3.2 装箱问题

[Acwing1024. 装箱问题](https://www.acwing.com/problem/content/1026/)

**题目描述**

有一个箱子容量为 V，同时有 n 个物品，每个物品有一个体积（正整数）。

要求 n 个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。

**输入格式**

第一行是一个整数 V，表示箱子容量。

第二行是一个整数 n，表示物品数。

接下来 n 行，每行一个正整数（不超过10000），分别表示这 n 个物品的各自体积。

**输出格式**

一个整数，表示箱子剩余空间。

**数据范围**

$0<V≤20000$,
$0<n≤30$

**输入样例：**

```c
24
6
8
3
12
7
9
7
```

**输出样例：**

```c
0
```

**题解：**

``` c
价值和体积都看作体积
    总体积最大 等价于 箱子剩余空间最小
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 20010;

int m,n;
int f[N];

int main() {
  cin>>m>>n;
  for(int i = 0; i < n; i++) {
    int v;
    cin>> v;
    for(int j = m; j >= v; j--) f[j] = max(f[j],f[j - v]+v);
  }
  cout << m - f[m] << endl;
  return 0;
}
```



#### 3.3 数字组合（01背包求方案数）

[Acwing 278. 数字组合](https://www.acwing.com/problem/content/280/)

**题目描述**

给定 N 个正整数 $A_1,A_2,…,A_N$，从中选出若干个数，使它们的和为 M，求有多少种选择方案。

**输入格式**

第一行包含两个整数 N 和 M。

第二行包含 N 个整数，表示 $A_1,A_2,…,A_N$。

**输出格式**

包含一个整数，表示可选方案数。

**数据范围**

$1≤N≤100$,
$1≤M≤10000$,
$1≤A_i≤1000$,
答案保证在 int 范围内。

**输入样例：**

```c
4 4
1 1 2 2
```

**输出样例：**

```c
3
```

**题解：**

``` c
M看作背包容量
把每个数看成是一个物品，Ai看成是体积
目标:求出总体积恰好是M的方案数
    
DP
    (1)状态表示：f[i][j]
    	1)集合：所有只从前i个物品中选择，且总体积恰好是j的方案的集合
    	2)属性：Count
    
    (2)状态计算
    	集合划分
    	初始化f[0][0] = 1,f[0][i] = 0
    	1)不包括物品i的所有选法
    		f[i-1][j]
    	2)包括物品i的所有选法
    		..... 物品i
    		..... 物品i
    		..... 物品i
    		
    		物品i前面部分，从物品1~i-1中选择，且体积<=j-vi
    		f[i-1][j-vi]
    f[i][j] = f[i-1][j] + f[i-1][j-vi]
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 10010;

int n,m;
int f[N];

int main() {
  cin >> n >> m;
  f[0] = 1;
  for(int i = 0; i < n; i++) {
    int v;
    cin >> v;
    for(int j = m; j >= v; j--) {
      f[j] += f[j-v];
    }
  }
  cout << f[m] << endl;
  return 0;
}
```



#### 3.4 开心的金明

[AcWing 426. 开心的金明](https://www.acwing.com/activity/content/problem/content/1280/)

**题目描述**

金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间他自己专用的很宽敞的房间。

更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 N 元钱就行”。

今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的 N 元。

于是，他把每件物品规定了一个重要度，分为 5 等：用整数 1∼5表示，第 5 等最重要。

他还从因特网上查到了每件物品的价格（都是整数元）。

他希望在不超过 N 元（可以等于 N 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。 

设第 j 件物品的价格为 v[j]，重要度为 w[j]，共选中了 k 件物品，编号依次为 $j_1，j_2，…，j_k$，则所求的总和为： 

$v[j_1]×w[j_1]+v[j_2]×w[j_2]+…+v[j_k]×w[j_k]$

请你帮助金明设计一个满足要求的购物单。

**输入格式**

输入文件的第 1 行，为两个正整数 N 和 m，用一个空格隔开。（其中 N 表示总钱数，m 为希望购买物品的个数） 

从第 2 行到第 m+1 行，第 j 行给出了编号为 j−1 的物品的基本数据，每行有 2 个非负整数 v 和 p。（其中 v 表示该物品的价格，p 表示该物品的重要度）

**输出格式**

输出文件只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（数据保证结果不超过 $10^8$）。

**数据范围**

$1≤N<30000$,
$1≤m<25$,
$0≤v≤10000$,
$1≤p≤5$

**输入样例：**

```c
1000 5
800 2
400 5
300 5
400 3
200 2
```

**输出样例：**

```c
3900
```

**题解：**

``` c
01背包
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 30010;

int n,m;
int f[N];

int main() {
  cin >> m >> n;
  for(int i = 0; i < n; i++) {
    int v,w;
    cin >> v >> w;
    for(int j = m; j >= v; j--) f[j] = max(f[j], f[j-v] + v*w);
  }
  cout << f[m] << endl;
  return 0;
}
```



#### 3.5 能量石（贪心）todo

[Acwing 734. 能量石](https://www.acwing.com/problem/content/736/)

**题目描述**

岩石怪物杜达生活在魔法森林中，他在午餐时收集了 N 块能量石准备开吃。

由于他的嘴很小，所以一次只能吃一块能量石。

能量石很硬，吃完需要花不少时间。

吃完第 i 块能量石需要花费的时间为 $S_i$ 秒。

杜达靠吃能量石来获取能量。

不同的能量石包含的能量可能不同。

此外，能量石会随着时间流逝逐渐失去能量。

第 i 块能量石最初包含 $E_i$ 单位的能量，并且每秒将失去$ L_i$ 单位的能量。

当杜达开始吃一块能量石时，他就会立即获得该能量石所含的全部能量（无论实际吃完该石头需要多少时间）。

能量石中包含的能量最多降低至 0。

请问杜达通过吃能量石可以获得的最大能量是多少？

**输入格式**

第一行包含整数 T，表示共有 T 组测试数据。

每组数据第一行包含整数 N，表示能量石的数量。

接下来 N 行，每行包含三个整数 $S_i,E_i,L_i$。

**输出格式**

每组数据输出一个结果，每个结果占一行。

结果表示为 `Case #x: y`，其中 x 是组别编号（从 1 开始），y 是可以获得的最大能量值。

**数据范围**

$1≤T≤10$,
$1≤N≤100,$
$1≤S_i≤100$,
$1≤E_i≤10^5$,
$0≤L_i≤10^5$

**输入样例：**

```c
3
4
20 10 1
5 30 5
100 30 1
5 80 60
3
10 4 1000
10 3 1000
10 8 1000
2
12 300 50
5 200 0
```

**输出样例：**

```c
Case #1: 105
Case #2: 8
Case #3: 500
```

#### 样例解释

在样例＃1中，有 N=4 个宝石。杜达可以选择的一个吃石头顺序是：

- 吃第四块石头。这需要 5 秒，并给他 80 单位的能量。
- 吃第二块石头。这需要 5 秒，并给他 5 单位的能量（第二块石头开始时具有 30 单位能量，5 秒后失去了 25 单位的能量）。
- 吃第三块石头。这需要 100 秒，并给他 20 单位的能量（第三块石头开始时具有 30 单位能量，10 秒后失去了 10 单位的能量）。
- 吃第一块石头。这需要 20 秒，并给他 0 单位的能量（第一块石头以 10 单位能量开始，110 秒后已经失去了所有的能量）。

他一共获得了 105 单位的能量，这是能获得的最大值，所以答案是 105。

在样本案例＃2中，有 N=3 个宝石。

无论杜达选择吃哪块石头，剩下的两个石头的能量都会耗光。

所以他应该吃第三块石头，给他提供 8 单位的能量。

在样本案例＃3中，有 N=2 个宝石。杜达可以：

- 吃第一块石头。这需要 12 秒，并给他 300 单位的能量。
- 吃第二块石头。这需要 5 秒，并给他 200 单位的能量（第二块石头随着时间的推移不会失去任何能量！）。

所以答案是 500。

**题解：**

``` c

```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110, M = 10010;

int n;
struct Stone
{
    int s, e, l;
}stones[N];

bool cmp(Stone a, Stone b)
{
    return a.s * b.l < b.s * a.l;
}

int f[N][M];

int main()
{
    int T;
    cin >> T;
    for (int C = 1; C <= T; C ++ )
    {
        cin >> n;
        int m = 0;
        for (int i = 1; i <= n; i ++ )
        {
            int s, e, l;
            cin >> s >> e >> l;
            stones[i] = {s, e, l};
            m += s;
        }

        sort(stones + 1, stones + 1 + n, cmp);

        for (int i = 1; i <= n; i ++ )
            for (int j = 0; j <= m; j ++ )
            {
                f[i][j] = f[i - 1][j];
                if (j >= stones[i].s)
                {
                    int s = stones[i].s, e = stones[i].e, l = stones[i].l;
                    f[i][j] = max(f[i][j], f[i - 1][j - s] + max(0, e - l * (j - s)));
                }
            }

        int res = 0;
        for (int i = 0; i <= m; i ++ ) res = max(res, f[n][i]);

        printf("Case #%d: %d\n", C, res);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/120230/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



### （二）完全背包问题应用

#### 3.6 买书（方案数）

[Acwing 1023. 买书](https://www.acwing.com/problem/content/1025/)

**题目描述**

小明手里有n元钱全部用来买书，书的价格为10元，20元，50元，100元。

问小明有多少种买书方案？（每种书可购买多本）

**输入格式**

一个整数 n，代表总共钱数。

**输出格式**

一个整数，代表选择方案种数。

**数据范围**

0≤n≤1000

**输入样例1：**

```c
20
```

**输出样例1：**

```c
2
```

**输入样例2：**

```c
15
```

**输出样例2：**

```c
0
```

**输入样例3：**

```c
0
```

**输出样例3：**

```c
1
```

**题解：**

``` c
DP
    (1)状态表示f[i][j]
    	1）集合：所有只从前i个物品中选，且总体积恰好是j的方案的集合
    	2）属性：Count
    (2)状态计算
    	1) 物品i选0个
    		f[i-1][j]
    	2) 物品i选1个
    	3) 物品i选2个
    	4) 物品i选3个
    	......
		s)   物品i选s-1个
    	s+1) 物品i选s个
    
    	...... 物品i选择k个
    	...... 物品i选择k个
    	...... 物品i选择k个
    	...... 物品i选择k个
    	左边部分：只从前i-1中选择，体积<=j-vi*k
    			f[i-1][j-vi*k]
    	
    f[i][j] = f[i-1][j]+f[i-1][j-vi*1]+f[i-1][j-vi*2]+ ...+f[i-1][j-vi*s]
    f[i][j-vi] =        f[i-1][j-vi*1]+f[i-1][j-vi*2]+ ...+f[i-1][j-vi*s] + f[i-1][j-vi*(s+1)]
    f[i][j-vi] =        f[i-1][j-vi*1]+f[i-1][j-vi*2]+ ...+f[i-1][j-vi*s]
    最多可以选择s个，所以f[i-1][j-vi*(s+1)]不存在
    f[i][j] = f[i-1][j]+f[i][j-vi]
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 1010;

int v[5] = {0,10,20,50,100};
int f[5][N];

int main() {
  int m;
  cin >> m;

  f[0][0] = 1;
  for(int i = 1; i <= 4; i++) {
    for(int j = 0; j <= m; j++) {
      f[i][j] = f[i-1][j];
      if(j >= v[i]) f[i][j] += f[i][j-v[i]];
    }
  }
  cout<< f[4][m]<<endl;
  return 0;
}
```

**优化**

```c
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 1010;

int v[5] = {0,10,20,50,100};
int f[N];

int main() {
  int m;
  cin >> m;

  f[0] = 1;
  for(int i = 1; i <= 4; i++) {
    for(int j = 0; j <= m; j++) {
      if(j >= v[i]) f[j] += f[j-v[i]];
    }
  }
  cout<< f[m]<<endl;
  return 0;
}
```



#### 3.7  货币系统 （方案数）

[Acwing1021货币系统 ](https://www.acwing.com/problem/content/1023/)

**题目描述**

给你一个 n 种面值的货币系统，求组成面值为 m 的货币有多少种方案。

**输入格式**

第一行，包含两个整数 n 和 m。

接下来 n 行，每行包含一个整数，表示一种货币的面值。

**输出格式**

共一行，包含一个整数，表示方案数。

**数据范围**

$n≤15,m≤3000$

**输入样例：**

```c
3 10
1
2
5
```

**输出样例：**

```c
10
```

**题解：**

``` c
n个物品（无限个），容量为m的背包
    f[i][j] = f[i-1][j] + f[i][j-v[i]]
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 3010;

int n,m;
LL f[N];

int main() {
  cin >> n >> m;
  f[0] = 1; 
  for(int i = 0; i < n; i++) {
    int a;
    cin >> a;
    for(int j = a; j <= m; j++) f[j] += f[j - a];
  }
  cout << f[m] << endl;
}
```



#### 3.8 货币系统(贪心)

[AcWing 532. 货币系统](https://www.acwing.com/problem/content/534/)

**题目描述**

在网友的国度中共有 $n$ 种不同面额的货币，第 $i$ 种货币的面额为 $a[i]$，你可以假设每一种货币都有无穷多张。

为了方便，我们把货币种数为 $n$、面额数组为 $a[1..n]$ 的货币系统记作 $(n,a)$。 

在一个完善的货币系统中，每一个非负整数的金额 $x$ 都应该可以被表示出，即对每一个非负整数 $x$，都存在 $n$ 个非负整数 $t[i]$ 满足 $a[i]×t[i]$ 的和为 $x$ 。

然而，在网友的国度中，货币系统可能是不完善的，即可能存在金额 x 不能被该货币系统表示出。

例如在货币系统 $n=3, a=[2,5,9]$ 中，金额 $1,3$ 就无法被表示出来。 

两个货币系统 $(n,a)$ 和 $(m,b)$ 是等价的，当且仅当对于任意非负整数 $x$ ，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。 

现在网友们打算简化一下货币系统。

他们希望找到一个货币系统 $(m,b)$ ，满足 $(m,b)$ 与原来的货币系统 $(n,a)$ 等价，且 $m$ 尽可能的小。

他们希望你来协助完成这个艰巨的任务：找到最小的 $m$。

**输入格式**

输入文件的第一行包含一个整数 $T$ ，表示数据的组数。

接下来按照如下格式分别给出 $T$   组数据。 

每组数据的第一行包含一个正整数 $n$ 。

接下来一行包含 $n$ 个由空格隔开的正整数 $a[i]$ 。

**输出格式**

输出文件共有 $T$ 行，对于每组数据，输出一行一个正整数，表示所有与 $(n,a)$ 等价的货币系统 $(m,b)$ 中，最小的 $m$。

**数据范围**

$1≤n≤100$,
$1≤a[i]≤25000$,
$1≤T≤20$

**输入样例：**

```c
2 
4 
3 19 10 6 
5 
11 29 13 19 17 
```

**输出样例：**

```c
2
5
```

**题解：**

``` c
3 19 10 6 == 3 10
{a1,a2,a3......an}
	x = a1*t1 + a2*t2 + a3*t3+ .. an*tn  ti>=0
{b1,b2,b3,.....bn}
性质1：
    a1,a2,....an一定都可以被表示出来
性质2：
    在最优解中,b1,b2,.....bm一定都是从a1,a2,....an中选择的
证明：
bi = ai+aj+ak = 2b1 + 3b2 + ....
bi > ai,aj,ak
    ai = bj + bk + bz
    aj = ....... 
bi都能被ai中的数组成
性质3：
    b1,b2,....bm一定不能被其他bi表示出来

 ai 可以被表示：一定不能选择
    不可以被表示：必选
 ai 能否被表示，用a1~a_{i-1}能否表示ai
 

```

**代码：**

```c
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110 ,M = 25010;

int n;
int a[N];
int f[M];

int main() {
  int T;
  cin >> T;
  while(T--) {
    cin >> n;
    for(int i = 0; i < n; i++) cin >> a[i];
    sort(a,a+n); //排序找到最大数m，大的只能由小的组成

    int m = a[n-1];
    memset(f,0,sizeof(f));
    f[0] = 1;

    int res = 0;
    for(int i = 0; i < n; i++) {
      if(!f[a[i]]) res++; //如果ai不能被凑出，则答案更新
      for(int j = a[i]; j <= m; j++) f[j] += f[j - a[i]];
    }
    cout<< res << endl;
  }
  return 0;
}
```



### （三）多重背包问题应用

#### 3.9 多重背包问题 III（困难）

**题目描述**

有 N 种物品和一个容量是 V 的背包。

第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。

**输入格式**

第一行两个整数，$N，V， (0<N≤1000, 0<V≤20000)$，用空格隔开，分别表示物品种数和背包容积。

接下来有 N 行，每行三个整数 $v_i,w_i,s_i$，用空格隔开，分别表示第 i 种物品的体积、价值和数量。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

$0<N≤1000$,
$0<V≤20000$,
$0<v_i,w_i,s_i≤20000$

**提示**

本题考查多重背包的单调队列优化方法。

**输入样例：**

```c
4 5
1 2 3
2 4 1
3 4 3
4 5 2
```

**输出样例：**

```c
10
```

**题解：**

``` c
	3） 多重背包(队列优化)：每个物品选0个，选1个，....选si个
		集合的划分:分若干组，按照第i个物品选多少个分(完全背包类似)
            0 1 2 3 4 5 .... s[i]  第i个物品选了0~k个
            注意：下面的式子是理想情况，当j不够的时候，边界情况需要额外考虑
            f(i,j)=max(f(i-1,j) , f(i-1,j-v)+w , f(i-1,j-2*v)+2w , f(i-1,j-3*v)+3w ,..f(i-1,j-s*v)+sw )
            f(i,j-v)=max(         f(i-1,j-v)   , f(i-1,j-2*v)+ w , f(i-1,j-3*v)+2w ,..         f(i-1,j-(s+1)*v)+sw )       
            	和完全背包不同的是第二个式子最后一项，是 -(s+1)*v，求j-v前面到j-sv的最大值
            f(i,j-2v)=max(                       f(i-1,j-2*v)     , f(i-1,j-3*v)+w ,..         f(i-1,j-(s+1)*v)+(s-1)*w...)  
            f(i,j-3v)=
            ........
            
            j,-v,j-2v,j-3v.....都是j mod v的余数
            设r为j mod v的余数
            r	    r+v	   r+2v	   r+3v	  r+4v	r+5v	.....	j-v		j
           -0*w    -1*w    -2*w    -3*w   -4*w   .....
            当求f[j]的时候，就是求f[j-v]前面n步的最大值（滑动窗口）
            		
		状态转移方程：f(i,j)=max(f[i][j],f[i-1][j-v[i]*k]+w[i]*k)  k=0,1,2.....s[i]
```

```c
	//滑动窗口内最小值模板
	// hh表示队头，tt表示队尾，头左尾右
    int hh = 0, tt = -1;
    for (int i = 0; i < n; i++)
    {
        //当队列不为空hh<=tt,每次判断队列头是否滑出了窗口，当前位置是i;
        //前面的k个数据的起始坐标i-k+1,不在得话则弹出队列头维持窗口大小
        //也就是删除i - k + 1 > q[hh]
        if (hh <= tt && i - k + 1 > q[hh])
            hh++;
        //构造单调队列，新的元素a[i]是否比队尾元素小，小得话则删除
        while (hh <= tt && a[q[tt]] >= a[i])
            tt--;
        //删除后将当前节点i加入到队列尾部
        q[++tt] = i;
        //每次的答案是队列头元素
        if (i >= k - 1)
            printf("%d ", a[q[hh]]);
    }
```



**代码：**

```c
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 20010;

int n, m;
int f[N], g[N], q[N];

int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i ++ )
    {
        int v, w, s;
        cin >> v >> w >> s;
        memcpy(g, f, sizeof f);
        for (int j = 0; j < v; j ++ )
        {
            int hh = 0, tt = -1;
            for (int k = j; k <= m; k += v)
            {
                //队头元素划出窗口了，队列元素已经超过s个了，则划出
                if (hh <= tt && q[hh] < k - s * v) hh ++ ;
                while (hh <= tt && g[q[tt]] - (q[tt] - j) / v * w <= g[k] - (k - j) / v * w) tt -- ;
                q[ ++ tt] = k;
                f[k] = g[q[hh]] + (k - q[hh]) / v * w;
            }
        } 
    }

    cout << f[m] << endl;

    return 0;
}
```

[推荐链接1](https://www.acwing.com/solution/content/53507/)

[推荐链接2](https://www.acwing.com/solution/content/6500/)



#### 3.10 庆功会

[Acwing 1019. 庆功会](https://www.acwing.com/problem/content/1021/)

**题目描述**

为了庆贺班级在校运动会上取得全校第一名成绩，班主任决定开一场庆功会，为此拨款购买奖品犒劳运动员。

期望拨款金额能购买最大价值的奖品，可以补充他们的精力和体力。

**输入格式**

第一行二个数n，m，其中n代表希望购买的奖品的种数，m表示拨款金额。

接下来n行，每行3个数，v、w、s，分别表示第I种奖品的价格、价值（价格与价值是不同的概念）和能购买的最大数量（买0件到s件均可）。

**输出格式**

一行：一个数，表示此次购买能获得的最大的价值（注意！不是价格）。

**数据范围**

$n≤500,m≤6000$,
$v≤100,w≤1000,s≤10$

**输入样例：**

```c
5 1000
80 20 4
40 50 9
30 50 7
40 30 6
20 20 1
```

**输出样例：**

```c
1040
```

**题解：**

``` c
分组背包
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 6010;

int n,m;
int f[N];

int main() {
  cin >> n >> m;
  for(int i = 0; i < n; i++) {
    int v,w,s;
    cin >> v >> w >> s;
    for(int j = m; j >= 0; j--) {
      for(int k = 0; k <= s && k * v <= j; k++) {
        f[j] = max(f[j],f[j-k*v]+ k * w);
      }
    }
  }
  cout << f[m] << endl;
  return 0;
}
```



### （四）二维费用的背包问题

#### 3.11 二维费用的背包问题

[Axwing 8.二维费用的背包问题](https://www.acwing.com/problem/content/8/)

**题目描述**

有 N 件物品和一个容量是 V 的背包，背包能承受的最大重量是 M。

每件物品只能用一次。体积是 $v_i$，重量是 $m_i$，价值是 $w_i$。

求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。
输出最大价值。

**输入格式**

第一行三个整数，$N,V,M$，用空格隔开，分别表示物品件数、背包容积和背包可承受的最大重量。

接下来有 N 行，每行三个整数 $v_i,m_i,w_i$，用空格隔开，分别表示第 i 件物品的体积、重量和价值。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

$0<N≤1000$
$0<V,M≤100$
$0<v_i,m_i≤100$
$0<w_i≤1000$

**输入样例：**

```c
4 5 6
1 2 3
2 4 4
3 4 5
4 5 6
```

**输出样例：**

```c
8
```

**题解：**

``` c
二维费用：
    01背包
    完全背包
    多重背包
    
DP
    (1)状态表示 f[i,j,k]
    	1)集合：所有只从前i个物品中选，并且总体积不超过j，总重量不超过k的选法
    	2)属性：Max
    (2)状态计算
    	集合表示
    	1)所有不包含物品i的选法
    		只从前i-1个中选择
    		f[i-1,j,k]
    	2)所有包含物品i的选法
    		...... 物品i	
    		...... 物品i
    		...... 物品i
			 前i-1物品：1~i-1
    		 前i-1体积: <= j- vi
             前i-1重量: <= k -mi
           f[i-1,j-vi,k-mi]+wi
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 110;

int n,V,M;
int f[N][N];

int main() {
  cin>>n>>V>>M;
  for(int i = 0; i < n; i++) {
    int v,m,w;
    cin>> v >> m >> w;
    for(int j = V; j >= v; j--) {
      for(int k = M; k >= m; k--) {
        f[j][k] = max(f[j][k],f[j - v][k - m] + w);
      }
    }
  }
  cout << f[V][M]<<endl;
  return 0;
}
```



#### 3.12 宠物小精灵之收服（二维费用-阅读理解题）

[Acwing 1022. 宠物小精灵之收服](https://www.acwing.com/problem/content/1024/)

**题目描述**

宠物小精灵是一部讲述小智和他的搭档皮卡丘一起冒险的故事。

一天，小智和皮卡丘来到了小精灵狩猎场，里面有很多珍贵的野生宠物小精灵。

小智也想收服其中的一些小精灵。

然而，野生的小精灵并不那么容易被收服。

对于每一个野生小精灵而言，小智可能需要使用很多个精灵球才能收服它，而在收服过程中，野生小精灵也会对皮卡丘造成一定的伤害（从而减少皮卡丘的体力）。

当皮卡丘的体力小于等于0时，小智就必须结束狩猎（因为他需要给皮卡丘疗伤），而使得皮卡丘体力小于等于0的野生小精灵也不会被小智收服。

当小智的精灵球用完时，狩猎也宣告结束。

我们假设小智遇到野生小精灵时有两个选择：收服它，或者离开它。

如果小智选择了收服，那么一定会扔出能够收服该小精灵的精灵球，而皮卡丘也一定会受到相应的伤害；如果选择离开它，那么小智不会损失精灵球，皮卡丘也不会损失体力。

小智的目标有两个：主要目标是收服尽可能多的野生小精灵；如果可以收服的小精灵数量一样，小智希望皮卡丘受到的伤害越小（剩余体力越大），因为他们还要继续冒险。

现在已知小智的精灵球数量和皮卡丘的初始体力，已知每一个小精灵需要的用于收服的精灵球数目和它在被收服过程中会对皮卡丘造成的伤害数目。

请问，小智该如何选择收服哪些小精灵以达到他的目标呢？

**输入格式**

输入数据的第一行包含三个整数：N，M，K，分别代表小智的精灵球数量、皮卡丘初始的体力值、野生小精灵的数量。

之后的 K 行，每一行代表一个野生小精灵，包括两个整数：收服该小精灵需要的精灵球的数量，以及收服过程中对皮卡丘造成的伤害。

**输出格式**

输出为一行，包含两个整数：C，R，分别表示最多收服C个小精灵，以及收服C个小精灵时皮卡丘的剩余体力值最多为R。

**数据范围**

$0<N≤1000$,
$0<M≤500$,
$0<K≤100$

**输入样例1：**

```c
10 100 5
7 10
2 40
2 50
1 20
4 20
```

**输出样例1：**

```c
3 30
```

**输入样例2：**

```c
10 100 5
8 110
12 10
20 10
5 200
1 110
```

**输出样例2：**

```c
0 100
```

**题解：**

``` c
花费1：精灵球数量
花费2：皮卡丘体力值
价值：小精灵的数量
     
DP
    (1)状态表示: f[i,j,k]
    1）集合：所有从前i物品中选择，且花费1不超过j，花费2不超过k的选法的最大价值
    2）属性：max
    
    (2)状态计算
    集合的划分
    不选择：f[i-1,j,k]
    选择：j-v1[i],k-v2[i]] + 1 （价值为1）
    f[i,j,k] = max(f[i-1,j,k],f[i-1,j-v1[i],k-v2[i]] + 1)
    
    最多收复的小精灵的数量f[k,N,M]
    最少耗费体力的计算 f[k,N,m] == f[k,N,M]
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 1010, M = 510;

int n, V1, V2;
int f[N][M];

int main() {
  cin>>V1>>V2>>n;
  for(int i = 0; i < n; i++) {
    int v1,v2;
    cin >> v1>> v2;
    for(int j = V1; j>= v1; j--) {
      for(int k = V2; k >= v2; k--) {
        f[j][k] = max(f[j][k],f[j-v1][k-v2]+1);
      }
    }
  }
  cout<<f[V1][V2]<<' ';
  int k = V2;
  while(k > 0 && f[V1][k-1]==f[V1][V2]) k--;
  cout<<V2-k<<endl;
  return 0;
}
```



#### 3.13 潜水员（回）

[Acwing 1020. 潜水员](https://www.acwing.com/problem/content/1022/)

**题目描述**

潜水员为了潜水要使用特殊的装备。

他有一个带2种气体的气缸：一个为氧气，一个为氮气。

让潜水员下潜的深度需要各种数量的氧和氮。

潜水员有一定数量的气缸。

每个气缸都有重量和气体容量。

潜水员为了完成他的工作需要特定数量的氧和氮。

他完成工作所需气缸的总重的最低限度的是多少？

例如：潜水员有5个气缸。每行三个数字为：氧，氮的（升）量和气缸的重量：

```
3 36 120

10 25 129

5 50 250

1 45 130

4 20 119
```

如果潜水员需要5升的氧和60升的氮则总重最小为249（1，2或者4，5号气缸）。

你的任务就是计算潜水员为了完成他的工作需要的气缸的重量的最低值。

**输入格式**

第一行有2个整数 m，n。它们表示氧，氮各自需要的量。

第二行为整数 k 表示气缸的个数。

此后的 k 行，每行包括$a_i，b_i，c_i$，3个整数。这些各自是：第 i 个气缸里的氧和氮的容量及气缸重量。

**输出格式**

仅一行包含一个整数，为潜水员完成工作所需的气缸的重量总和的最低值。

**数据范围**

$1≤m≤21$,
$1≤n≤79$,
$1≤k≤1000$,
$1≤a_i≤21$,
$1≤b_i≤79$
$1≤c_i≤800$

**输入样例：**

```c
5 60
5
3 36 120
10 25 129
5 50 250
1 45 130
4 20 119
```

**输出样例：**

```c
249
```

**题解：**

``` c
技巧一：
DP常见状态表示的体积的三种情况
1、体积最多是j
    (更新的时候必须保证v>=0)
    初始化时候，全部为0
    
2、体积恰好是j
    恰好j,k初始化(更新的时候必须保证v>=0)：
    	(1)f[0] = 0;  (合法方案)
		(2)其余的f[i] = +∞ / -1  (不合法方案)
        对应本题如果是恰好
    	f[0,0,0] = 0        (合法方案)
    	f[0,j,k] = +∞ / -1  (不合法方案)
    	j>=v1i,k>=v2i
    
3、体积至少是j(✔)
    至少j,k初始化(更新的时候没有v的限制)：
        (1)f[0] = 0;  (合法方案)
		(2)其余的f[i] = +∞ / -1  (不合法方案)
        对应本题如果是至少
    	f[0,0,0] = 0        (合法方案)
    	f[0,j,k] = +∞ / -1  (不合法方案)
    	j>=v1i,k>=v2i -->合法
    	j<=v1i,k<=v2i -->此时也合法
            
技巧二：
for 物品
	for 体积
		for 决策(划分子集)
     从i-1转移到i的，遍历体积的时候，从大到小循环
     从i转移到i-1的，遍历体积的时候，从小到大循环

需要特定数量的氧和氮。
氧气：费用1 >= m
氮气：费用2 >= n
价值：重量   最小值
    
DP
    (1)状态表示 f[i][j][k]
    	1)集合：所有只从前i个物品中选，并且氧气含量至少是j，氮气含量至少是k的所有选法
    	2)属性：Min
    (2)状态计算
    	集合表示
    	1)所有不含物品i的所有选法
    		f[i-1][j][k]
    	2)所有包含物品i的所有选法
    		f[i-1][j-v1i][k-v2i] + wi	
    
    二维费用模板的时候：
    不超过：
    	f[0,j,k] = 0		(合法方案)
    
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;
const int N = 22, M = 80;   

int n,m,K;
int f[N][M];

int main() {
  cin >> n >> m >> K;
  memset(f, 0x3f, sizeof f);
  f[0][0] = 0;

  while(K--) {
    int v1 , v2, w;
    cin >> v1 >> v2 >> w;
    for(int j = n; j >= 0; j--) {
      for(int k = m; k >= 0; k--) {
        f[j][k] = min(f[j][k],f[max(0,j-v1)][max(0,k-v2)] + w);
      }
    }
  }
  cout<<f[n][m]<<endl;
  return 0;
}
```



### （五）分组背包应用

#### 3.14 金明的预算方案（回）

[Acwing 487. 金明的预算方案](https://www.acwing.com/problem/content/489/)

**题目描述**

金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。

更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过N元钱就行”。

今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：

![](https://cdn.acwing.com/media/article/image/2019/03/13/19_45c6dcea44-QQ%E6%88%AA%E5%9B%BE20190313024710.png)

如果要买归类为附件的物品，必须先买该附件所属的主件。

每个主件可以有0个、1个或2个附件。

附件不再有从属于自己的附件。

金明想买的东西很多，肯定会超过妈妈限定的N元。

于是，他把每件物品规定了一个重要度，分为5等：用整数1~5表示，第5等最重要。

他还从因特网上查到了每件物品的价格（都是10元的整数倍）。

他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。

设第j件物品的价格为v[j]，重要度为w[j]，共选中了k件物品，编号依次为$j_1，j_2，…，j_k$，则所求的总和为：

$v[j_1]∗w[j_1]+v[j_2]∗w[j_2]+…+v[j_k]∗w[j_k]$（其中*为乘号）

请你帮助金明设计一个满足要求的购物单。

**输入格式**

输入文件的第1行，为两个正整数，用一个空格隔开：N m，其中N表示总钱数，m为希望购买物品的个数。

从第2行到第m+1行，第j行给出了编号为j-1的物品的基本数据，每行有3个非负整数v p q，其中v表示该物品的价格，p表示该物品的重要度（1~5），q表示该物品是主件还是附件。

如果q=0，表示该物品为主件，如果q>0，表示该物品为附件，q是所属主件的编号。

**输出格式**

输出文件只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（<200000）。

**数据范围**

$N<32000,m<60,v<10000$

**输入样例：**

```c
1000 5
800 2 0
400 5 1
300 5 1
400 3 0
500 2 0
```

**输出样例：**

```c
2200
```

**题解：**

``` c
每个主件和附件是一组：
    主件->附件1、附件2
    分组：
    	主件
    	主件、附件1
    	主件、附件2
    	主件、附件1、附件2
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <vector>

#define v first
#define w second

using namespace std;

typedef pair<int,int> PII;

const int N =70, M = 32010;

int n, m;
PII master[N];
vector<PII> servent[N];
int f[M];

int main() {
  cin >> m >> n;
  for(int i = 1; i <= n; i++) {
    int v,w,q;
    cin>>v>>w>>q;
    if(!q) master[i] = {v,v*w};
    else servent[q].push_back({v,v*w});
  }

  for(int i = 1; i <= n; i++) {
    if(master[i].v) {
      for(int j = m; j >=0; j--) {
        auto &sv = servent[i];
        for(int k = 0; k < 1<< sv.size(); k++) {
          int v = master[i].v, w = master[i].w;
          for(int u  =0; u < sv.size(); u++) {
            if(k>>u & 1){ //k的第u位是1，则包含该物品
              v+=sv[u].v;
              w+=sv[u].w;
            }
          }
          if(j >= v) f[j] = max(f[j],f[j-v]+w);
        }
      }
    }
  }
  cout<< f[m] << endl;
  return 0;
}
```



### （六）背包问题求具体方案

####  3.15 背包问题求具体方案

[Acwing 12. 背包问题求具体方案](https://www.acwing.com/problem/content/12/)

**题目描述**

有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。

第 i 件物品的体积是 $v_i$，价值是 $w_i$。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

输出 **字典序最小的方案**。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是 $1…N$。

**输入格式**

第一行两个整数，$N，V$，用空格隔开，分别表示物品数量和背包容积。

接下来有 N 行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 i 件物品的体积和价值。

**输出格式**

输出一行，包含若干个用空格隔开的整数，表示最优解中所选物品的编号序列，且该编号序列的字典序最小。

物品编号范围是 $1…N$。

**数据范围**

$0<N,V≤1000$,
$0<v_i,w_i≤1000$

**输入样例：**

```c
4 5
1 2
2 4
3 4
4 6
```

**输出样例：**

```c
1 4
```

**题解：**

``` c
状态转移：f[i][j] = max(f[i-1][j],f[i-1][j-v[i]]+ w[i])
最终求:f[n][m]
    
求背包问题具体的方案其实就是判断出每个物品是否被选
-> 最短路问题，求最短路径 
	f[n-1][m]
    	       \ 
    			   f[n][m]
    	       /
f[n-1][m-v[n]] (对应权重为w[n])
看f[n][m]和哪个相等，相等则是从前一个状态转移过来的
f[n][m] = f[n-1][m]
    	= f[n-1][m-v[n]] + w[n]
    	= 上面两个都可以
    
三种情况：
    1、只能选  必选
    2、只能不选 必不选
    3、可选/可不选  一定选择第一个
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 1010;

int n,m;
int v[N], w[N];
int f[N][N];

int main() {
  cin >> n >> m;
  for(int i = 1; i <= n; i++) cin >> v[i] >> w[i];

  //倒着来推导，需要先把v和w 读进来
  for(int i = n; i >= 1; i--) {
    for(int j = 0; j <= m; j++) {
      f[i][j] = f[i+1][j];
      if(j >= v[i]) 
        f[i][j] = max(f[i][j], f[i+1][j-v[i]] + w[i]);
    }
  }

  int j = m;
  for(int i = 1; i <= n; i++) {
    if(j >= v[i] && f[i][j] == f[i+1][j-v[i]] + w[i]){
      cout<< i << ' ';
      j -= v[i];
    }
  }
  return 0;
}
```



#### 3.16 机器分配（多重背包+方案数）

[Acwing 1013. 机器分配](https://www.acwing.com/problem/content/1015/)

**题目描述**

总公司拥有 M 台 **相同** 的高效设备，准备分给下属的 N 个分公司。

各分公司若获得这些设备，可以为国家提供一定的盈利。盈利与分配的设备数量有关。

问：如何分配这 M 台设备才能使国家得到的盈利最大？

求出最大盈利值。

分配原则：每个公司有权获得任意数目的设备，但总台数不超过设备数 M。

**输入格式**

第一行有两个数，第一个数是分公司数 N，第二个数是设备台数 M；

接下来是一个 $N×M$ 的矩阵，矩阵中的第 i 行第 j 列的整数表示第 i 个公司分配 j 台机器时的盈利。

**输出格式**

第一行输出最大盈利值；

接下 N 行，每行有 2 个数，即分公司编号和该分公司获得设备台数。

答案不唯一，输出任意合法方案即可。

**数据范围**

$1≤N≤10$,
$1≤M≤15$

**输入样例：**

```c
3 3
30 40 50
20 30 50
20 25 30
```

**输出样例：**

```c
70
1 1
2 1
3 1
```

**题解：**

``` c
将每个公司看作物品组：
    公司1：				体积			价值
    	分配1台			 1			  30
    	分配2台			 2			  40
    	......
    	分配s台			 s
    公司2：
    	分配1台			 1			  20
    	分配2台			 2			  30
    	......
    	分配s台
    公司3：
    	分配1台			 1			  20
    	分配2台			 2			  25
    	......
    	分配s台
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 11, M = 16;

int n,m;
int w[N][N];
int f[N][M];
int way[N];

int main() {
  cin >> n >> m;
  for(int i = 1; i <= n; i++) {
    for(int j = 1; j <= m; j++) {
      cin >> w[i][j];
    }
  }
  // for(int i = 1; i <= n; i++) {   //物品
  //   for(int j = 1; j <= m; j++) { //体积
  //     f[i][j] = f[i-1][j];  //不选第i个物品
  //     for(int k = 1; k <= j; k++) { //第i个物品选k个
  //       f[i][j] = max(f[i][j],f[i-1][j-k]+w[i][k]);
  //     }
  //   }
  // }
  //合并
  for(int i = 1; i <= n; i++) {   //物品
    for(int j = 1; j <= m; j++) { //体积
      for(int k = 0; k <= j; k++) { //第i个物品选k个
        f[i][j] = max(f[i][j],f[i-1][j-k]+w[i][k]);
      }
    }
  }

  cout<< f[n][m] << endl;

  int j = m;
  for(int i = n; i; i--) {
    for(int k = 0; k <= j; k++) {
      if(f[i][j] == f[i-1][j-k]+w[i][k]) {
        way[i] = k;
        j-=k;
        break;
      }
    }
  }

  for(int i = 1; i <= n; i++) cout<<i<<' '<<way[i]<<endl;
  return 0;
}
```

#### 3.17 背包问题求方案数

[Acwing 11. 背包问题求方案数](https://www.acwing.com/problem/content/11/)

**题目描述**

有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。

第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

输出 **最优选法的方案数**。注意答案可能很大，请输出答案模 $10^9+7$ 的结果。

**输入格式**

第一行两个整数，$N，V$，用空格隔开，分别表示物品数量和背包容积。

接下来有 $N$ 行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第$i$ 件物品的体积和价值。

**输出格式**

输出一个整数，表示 **方案数** 模 $10^9+7$ 的结果。

**数据范围**

$0<N,V≤1000$,
$0<v_i,w_i≤1000$

**输入样例：**

```c
4 5
1 2
2 4
3 4
4 6
```

**输出样例：**

```c
2
```

**题解：**

``` c
f[i][j] = max(f[i-1][j],f[i-1][j-vi]+wi)
    
g[i][j]表示f[i][j]取最大值的方案数
    
f[i][j]
    (1)不选第i个物品，f[i-1][j]
    (2)选第i个物品，f[i-1][j-vi]+wi
f[i][j]导致g[i][j]三种情况
    (1)f[i-1][j] > f[i-1][j-vi]+wi ,则g[i-1][j]
    (2)f[i-1][j] < f[i-1][j-vi]+wi ,则g[i-1][j-vi]
    (3)f[i-1][j] = f[i-1][j-vi]+wi ,则g[i-1][j]+g[i-1][j-vi]
```

**代码：**

```c
#include <cstring>
#include <iostream>

using namespace std;

const int N = 1010, mod = 1e9 + 7;

int n, m;
int f[N], g[N];

int main()
{
    cin >> n >> m;

    memset(f, -0x3f, sizeof f);
    f[0] = 0;
    g[0] = 1;

    for (int i = 0; i < n; i ++ )
    {
        int v, w;
        cin >> v >> w;
        for (int j = m; j >= v; j -- )
        {
            int maxv = max(f[j], f[j - v] + w);
            int s = 0;
            if (f[j] == maxv) s = g[j];
            if (f[j - v] + w == maxv) s = (s + g[j - v]) % mod;
            f[j] = maxv, g[j] = s;
        }
    }

    int res = 0;
    for (int i = 1; i <= m; i ++ )
        if (f[i] > f[res])
            res = i;

    int sum = 0;
    for (int i = 0; i <= m; i ++ )
        if (f[i] == f[res])
            sum = (sum + g[i]) % mod;

    cout << sum << endl;

    return 0;
}
```

 	

### （七）混合背包问题

#### 3.18 混合背包问题

[Acwing 7. 混合背包问题](https://www.acwing.com/problem/content/7/)

**题目描述**

有 N 种物品和一个容量是 V 的背包。

物品一共有三类：

- 第一类物品只能用 1 次（01背包）；
- 第二类物品可以用无限次（完全背包）；
- 第三类物品最多只能用 $s_i$ 次（多重背包）；

每种体积是 $v_i$，价值是 $w_i$。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。

**输入格式**

第一行两个整数，$N，V$，用空格隔开，分别表示物品种数和背包容积。

接下来有 $N$ 行，每行三个整数 $v_i,w_i,s_i$，用空格隔开，分别表示第 i 种物品的体积、价值和数量。

- $s_i=−1$表示第 i 种物品只能用1次；
- $s_i=0$ 表示第 i 种物品可以用无限次；
- $s_i>0$ 表示第 i 种物品可以使用 $s_i$ 次；

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

$0<N,V≤1000$,
$0<v_i,w_i≤1000$.
$−1≤s_i≤1000$

**输入样例：**

```c
4 5
1 2 -1
2 4 1
3 4 0
4 5 2
```

**输出样例：**

```c
8
```

**题解：**

``` c
DP
    (1)状态表示f[i][j]
    	1)集合：只从前i件物品中选，且总体积不超过j的选法
    	2)属性：Max
    (2)状态计算：
    	1)01背包：f[i][j] = max(f[i-1][j], f[i-1][j-v[i]]+w[i])
    	2)完全背包：f[i][j] = max(f[i-1][j],f[i][j-v[i]]+w[i])
    	3)多重背包：f[i][j] = max(f[i-1][j],f[i-1][j-v[i]]+w[i],f[i-1][j-2*v[i]]+2*w[i]+...)
    
```

**代码：**

```c
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int n,m;
int f[N];

int main() {
  cin >> n >> m;
  for(int i = 0; i < n; i++) {
    int v, w, s;
    cin >> v >> w >> s;
    if(s == 0){  //完全背包
      for(int j = v; j <= m; j++) f[j] = max(f[j], f[j-v]+w);
    } 
    else{
      //01背包相当于特殊的完全背包
      if(s == -1) s = 1;
      //二进制优化
      for(int k = 1; k <= s; k*=2) {
        for(int j = m; j >= k * v; j--) {
          f[j] = max(f[j],f[j-k  *v]+k * w);
        }
        s-=k;
      }
      if(s) {
        for(int j = m; j >= s * v; j--){
          f[j] = max(f[j], f[j - s * v] + s * w);
        }
      }
    }
  }
  cout << f[m] << endl;
}
```



### （八）有依赖的背包问题

#### 3.19 有依赖的背包问题

[AcWing 10. 有依赖的背包问题](https://www.acwing.com/problem/content/10/)

**题目描述**

有 $N$ 个物品和一个容量是 $V$ 的背包。

物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。

如下图所示：

![](https://www.acwing.com/media/article/image/2018/10/18/1_bb51ecbcd2-QQ%E5%9B%BE%E7%89%8720181018170337.png)

如果选择物品5，则必须选择物品1和2。这是因为2是5的父节点，1是2的父节点。

每件物品的编号是 $i$，体积是 $v_i$，价值是 $w_i$，依赖的父节点编号是 $p_i$。物品的下标范围是 $1…N$。

求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。

输出最大价值。

**输入格式**

第一行有两个整数 $N，V$，用空格隔开，分别表示物品个数和背包容量。

接下来有 $N$ 行数据，每行数据表示一个物品。
第 $i$ 行有三个整数 $v_i,w_i,p_i$，用空格隔开，分别表示物品的体积、价值和依赖的物品编号。
如果 $p_i=−1$，表示根节点。 **数据保证所有物品构成一棵树。**

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

$1≤N,V≤100$,
$1≤v_i,w_i≤100$

父节点编号范围：

- 内部结点：$1≤p_i≤N$;
- 根节点 $p_i=−1$;

**输入样例：**

```c
5 7
2 3 -1
2 2 1
3 5 1
4 7 2
3 6 2
```

**输出样例：**

```c
11
```

**题解：**

``` c
DP
    (1)状态表示f[u][j]
    	1)集合：所有从以u为根的子树中选,且总体积不超过j的方案
    	2)属性：Max
    (2)状态计算：
    	1)子树1
    		里面包含K棵子树，有2^k选择
    		按照体积继续划分0~m
    		
    	2)子树2
    	3)子树3
```

**代码：**

```c
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;

int n, m;
int v[N], w[N];
int h[N], e[N], ne[N], idx;
int f[N][N];

void add(int a,int b) {
  e[idx] = b, ne[idx]  = h[a], h[a] = idx++;
}

void dfs(int u) {
  for(int i = h[u]; ~i; i = ne[i]) { //循环物品组
    int son = e[i];
    dfs(e[i]);

    //分组背包
    for(int j = m - v[u]; j >= 0; j--){  //循环体积
      for(int k = 0; k <= j; k++) { // 循环决策
        f[u][j] = max(f[u][j], f[u][j-k]+f[son][k]);
      }
    }
  }
  //将物品U加进去
  for(int i = m; i >= v[u]; i--) f[u][i] = f[u][i-v[u]] + w[u];
  for(int i = 0; i < v[u]; i++) f[u][i] = 0;
}

int main() {
  cin >> n >> m;

  memset(h, -1, sizeof h);
  int root;
  for(int i = 1; i <= n; i++) {
    int p;
    cin >> v[i] >> w[i] >> p;
    if(p == -1) root = i;
    else add(p, i);
  }

  dfs(root);

  cout<< f[root][m] << endl;
  return 0;
}
```



### 4、状态机模型

#### 4.1 大盗阿福

[AcWing 1049. 大盗阿福](https://www.acwing.com/problem/content/1051/)

**题目描述**

阿福是一名经验丰富的大盗。趁着月黑风高，阿福打算今晚洗劫一条街上的店铺。

这条街上一共有 N 家店铺，每家店中都有一些现金。

阿福事先调查得知，只有当他同时洗劫了两家相邻的店铺时，街上的报警系统才会启动，然后警察就会蜂拥而至。

作为一向谨慎作案的大盗，阿福不愿意冒着被警察追捕的风险行窃。

他想知道，在不惊动警察的情况下，他今晚最多可以得到多少现金？

**输入格式**

输入的第一行是一个整数 T，表示一共有 T 组数据。

接下来的每组数据，第一行是一个整数 N ，表示一共有 N 家店铺。

第二行是 N 个被空格分开的正整数，表示每一家店铺中的现金数量。

每家店铺中的现金数量均不超过1000。

**输出格式**

对于每组数据，输出一行。

该行包含一个整数，表示阿福在不惊动警察的情况下可以得到的现金数量。

**数据范围**

$1≤T≤50$,
$1≤N≤10^5$

**输入样例：**

```c
2
3
1 8 2
4
10 7 6 14
```

**输出样例：**

```c
8
24
```

**样例解释**

对于第一组样例，阿福选择第2家店铺行窃，获得的现金数量为8。

对于第二组样例，阿福选择第1和4家店铺行窃，获得的现金数量为10+14=24。

**题解：**

``` 
DP
    (1)状态表示：f[i]
    	1)集合：f[i]表示前i家的最大收益
    	2)属性：Max
    (2)状态计算
    	1)抢劫第i家店铺
    		...... i-1 i
    		...... i-1 i
    		...... i-1 i
    		...... i-1 i
    		i-1必定不选
    		f[i-2]+w[i]
    	2)不抢劫第i家店铺
    		f[i-1]
状态机
    f[i]:	f[i][0]  表示未选最后一个店铺
    		f[i][1]	 表示选择最后一个店铺
    		0-(不选)->0
    		0-(选)->1-(不选)->0
    (1)状态表示：f[i][0]、f[i][1]
    	1)集合：表示所有走了i步，且当前位于状态j的所有走法
    	2)属性：Max
    (2)状态计算
    	f[i][0]
    	1)最后一步0->0
    		f[i-1][0]
    	2)最后一步1->0
    		f[i-1][1]
    		
    	f[i][1]
    	3)最后一步1->0
    		f[i-1][0]+w[i]
    		
    初始化虚拟入口可以到0到1
    f[0][0] = 0
    f[0][1] = -INF
```

**代码：**

```c
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 100010, INF = 0x3f3f3f3f;
int w[N],f[N][2];

int main() {
    int T;
    scanf("%d",&T);
    while(T--) {
        int n;
        scanf("%d",&n);
        for(int i = 1; i <= n; i++) scanf("%d",&w[i]);
        f[0][0] = 0, f[0][1] = -INF;
        for(int i = 1; i <= n; i++) {
            f[i][0] = max(f[i-1][0],f[i-1][1]);
            f[i][1] = f[i-1][0] + w[i];
        }
        printf("%d\n",max(f[n][0],f[n][1]));
    }
    return 0;
}
```



#### 4.2 股票买卖 IV

[AcWing 1057. 股票买卖 IV](https://www.acwing.com/problem/content/1059/)

**题目描述**

给定一个长度为 N 的数组，数组中的第 i 个数字表示一个给定股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润，你最多可以完成 k 笔交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。一次买入卖出合为一笔交易。

**输入格式**

第一行包含整数 N 和 k，表示数组的长度以及你可以完成的最大交易笔数。

第二行包含 N 个不超过 10000 的正整数，表示完整的数组。

**输出格式**

输出一个整数，表示最大利润。

**数据范围**

$1≤N≤10^5$,
$1≤k≤100$

**输入样例1：**

```c
3 2
2 4 1
```

**输出样例1：**

```c
2
```

**输入样例2：**

```c
6 2
3 2 6 5 0 3
```

**输出样例2：**

```c
7
```

**样例解释**

样例1：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。

样例2：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。共计利润 4+3 = 7.

**题解：**

``` 
股票状态机
    (1)手中有货1
    (2)手中无货0
    1-(不卖：权重0)->1
    	f[i-1][j][1]
    1-(卖：权重+w[i])->0-(买：权重-w[i])->1
    	1-(卖：权重+w[i])->0
    		f[i-1][j][1]+w[i]
    	0-(买：权重-w[i])->1
    		f[i-1][j-1][0]-w[i]
    		开始买算一次交易
    0-(不买：权重0)->0
    	f[i-1][j][0]
    
DP
	(1)状态表示 f[i][j][0]、f[i][j][1]
		1)集合:所有只考虑前i天，正在进行第j次交易，买入或卖出的所有方法
		2)属性：最大值
	(2)状态计算
		f[i][j][0] = max(f[i-1][j][0], f[i-1][j][1]+w[i])
		f[i][j][1] = max(f[i-1][j][1],f[i-1][j-1][0]-w[i])
		
	(3)初始状态无货
		f[0][0][0] = 0
		f[0][0][1] = -INF
		j = 0
		f[i][0][0] = 0
		f[i][0][1] = -INF
```

**代码：**

```c
/*
 * @Descripttion: 
 * @version: 
 * @Author: ZKYAAA
 * @Date: 2023-08-07 12:06:17
 * @LastEditors: 请叫我ZK谕啊啊啊
 * @LastEditTime: 2023-08-07 12:27:22
 */
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 100010, M = 110, INF = 0x3f3f3f3f;

int n, m;
int w[N];
int f[N][M][2];

int main() {
    scanf("%d%d",&n,&m);
    for(int i = 1; i <= n; i++) scanf("%d",&w[i]);

    // j = 0的时候，没有股票的时候是合法的
    memset(f, -0x3f, sizeof f);
    for(int i = 0; i <= n; i++) f[i][0][0] = 0;

    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= m; j++){
            f[i][j][0] = max(f[i-1][j][0], f[i-1][j][1]+w[i]);
		    f[i][j][1] = max(f[i-1][j][1],f[i-1][j-1][0]-w[i]);
        }
    }

    // 更新答案，最后的状态应该是没有股票
    int res = 0;
    for(int i = 0; i <= m; i++) res = max(res,f[n][i][0]);

    printf("%d\n",res);
    return 0;
}
```



#### 4.3 股票买卖 V

[AcWing 1058. 股票买卖 V](https://www.acwing.com/activity/content/problem/content/1289/)

**题目描述**

给定一个长度为 N 的数组，数组中的第 i 个数字表示一个给定股票在第 i 天的价格。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**输入格式**

第一行包含整数 N，表示数组长度。

第二行包含 N 个不超过 10000 的正整数，表示完整的数组。

**输出格式**

输出一个整数，表示最大利润。

**数据范围**

$1≤N≤10^5$

**输入样例：**

```c
5
1 2 3 0 2
```

**输出样例：**

```c
3
```

**样例解释**

对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]，第一笔交易可得利润 2-1 = 1，第二笔交易可得利润 2-0 = 2，共得利润 1+2 = 3。

**题解：**

``` c
手中有货（0）
    手中无货得第1天 （1）
    	手中无货的第>=2天	（2）
    
0-（权重0）->0
    0-（权重+w[i]）->1
    	1-（权重+0）->2 （出口1）
    		2-（权重0）->2(入口)（出口2）
    2-（权重-w[i]）->0
    
f[i][0] = max(f[i-1][0],f[i-1][2]-w[i])
f[i][1] = f[i-1][0] + w[i]
f[i][2] = max(f[i-1][1],f[i-1][2])
```

**代码：**

```c
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;
const int N = 100010, INF = 0x3f3f3f3f;

int n;
int w[N];
int f[N][3];

int main() {
    scanf("%d",&n);
    for(int i = 1; i <= n; i++) scanf("%d",&w[i]);

    //第0天有货f[0][0]和第0天手中无货的第1天，无效
    f[0][0] = f[0][1] = -INF;
    f[0][2] = 0;    //入口

    for(int i = 1; i <= n; i++) {
        f[i][0] = max(f[i-1][0],f[i-1][2]-w[i]);
        f[i][1] = f[i-1][0] + w[i];
        f[i][2] = max(f[i-1][1],f[i-1][2]);
    }

    printf("%d\n",max(f[n][1],f[n][2]));
    return 0;
}
```



#### 4.4 设计密码（KMP+DP+回）

[AcWing 1052. 设计密码](https://www.acwing.com/problem/content/1054/)

**题目描述**

你现在需要设计一个密码 S，S 需要满足：

- S 的长度是 N；
- S 只包含小写英文字母；
- S 不包含子串 T；

例如：abc 和 abcde 是 abcde 的子串，abd 不是 abcde 的子串。

请问共有多少种不同的密码满足要求？

由于答案会非常大，请输出答案模 $10^9+7$ 的余数。

**输入格式**

第一行输入整数N，表示密码的长度。

第二行输入字符串T，T中只包含小写字母。

**输出格式**

输出一个**正整数**，表示总方案数模  $10^9+7$  后的结果。

**数据范围**

$1≤N≤50$,
$1≤|T|≤N，|T|$是$T$的长度。

**输入样例1：**

```c
2
a
```

**输出样例1：**

```c
625
```

**输入样例2：**

```c
4
cbc
```

**输出样例2：**

```c
456924
```

**题解：**

``` c
str len=m
    KMP指针j = 0;
		0,1,2,3,4,......m
        把j的跳的m步骤当作状态，起点入口0，不能跳到m，其他任意跳
```

**代码：**

```c
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 55, mod = 1e9 + 7;

int n, m;
char str[N];
int nxt[N];
int f[N][N];

int main()
{
    cin >> n >> str + 1;

    m = strlen(str + 1);

    for (int i = 2, j = 0; i <= m; i ++ )
    {
        while (j && str[i] != str[j + 1]) j = nxt[j];
        if (str[i] == str[j + 1]) j ++ ;
        nxt[i] = j;
    }

    f[0][0] = 1;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < m; j ++ )
            for (char k = 'a'; k <= 'z'; k ++ )
            {
                int u = j;
                while (u && k != str[u + 1]) u = nxt[u];
                if (k == str[u + 1]) u ++ ;
                if (u < m) f[i + 1][u] = (f[i + 1][u] + f[i][j]) % mod;
            }

    int res = 0;
    for (int i = 0; i < m; i ++ ) res = (res + f[n][i]) % mod;

    cout << res << endl;

    return 0;
}
```



#### 4.5 修复DNA(todo)-（AC自动机-Trie树+KMP+DP）

[AcWing 1053. 修复DNA](https://www.acwing.com/problem/content/1055/)

**题目描述**

生物学家终于发明了修复DNA的技术，能够将包含各种遗传疾病的DNA片段进行修复。

为了简单起见，DNA看作是一个由’A’, ‘G’ , ‘C’ , ‘T’构成的字符串。

修复技术就是通过改变字符串中的一些字符，从而消除字符串中包含的致病片段。

例如，我们可以通过改变两个字符，将DNA片段”AAGCAG”变为”AGGCAC”，从而使得DNA片段中不再包含致病片段”AAG”，”AGC”，”CAG”，以达到修复该DNA片段的目的。

需注意，被修复的DNA片段中，仍然只能包含字符’A’, ‘G’ , ‘C’ , ‘T’。

请你帮助生物学家修复给定的DNA片段，并且修复过程中改变的字符数量要尽可能的少。

**输入格式**

输入包含多组测试数据。

每组数据第一行包含整数N，表示致病DNA片段的数量。

接下来N行，每行包含一个长度不超过20的非空字符串，字符串中仅包含字符’A’, ‘G’ , ‘C’ , ‘T’，用以表示致病DNA片段。

再一行，包含一个长度不超过1000的非空字符串，字符串中仅包含字符’A’, ‘G’ , ‘C’ , ‘T’，用以表示待修复DNA片段。

最后一组测试数据后面跟一行，包含一个0，表示输入结束。

**输出格式**

每组数据输出一个结果，每个结果占一行。

输入形如”Case x: y”，其中x为测试数据编号（从1开始），y为修复过程中所需改变的字符数量的最小值，如果无法修复给定DNA片段，则y为”-1”。	

**数据范围**

$1≤N≤50$

**输入样例：**

```c
2
AAA
AAG
AAAG    
2
A
TG
TGAATG
4
A
G
C
T
AGT
0
```

**输出样例：**

```c
Case 1: 1
Case 2: 4
Case 3: -1
```

**题解：**

``` c

```

**代码：**

```c

```



### 5、状态压缩DP

```
状态压缩DP
(1)棋盘式（基于连通性）
(2)集合
```

#### 5.1 小国王

[AcWing 1064. 小国王](https://www.acwing.com/problem/content/1066/)

**题目描述**

在 n×n 的棋盘上放 k 个国王，国王可攻击相邻的 8 个格子，求使它们无法互相攻击的方案总数。

**输入格式**

共一行，包含两个整数 n 和 k。

**输出格式**

共一行，表示方案总数，若不能够放置则输出0。

**数据范围**

$1≤n≤10$,
$0≤k≤n^2$

**输入样例：**

```c
3 2
```

**输出样例：**

```c
16
```

**题解：**

``` c
棋盘式状态压缩DP
    (1)状态表示: f[i][j][s]
    	1)集合：所有只摆在前i行,已经摆了j个国王，并且第i行摆放的状态是s的所有方案的集合
    	2)属性:Count
    (2)状态计算：
        上一行共2^n次种划分
        性质：
            ① 第i-1行内部不能有两个1相邻
            ② 第i-1行和第i行之间也不能相互攻击到(附近八个位置)
            b(i-1行状态)： 01010
            a(i行状态)	 ： 00101
            (a & b) == 0
            (a | b) 不能有两个相邻的1
        1)第i行当前状态f[i][j][a]：
            已经摆完了前i行，并且第i行的状态是a，第i-1的状态是b的所有方案
        2)第i-1行也就是最后一行去掉：
            count(a)表示第i行1的个数
            已经摆完了前i-1行，并且第i-1行状态是b，已经摆了j-count(a)个国王的所有的方案
            f[i-1][j-count(a)][b]
```

**代码：**

```c
/*
 * @Descripttion: 
 * @version: 
 * @Author: ZKYAAA
 * @Date: 2023-08-08 09:54:56
 * @LastEditors: 请叫我ZK谕啊啊啊
 * @LastEditTime: 2023-08-08 11:11:09
 */
#include <iostream>
#include <algorithm>
#include <cstring>
#include <vector>

using namespace std;
typedef long long LL;
const int N = 12, M = 1 << 10, K = 110;

int n, m;   //  m国王数量
vector<int> state;  // 所有合法状态
// int id[M];  //id表示每个状态和下标之间映射关系
int cnt[M]; // cnt表示每个状态1的个数
vector<int> head[M];    // 每个状态所有可以转移到的其他状态
LL f[N][K][M]; 

// 检查是否合法，存在两个连续的1不合法
bool check(int state) {
    for(int i = 0; i < n; i++) {
        if((state >> i & 1) && (state >> i+1 & 1))
            return false;
    }
    return true;
}

int count(int state) {
    int res = 0;
    for(int i = 0; i < n; i++) res += state >> i & 1;
    return res;
}

int main() {
    cin >> n >> m;
    for(int i = 0; i < 1<<n; i++) {
        if(check(i)) {
            state.push_back(i);
            // id[i] = state.size()-1; //  合法方案对应的下标是多少
            cnt[i] = count(i); //i里面1的个数
        }
    }

    //不同状态边与边之间的关系
    for(int i = 0; i < state.size(); i++) {
        for(int j = 0; j < state.size(); j++){
            //a是第i行状态，b是i-1行状态
            int a = state[i], b = state[j];
            //预处理哪些状态可以转移
            if((a & b) == 0 && check(a | b))
                head[i].push_back(j);   //  合法则将b的方案加到a里面,下标
        }
    }

    //所有只摆在前i行,已经摆了j个国王，并且第i行摆放的状态是s的所有方案的集合
    f[0][0][0] = 1;
    for(int i = 1; i <= n + 1; i++) {
        for(int j = 0; j <= m; j++) {
            for(int a = 0; a < state.size(); a++) {
                for(int b : head[a]) {
                    int c = cnt[state[a]];  //  a里面1的个数
                    if( j >= c) {   //当前i行的国王数量要满足要求
                        f[i][j][a] += f[i-1][j-c][b];
                    }
                }
            }
        }
    }
    //假设有n+1行，实际第n+1行没有摆放，第n+1行已经计算过了，同时需要用到11，所以N开12
    cout << f[n+1][m][0] << endl;
    return 0;
}
```



#### 5.2 玉米田

[AcWing 327. 玉米田](https://www.acwing.com/problem/content/329/)

**题目描述**

农夫约翰的土地由 M×N 个小方格组成，现在他要在土地里种植玉米。

非常遗憾，部分土地是不育的，无法种植。

而且，相邻的土地不能同时种植玉米，也就是说种植玉米的所有方格之间都不会有公共边缘。

现在给定土地的大小，请你求出共有多少种种植方法。

土地上什么都不种也算一种方法。

**输入格式**

第 1 行包含两个整数 M 和 N。

第 2..M+1 行：每行包含 N 个整数 0 或 1，用来描述整个土地的状况，1 表示该块土地肥沃，0 表示该块土地不育。

**输出格式**

输出总种植方法对 $10^8$ 取模后的值。

**数据范围**

$1≤M,N≤12$

**输入样例：**

```c
2 3
1 1 1
0 1 0
```

**输出样例：**

```c
9
```

**题解：**

``` c
棋盘式状态压缩DP
    (1)状态表示:f[i][s]
    	1) 集合：所有已经摆完前i行，且第i行的状态是s的所有摆放方案的集合
    	2) 属性：Count
    (2)状态计算
    	划分依据，最后一个状态
    	1) a,b的二进制表示中不包含连续两个1
    	2) (a & b) == 0 上下左右不相邻
    	
    	集合划分
    	1) 已经摆完前i行，且第i行的状态是a ， 第i-1行的状态是b的所有摆放方案
    	2) 已经摆放完前i-1行，且第i-1行的状态是b的所有摆放方案
    		f[i-1][b]
```

**代码：**

```c
/*
 * @Descripttion: 
 * @version: 
 * @Author: ZKYAAA
 * @Date: 2023-08-08 11:29:28
 * @LastEditors: 请叫我ZK谕啊啊啊
 * @LastEditTime: 2023-08-08 11:59:20
 */
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>

using namespace std;
const int N = 14, M = 1 << 12, mod = 1e8;

int n, m;
int g[N];   //状态f[i][s]是否合法，当中有的1是不能枚举的
vector<int> state;  // 所有合法状态
vector<int> head[M];    // 每个状态所有可以转移到的其他状态
int f[N][M]; 

// 检查是否合法，存在两个连续的1不合法
bool check(int state) {
    for(int i = 0; i < m; i++) {
        if((state >> i & 1) && (state >> i + 1 & 1))
            return false;
    }
    return true;
}

int main() {
    cin >> n >> m;
    for(int i = 1; i <= n; i++) {
        for(int j = 0; j < m; j++) {
            int t;
            cin >> t;
            g[i] += !t << j;    //是0的话置为1，表示该位置不可选
        }
    }

    for(int i = 0; i < 1 << m; i++) {
        if(check(i)) {
            state.push_back(i);
        }
    }

    //不同状态边与边之间的转移关系
    for(int i = 0; i < state.size(); i++) {
        for(int j = 0; j < state.size(); j++) {
            //a是第i行状态，b是i-1行状态
            int a = state[i], b = state[j];
            //预处理哪些状态可以转移
            if((a & b) == 0) {
                head[i].push_back(j);   //合法则将b的方案加到a里面(存下标)
            }
        }
    }

    f[0][0] = 1;
    for(int i = 1; i <= n+1; i++) {
        for(int a = 0; a < state.size(); a++) {
            for(int b : head[a]) {
                if(g[i] & state[a]) continue;   //田地不满足,摆放玉米和田冲突
                f[i][a] =(f[i][a] + f[i-1][b]) % mod;
            }
        }
    }
    cout<< f[n+1][0] << endl;
    return 0;
}
```



#### 5.3 炮兵阵地

[AcWing 292. 炮兵阵地](https://www.acwing.com/problem/content/294/)

**题目描述**

司令部的将军们打算在 N×M 的网格地图上部署他们的炮兵部队。

一个 N×M 的地图由 N 行 M 列组成，地图的每一格可能是山地（用 `H` 表示），也可能是平原（用 `P` 表示），如下图。

在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：

![](https://www.acwing.com/media/article/image/2019/02/16/19_d512cdba31-1185_1.jpg)

如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。

图上其它白色网格均攻击不到。

从图上可见炮兵的攻击范围不受地形的影响。

现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。

**输入格式**

第一行包含两个由空格分割开的正整数，分别表示 N 和 M；

接下来的 N 行，每一行含有连续的 M 个字符(`P` 或者 `H`)，中间没有空格。按顺序表示地图中每一行的数据。

**输出格式**

仅一行，包含一个整数 K，表示最多能摆放的炮兵部队的数量。

**数据范围**

$N≤100,M≤10$

**输入样例：**

```c
5 4
PHPP
PPHH
PPPP
PHPP
PHHP
```

**输出样例：**

```c
6
```

**题解：**

``` c
棋盘式状态压缩DP
    (1)状态表示:f[i][j][k]
    	1) 集合：所有已经摆完前i行，且第i-1行的状态是j,第i行的状态是k的所有摆放方案的最大值
    	2) 属性：Max
    (2)状态计算
    	划分依据，i行和i-1行状态已经确定了，i-2行状态不一样，则按照i-2行来划分
    	第i-1行状态是a,第i行是b，第i-2行是c
    	1) ((a & b) | (a & c) | (b & c)) == 0
    	2) (g[i-1] & a | g[i] & b) == 0	要能放置平原
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>
#include <vector>

using namespace std;
const int N = 11, M = 1<<10;

int n, m;
int g[110];
int cnt[M];
vector<int> state;  // 所有合法状态
int f[2][M][M]; // 使用滚动数组

// 检查是否合法，存在两个连续的1不合法
bool check(int state) {
    for(int i = 0; i < m; i++) {
        if((state >> i & 1) && ((state >> i+1 & 1) | (state >> i+2 & 1)))
            return false;
    }
    return true;
}

int count(int state) {
    int res = 0;
    for(int i = 0; i < m; i++) res += state >> i & 1;
    return res;
}

int main() {
    cin >> n >> m;
    for(int i = 1; i <= n; i++) {
        for(int j = 0; j < m;j++) {
            char c;
            cin >> c;
            if(c == 'H') 
                g[i] += 1 << j; //记录山地
        }
    }

    for(int i = 0; i < 1 << m; i++) {
        if(check(i)) {
            state.push_back(i);
            cnt[i] = count(i);
        }
    }

    //枚举所有状态
    for(int i = 1; i <= n + 2; i++) {
        for(int j = 0; j < state.size(); j++) {
            for(int k = 0; k < state.size(); k++) {
                for(int u = 0; u < state.size(); u++) {
                    int a = state[j], b = state[k], c = state[u];
                    if((a & b) | (b & c) | (a & c)) continue;
                    if(g[i-1] & a | g[i] & b) continue;
                    f[i & 1][j][k] = max(f[i & 1][j][k],f[i-1 & 1][u][j] + cnt[b]);
                }
            }
        }
    }

    // int res = 0;
    // for(int i = 0; i < state.size(); i++) {
    //     for(int j = 0; j < state.size(); j++) {
    //         res = max(res, f[n][i][j]);

    //     }
    // }
    // cout << res << endl;

    cout<< f[n+2 & 1][0][0] << endl;
    return 0;
}
```



#### 5.4 愤怒的小鸟(todo回)

[AcWing 524. 愤怒的小鸟](https://www.acwing.com/problem/content/526/)

**题目描述**

Kiana 最近沉迷于一款神奇的游戏无法自拔。   

简单来说，这款游戏是在一个平面上进行的。 

有一架弹弓位于 (0,0) 处，每次 Kiana 可以用它向第一象限发射一只红色的小鸟， 小鸟们的飞行轨迹均为形如 $y=ax^2+bx$ 的曲线，其中 a,b 是 Kiana 指定的参数，且必须满足 a<0。

当小鸟落回地面（即 x 轴）时，它就会瞬间消失。

在游戏的某个关卡里，平面的第一象限中有 n 只绿色的小猪，其中第 i 只小猪所在的坐标为 $(x_i,y_i)$。 

如果某只小鸟的飞行轨迹经过了  $(x_i,y_i)$，那么第 i 只小猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行； 

如果一只小鸟的飞行轨迹没有经过 $(x_i,y_i)$，那么这只小鸟飞行的全过程就不会对第 i 只小猪产生任何影响。 

例如，若两只小猪分别位于 (1,3) 和 (3,3)，Kiana 可以选择发射一只飞行轨迹为 $y=−x^2+4x$ 的小鸟，这样两只小猪就会被这只小鸟一起消灭。 

而这个游戏的目的，就是通过发射小鸟消灭所有的小猪。 

这款神奇游戏的每个关卡对 Kiana 来说都很难，所以 Kiana 还输入了一些神秘的指令，使得自己能更轻松地完成这个这个游戏。   

这些指令将在输入格式中详述。 

假设这款游戏一共有 T 个关卡，现在 Kiana 想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的小猪。  

由于她不会算，所以希望由你告诉她。

**注意**:本题除 NOIP 原数据外，还包含加强数据。

**输入格式**

第一行包含一个正整数 T，表示游戏的关卡总数。

下面依次输入这 T 个关卡的信息。

每个关卡第一行包含两个非负整数 n,m，分别表示该关卡中的小猪数量和 Kiana 输入的神秘指令类型。

接下来的 n 行中，第 i 行包含两个正实数 $(x_i,y_i)$，表示第 i 只小猪坐标为 $(x_i,y_i)$，数据保证同一个关卡中不存在两只坐标完全相同的小猪。

如果 m=0，表示 Kiana 输入了一个没有任何作用的指令。

如果 m=1，则这个关卡将会满足：至多用 ⌈n/3+1⌉ 只小鸟即可消灭所有小猪。

如果 m=2，则这个关卡将会满足：一定存在一种最优解，其中有一只小鸟消灭了至少 ⌊n/3⌋只小猪。

保证 $1≤n≤18，0≤m≤2，0<x_i,y_i<10$，输入中的实数均保留到小数点后两位。

上文中，符号 ⌈c⌉ 和 ⌊c⌋ 分别表示对 c 向上取整和向下取整，例如 ：$⌈2.1⌉=⌈2.9⌉=⌈3.0⌉=⌊3.0⌋=⌊3.1⌋=⌊3.9⌋=3$。

**输出格式**

对每个关卡依次输出一行答案。

输出的每一行包含一个正整数，表示相应的关卡中，消灭所有小猪最少需要的小鸟数量。

**数据范围**

![](https://cdn.acwing.com/media/article/image/2021/03/11/19_f187a0f582-QQ%E6%88%AA%E5%9B%BE20210311115727.png)

**输入样例：**

```c
2
2 0
1.00 3.00
3.00 3.00
5 2
1.00 5.00
2.00 8.00
3.00 9.00
4.00 8.00
5.00 5.00
```

**输出样例：**

```c
1
1
```

**题解：**

``` c
int dfs(int state,int cnt){	//state存储当前哪些列已经被覆盖
    if(state 已经包含了所有列){
    	ans = min(ans,cnt);
        return;
    } 
    任选没有被覆盖的一列x
    枚举所有能覆盖x的抛物线
    	更新一下state->new_state
        dfs(new_state,cnt+1)
}

//f[state]存下来
// x,path[x][j], new_state = state | path[x][j]
```

**代码：**

```c

```



#### 5.5 宝藏 （todo）

[AcWing 529. 宝藏 ](https://www.acwing.com/problem/content/531/)

**题目描述**

参与考古挖掘的小明得到了一份藏宝图，藏宝图上标出了 n 个深埋在地下的宝藏屋，也给出了这 n 个宝藏屋之间可供开发的 m 条道路和它们的长度。 

小明决心亲自前往挖掘所有宝藏屋中的宝藏。

但是，每个宝藏屋距离地面都很远，也就是说，从地面打通一条到某个宝藏屋的道路是很困难的，而开发宝藏屋之间的道路则相对容易很多。

小明的决心感动了考古挖掘的赞助商，赞助商决定免费赞助他打通一条从地面到某个宝藏屋的通道，通往哪个宝藏屋则由小明来决定。 

在此基础上，小明还需要考虑如何开凿宝藏屋之间的道路。

已经开凿出的道路可以任意通行不消耗代价。

每开凿出一条新道路，小明就会与考古队一起挖掘出由该条道路所能到达的宝藏屋的宝藏。

另外，小明不想开发无用道路，即两个已经被挖掘过的宝藏屋之间的道路无需再开发。

新开发一条道路的代价是：  

这条道路的长度 × 从赞助商帮你打通的宝藏屋到这条道路起点的宝藏屋所经过的宝藏屋的数量（包括赞助商帮你打通的宝藏屋和这条道路起点的宝藏屋）。 

请你编写程序为小明选定由赞助商打通的宝藏屋和之后开凿的道路，使得工程总代价最小，并输出这个最小值。

**输入格式**

第一行两个用空格分离的正整数 n 和 m，代表宝藏屋的个数和道路数。

接下来 m 行，每行三个用空格分离的正整数，分别是由一条道路连接的两个宝藏屋的编号（编号为 1∼n），和这条道路的长度 v。

**输出格式**

输出共一行，一个正整数，表示最小的总代价。

**数据范围**

$1≤n≤12$,
$0≤m≤1000$,
$v≤5∗10^5$

**输入样例：**

```c
4 5 
1 2 1 
1 3 3 
1 4 1 
2 3 4 
3 4 1 
```

**输出样例：**

```c
4
```

**题解：**

``` c

```

**代码：**

```c

```



### 6、区间DP

```
1、环形->链式
2、记录方案数
3、区间DP+高精度
4、二维区间DP

1、迭代式
先循环区间长度、再循环左端点
	for(int len = 1; len <= n; len++) 
		for(int L = 1;L+len+1 <= n; L++)
			R = L+len-1;
2、记忆化搜索
```

#### 6.1 环形石子合并

[AcWing 1068. 环形石子合并](https://www.acwing.com/problem/content/1070/)

**题目描述**

将 n 堆石子绕圆形操场排放，现要将石子有序地合并成一堆。

规定每次只能选相邻的两堆合并成新的一堆，并将新的一堆的石子数记做该次合并的得分。

请编写一个程序，读入堆数 n 及每堆的石子数，并进行如下计算：

- 选择一种合并石子的方案，使得做 n−1 次合并得分总和最大。
- 选择一种合并石子的方案，使得做 n−1 次合并得分总和最小。

**输入格式**

第一行包含整数 n，表示共有 n 堆石子。

第二行包含 n 个整数，分别表示每堆石子的数量。

**输出格式**

输出共两行：

第一行为合并得分总和最小值，

第二行为合并得分总和最大值。

**数据范围**

$1≤n≤200$

**输入样例：**

```c
4
4 5 9 4	
```

**输出样例：**

```c
43
54
```

**题解：**

``` c
copy一份变成链
```

**代码：**

```c
/*
 * @Descripttion: 
 * @version: 
 * @Author: ZKYAAA
 * @Date: 2023-08-09 10:42:04
 * @LastEditors: 请叫我ZK谕啊啊啊
 * @LastEditTime: 2023-08-09 11:00:14
 */
#include <iostream>
#include <algorithm>
#include <cstring>
#include <vector>

using namespace std;
const int N = 410, INF = 0x3f3f3f3f;  //两倍

int n;
int s[N],w[N];
int f[N][N], g[N][N];

int main() {
    cin >> n;
    for(int i = 1; i <= n; i++) {
        cin >> w[i];
        w[i+n] = w[i];
    }
    //处理前缀和
    for(int i = 1; i <= 2*n; i++) {
        s[i] = s[i-1] + w[i];
    }

    memset(f, 0x3f, sizeof f);
    memset(g, -0x3f, sizeof g);

    for(int len = 1; len <= n; len++) {
        for(int l = 1; l + len -1 <= n * 2; l++) {
            int r = l + len - 1;
            if(len == 1) f[l][r] = g[l][r] = 0;
            else {
                //枚举l-r之间的分界点k
                for(int k = l; k < r; k++) {
                    f[l][r] = min(f[l][r], f[l][k] + f[k+1][r] + s[r] - s[l-1]);
                    g[l][r] = max(g[l][r], g[l][k] + g[k+1][r] + s[r] - s[l-1]);
                }
            }
        }
    }

    int minv = INF, maxv = -INF;
    for(int i = 1; i <= n; i++) {
        minv = min(minv, f[i][i+n-1]);
        maxv = max(maxv, g[i][i+n-1]);
    }
    cout << minv << endl << maxv << endl;
    return 0;
}
```



#### 6.2 能量项链 

[AcWing 320. 能量项链 ](https://www.acwing.com/problem/content/322/)

**题目描述**

在 Mars 星球上，每个 Mars 人都随身佩带着一串能量项链，在项链上有 N 颗能量珠。

能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。

并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。

因为只有这样，通过吸盘（吸盘是 Mars 人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。

如果前一颗能量珠的头标记为 m，尾标记为 r，后一颗能量珠的头标记为 r，尾标记为 n，则聚合后释放的能量为 m×r×n（Mars 单位），新产生的珠子的头标记为 m，尾标记为 n。

需要时，Mars 人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。

显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。

例如：设 N=4，4 颗珠子的头标记与尾标记依次为 (2，3)(3，5)(5，10)(10，2)。

我们用记号 ⊕ 表示两颗珠子的聚合操作，(j⊕k) 表示第 j，k 两颗珠子聚合后所释放的能量。则

第 4、1两颗珠子聚合后释放的能量为：(4⊕1)=10×2×3=60。

这一串项链可以得到最优值的一个聚合顺序所释放的总能量为 ((4⊕1)⊕2)⊕3)=10×2×3+10×3×5+10×5×10=710。

**输入格式**

输入的第一行是一个正整数 N，表示项链上珠子的个数。

第二行是 N 个用空格隔开的正整数，所有的数均不超过 1000，第 i 个数为第 i 颗珠子的头标记，当 i<N 时，第 i 颗珠子的尾标记应该等于第 i+1 颗珠子的头标记，第 N 颗珠子的尾标记应该等于第 1 颗珠子的头标记。

至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。

**输出格式**

输出只有一行，是一个正整数 E，为一个最优聚合顺序所释放的总能量。

**数据范围**

$4≤N≤100$,
$1≤E≤2.1×10^9$

**输入样例：**

```c
4
2 3 5 10
```

**输出样例：**

```c
710
```

**题解：**

``` c
2-（1）-3-（2）-5-（3）-10-（4）-2
    
DP
    (1)状态表示 f[l][r]
    	1) 集合：所有将[L,R]合并成一个矩阵(珠子)的方式
    	2) 属性：Max
    (2)状态计算
    	(2,3) (3,5) (5,10) (10,2)
    	2 3 5 10 2
    	答案：f[1][5]
    	集合划分f[l][r]
    	1)l+1
    	2)l+2
    	3)l+3
    	...
    	4)r-2
    	5)r-1
    (l,k)->(k,r)->(l,r,k)
    f[l][k]->f[k][r]->w[l]*w[k]*w[r]
    
    (3)环形
```

**代码：**

```c
/*
 * @Descripttion: 
 * @version: 
 * @Author: ZKYAAA
 * @Date: 2023-08-09 11:30:34
 * @LastEditors: 请叫我ZK谕啊啊啊
 * @LastEditTime: 2023-08-09 11:38:00
 */
#include <iostream>
#include <algorithm>
#include <cstring>
#include <vector>

using namespace std;
const int N = 210;

int n;
int w[N];
int f[N][N];

int main() {
    cin >> n;
    for(int i = 1; i <= n; i++) {
        cin >> w[i];
        w[i+n] = w[i];
    }

    // 需要加到 n+1, 转动一圈之后回到1
    for(int len = 3; len <= n + 1; len++) {
        for(int l = 1; l + len - 1 <= n * 2; l++) {
            int r = l + len - 1;
            for(int k = l+1; k < r; k++) {
                f[l][r] = max(f[l][r], f[l][k] + f[k][r] + w[l]*w[k]*w[r]);
            }
        }
    }
    int res = 0;
    for(int i = 1; i <= n; i++) {
        res = max(res,f[i][i+n]);
    }
    cout << res << endl;
    return 0;
}
```



#### 6.3 加分二叉树(记录方案)

[AcWing 479. 加分二叉树](https://www.acwing.com/problem/content/481/)

**题目描述**

设一个 n 个节点的二叉树 tree 的中序遍历为（1,2,3,…,n），其中数字 1,2,3,…,n 为节点编号。

每个节点都有一个分数（均为正整数），记第 i 个节点的分数为 $d_i$，tree 及它的每个子树都有一个加分，任一棵子树 subtree（也包含 tree 本身）的加分计算方法如下：     

subtree的左子树的加分 × subtree的右子树的加分 ＋ subtree的根的分数 

若某个子树为空，规定其加分为 1。

叶子的加分就是叶节点本身的分数，不考虑它的空子树。

试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树 tree。

要求输出： 

（1）tree的最高加分 

（2）tree的前序遍历

**输入格式**

第 1 行：一个整数 n，为节点个数。 

第 2 行：n 个用空格隔开的整数，为每个节点的分数（0<分数<100）。

**输出格式**

第 1 行：一个整数，为最高加分（结果不会超过`int`范围）。     

第 2 行：n 个用空格隔开的整数，为该树的前序遍历。如果存在多种方案，则输出字典序最小的方案。

**数据范围**

n<30

**输入样例：**

```c
5
5 7 1 2 10
```

**输出样例：**

```c
145
3 1 2 4 5
```

**题解：**

``` c
2-（1）-3-（2）-5-（3）-10-（4）-2
    
DP
    (1)状态表示 f[l][r]
    	1) 集合：所有中序遍历是[L,R]这一段的二叉树的集合
    	2) 属性：Max
    (2)状态计算
    	集合划分：
    	1)根节点为 L
    	2)根节点为 L+1
    	3)根节点为 L+2
    	4)根节点为 L + k
    	....
    	5)根节点为 R-1
    	6)根节点为 R
    f[l][k-1] * f[k+1][r] + w[k]
```

**代码：**

```c
/*
 * @Descripttion: 
 * @version: 
 * @Author: ZKYAAA
 * @Date: 2023-08-09 15:09:21
 * @LastEditors: 请叫我ZK谕啊啊啊
 * @LastEditTime: 2023-08-09 15:19:43
 */
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 30;

int n;
int w[N];
int f[N][N], g[N][N];

void dfs(int l,int r) {
    if(l > r) return;
    int root = g[l][r];
    cout << root << ' ';
    dfs(l, root-1);
    dfs(root+1,r);
}

int main() {
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> w[i];

    for(int len = 1; len <= n; len++) {
        for(int l = 1; l + len - 1 <= n; l++) {
            int r = l + len -1;
            if(len == 1) {
                f[l][r] = w[l];
                g[l][r] = l;    //叶节点就是自己
            } 
            else {
                for(int k = 1; k <= r; k++) {
                    int left = k==l ? 1 : f[l][k-1];
                    int right = k==r ? 1 : f[k+1][r];
                    int score = left*right + w[k];
                    if(f[l][r] < score) {
                        f[l][r] = score;
                        g[l][r] = k;
                    }
                }
            }
        }
    }
    cout<< f[1][n] << endl;
    dfs(1,n);
    return 0;
}
```



#### 6.4 凸多边形的划分

[AcWing 1069. 凸多边形的划分](https://www.acwing.com/problem/content/1071/)

**题目描述**

给定一个具有 N 个顶点的凸多边形，将顶点从 1 至 N 标号，每个顶点的权值都是一个正整数。

将这个凸多边形划分成 N−2 个互不相交的三角形，对于每个三角形，其三个顶点的权值相乘都可得到一个权值乘积，试求所有三角形的顶点权值乘积之和至少为多少。

**输入格式**

第一行包含整数 N，表示顶点数量。

第二行包含 N 个整数，依次为顶点 1 至顶点 N 的权值。

**输出格式**

输出仅一行，为所有三角形的顶点权值乘积之和的最小值。

**数据范围**

N≤50,
数据保证所有顶点的权值都小于$10^9$

**输入样例：**

```c
5
121 122 123 245 231
```

**输出样例：**

```c
12214884
```

**题解：**

``` c
2-（1）-3-（2）-5-（3）-10-（4）-2
    
DP
    (1)状态表示 f[l][r]
    	1) 集合：所有将[L,L+1]、[L+1,L+2]、[R-1,R]、[R,L]这个多边形划分为三角形的方案
    	2) 属性：Max
    (2)状态计算
    (l,k)->(k,r)->(l,r,k)
    f[l][k]->f[k][r]->w[l]*w[k]*w[r]
    
    (3)环形
```

**代码：**

**WA版本**

```c
#include <iostream>
#include <algorithm>
#include <cstring>
#include <vector>

using namespace std;
const int N = 55, M = 35, INF = 1e9;

int n;
int w[N];
int f[N][N];

int main() {
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> w[i];

    for(int len = 3; len <= n; len++) {
        for(int l = 1; l + len - 1 <= n; l++) {
            int r = l + len - 1;
            f[l][r] = INF;
            for(int k = l + 1; k < r; k++) {
                f[l][r] = min(f[l][r], f[l][k] + f[k][r] + w[l] * w[k] * w[r]);
            }
        }
    }
    cout << f[1][n] << endl;
    return 0;
}
```

**高精度版本**

```c
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 55, M = 35, INF = 1e9;

int n;
int w[N];
LL f[N][N][M];

void add(LL a[], LL b[])
{
    static LL c[M];
    memset(c, 0, sizeof c);
    for (int i = 0, t = 0; i < M; i ++ )
    {
        t += a[i] + b[i];
        c[i] = t % 10;
        t /= 10;
    }
    memcpy(a, c, sizeof c);
}

void mul(LL a[], LL b)
{
    static LL c[M];
    memset(c, 0, sizeof c);
    LL t = 0;
    for (int i = 0; i < M; i ++ )
    {
        t += a[i] * b;
        c[i] = t % 10;
        t /= 10;
    }
    memcpy(a, c, sizeof c);
}

int cmp(LL a[], LL b[])
{
    for (int i = M - 1; i >= 0; i -- )
        if (a[i] > b[i]) return 1;
        else if (a[i] < b[i]) return -1;
    return 0;
}

void print(LL a[])
{
    int k = M - 1;
    while (k && !a[k]) k -- ;
    while (k >= 0) cout << a[k -- ];
    cout << endl;
}

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i ++ ) cin >> w[i];

    LL temp[M];
    for (int len = 3; len <= n; len ++ )
        for (int l = 1; l + len - 1 <= n; l ++ )
        {
            int r = l + len - 1;
            //设为正无穷的意思。
            //第三个数组的数字其实是倒着存的，这个语句的意思是 设高精度数为 1000...0，后面有M - 1个0
            f[l][r][M - 1] = 1;
            for (int k = l + 1; k < r; k ++ )
            {
                memset(temp, 0, sizeof temp);
                temp[0] = w[l];
                mul(temp, w[k]);
                mul(temp, w[r]);
                add(temp, f[l][k]);
                add(temp, f[k][r]);
                if (cmp(f[l][r], temp) > 0)
                    memcpy(f[l][r], temp, sizeof temp);
            }
        }

    print(f[1][n]);

    return 0;
}
```



#### 6.5 棋盘分割(回)

[AcWing 321. 棋盘分割](https://www.acwing.com/problem/content/323/)

**题目描述**

将一个 8×8 的棋盘进行如下分割：将原棋盘割下一块矩形棋盘并使剩下部分也是矩形，再将剩下的部分继续如此分割，这样割了 (n−1) 次后，连同最后剩下的矩形棋盘共有 n 块矩形棋盘。(每次切割都只能沿着棋盘格子的边进行)

![](https://www.acwing.com/media/article/image/2019/02/05/19_32dad08629-1191_1.jpg)

原棋盘上每一格有一个分值，一块矩形棋盘的总分为其所含各格分值之和。

现在需要把棋盘按上述规则分割成 n 块矩形棋盘，并使各矩形棋盘总分的均方差最小。

均方差![formula.png](https://www.acwing.com/media/article/image/2019/02/05/19_566d096029-formula.png) ，其中平均值![lala.png](https://www.acwing.com/media/article/image/2019/02/05/19_047fe57229-lala.png) ，$x_i$ 为第 i 块矩形棋盘的总分。

请编程对给出的棋盘及 n，求出均方差的最小值。

**输入格式**

第 1 行为一个整数 n。

第 2 行至第 9 行每行为 8 个小于 100 的非负整数，表示棋盘上相应格子的分值。每行相邻两数之间用一个空格分隔。

**输出格式**

输出最小均方差值（四舍五入精确到小数点后三位）。

**数据范围**

1<n<15

**输入样例：**

```c
3
1 1 1 1 1 1 1 3
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 0
1 1 1 1 1 1 0 3
```

**输出样例：**

```c
1.633
```

**题解：**

``` c
求均值最小====xi平方和最小
DP
    (1)状态表示 f[x1][y1][x2][y2][k]
    	1) 集合: 子矩阵(x1,y1)(x2,y2)切分成K部分的所有方案
    	2) 属性: 均方差最小值
    (2)状态计算
    	1)横切 n
        2)纵切 n
```

**代码：**

```c
#include <cstring>
#include <iostream>
#include <algorithm>
#include <cmath>

using namespace std;

const int N = 15, M = 9;
const double INF = 1e9;

int n, m = 8;
int s[M][M];
double f[M][M][M][M][N];
double X;

int get_sum(int x1, int y1, int x2, int y2)
{
    return s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1];
}

double get(int x1, int y1, int x2, int y2)
{
    double sum = get_sum(x1, y1, x2, y2) - X;
    return (double)sum * sum / n;
}

//记忆化搜索
double dp(int x1, int y1, int x2, int y2, int k)
{
    double &v = f[x1][y1][x2][y2][k];
    if (v >= 0) return v;
    if (k == 1) return v = get(x1, y1, x2, y2);

    v = INF;
    // 横切
    for (int i = x1; i < x2; i ++ )
    {
        v = min(v, get(x1, y1, i, y2) + dp(i + 1, y1, x2, y2, k - 1));
        v = min(v, get(i + 1, y1, x2, y2) + dp(x1, y1, i, y2, k - 1));
    }
    // 纵切
    for (int i = y1; i < y2; i ++ )
    {
        v = min(v, get(x1, y1, x2, i) + dp(x1, i + 1, x2, y2, k - 1));
        v = min(v, get(x1, i + 1, x2, y2) + dp(x1, y1, x2, i, k - 1));
    }
    return v;
}

int main()
{
    cin >> n;
    for (int i = 1; i <= m; i ++ )
        for (int j = 1; j <= m; j ++ )
        {
            cin >> s[i][j];
            s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];
        }

    X = (double)s[m][m] / n;
    memset(f, -1, sizeof f);
    printf("%.3lf\n", sqrt(dp(1, 1, 8, 8, n)));

    return 0;
}
```



### 7、树形DP

#### 1.2 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```

#### 1.2 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```

#### 1.2 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```

#### 1.2 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```

#### 1.2 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```

#### 1.2 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```





### 8、数位DP

#### 1.2 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```

#### 1.2 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```

#### 1.2 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```

#### 1.2 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```

#### 1.2 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```

#### 1.2 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```





### 9、单调队列优化DP

#### 1.2 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```

#### 1.2 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```

#### 1.2 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```

#### 1.2 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```

#### 1.2 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```

#### 1.2 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```



### 10、斜率优化DP

#### 1.2 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```

#### 1.2 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```

#### 1.2 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```



#### 1.2 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```







## 二、搜索

### 1、BFS

应用：

①最短距离

②最小步数

特点：

①求最小，最短

②基于迭代的思想，不会爆栈

#### (1) Flood Fill

**在线性时间复杂度里面，找到某个点所在的连通块**

#### Acwing 池塘计数（八连通BFS）

**[题目：AcWing1097. 池塘计数]()**

**题目描述**

农夫约翰有一片 N∗M 的矩形土地。

最近，由于降雨的原因，部分土地被水淹没了。

现在用一个字符矩阵来表示他的土地。

每个单元格内，如果包含雨水，则用”W”表示，如果不含雨水，则用”.”表示。

现在，约翰想知道他的土地中形成了多少片池塘。

每组相连的积水单元格集合可以看作是一片池塘。

每个单元格视为与其上、下、左、右、左上、右上、左下、右下八个邻近单元格相连。

请你输出共有多少片池塘，即矩阵中共有多少片相连的”W”块。

**输入格式**

第一行包含两个整数 N 和 M。

接下来 N行，每行包含 M个字符，字符为”W”或”.”，用以表示矩形土地的积水状况，字符之间没有空格。

**输出格式**

输出一个整数，表示池塘数目。

**数据范围**

1≤N,M≤1000	

**输入样例：**

```c
10 12
W........WW.
.WWW.....WWW
....WW...WW.
.........WW.
.........W..
..W......W..
.W.W.....WW.
W.W.W.....W.
.W.W......W.
..W.......W.
```

**输出样例：**

```c
3
```

**题解：**

``` c

```

**代码：**

```c
#include <cstring>
#include <iostream>
#include <algorithm>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 1010, M = N * N;

int n, m;
char g[N][N];
PII q[M];
bool st[N][N];	//bfs很多时候都需要开标记数组

void bfs(int sx, int sy)
{
    int hh = 0, tt = 0;
    q[0] = {sx, sy};
    st[sx][sy] = true;

    while (hh <= tt)
    {
        PII t = q[hh ++ ];

        for (int i = t.x - 1; i <= t.x + 1; i ++ )
            for (int j = t.y - 1; j <= t.y + 1; j ++ )
            {
                if (i == t.x && j == t.y) continue;
                //判重，越界，撞墙
                if (i < 0 || i >= n || j < 0 || j >= m) continue;
                if (g[i][j] == '.' || st[i][j]) continue;
                q[ ++ tt] = {i, j};
                st[i][j] = true;
            }
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 0; i < n; i ++ ) scanf("%s", g[i]);

    int cnt = 0;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < m; j ++ )
            if (g[i][j] == 'W' && !st[i][j])
            {
                bfs(i, j);
                cnt ++ ;
            }

    printf("%d\n", cnt);

    return 0;
}
```

#### Acwing1106 山峰和山谷            

**[题目：AcWing1106 山峰和山谷 ]()**

**题目描述**

FGD小朋友特别喜欢爬山，在爬山的时候他就在研究山峰和山谷。

为了能够对旅程有一个安排，他想知道山峰和山谷的数量。

给定一个地图，为FGD想要旅行的区域，地图被分为 *n*×*n*的网格，每个格子 (*i*,*j*) 的高度 *w*(*i*,*j*)是给定的。

若两个格子有公共顶点，那么它们就是相邻的格子，如与 $(i,j)$

 相邻的格子有$(i−1,j−1),(i−1,j),(i−1,j+1),(i,j−1),(i,j+1),(i+1,j−1),(i+1,j),(i+1,j+1)$。

我们定义一个格子的集合 *S*为山峰（山谷）当且仅当：

1、*S*的所有格子都有相同的高度。

 2、*S* 的所有格子都连通。

3、对于 *s*属于 *S*，与 *s* 相邻的 *s*′ 不属于 *S*，都有 $w_s>w_s′$（山峰），或者 $w_s<w_s′$（山谷）。

4、如果周围不存在相邻区域，则同时将其视为山峰和山谷。

你的任务是，对于给定的地图，求出山峰和山谷的数量，如果所有格子都有相同的高度，那么整个地图即是山峰，又是山谷。

**输入格式**

第一行包含一个正整数 *n*，表示地图的大小。

接下来一个 *n*×*n* 的矩阵，表示地图上每个格子的高度 *w*。

**输出格式**

共一行，包含两个整数，表示山峰和山谷的数量。

**数据范围**

$1≤n≤1000$,
 $0≤w≤10^9$

**输入样例：**

```c
5
8 8 8 7 7
7 7 8 8 7
7 7 7 7 7
7 8 8 7 8
7 8 8 8 8
```

**输出样例：**

```c
2 1
```

**题解：**

``` c

```

**代码：**

```c
#include <cstring>
#include <iostream>
#include <algorithm>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 1010, M = N * N;

int n;
int h[N][N];
PII q[M];
bool st[N][N];

void bfs(int sx, int sy, bool& has_higher, bool& has_lower)
{
    int hh = 0, tt = 0;
    q[0] = {sx, sy};
    st[sx][sy] = true;

    while (hh <= tt)
    {
        PII t = q[hh ++ ];

        for (int i = t.x - 1; i <= t.x + 1; i ++ )
            for (int j = t.y - 1; j <= t.y + 1; j ++ )
            {
            	//遍历八个方向 
                if (i == t.x && j == t.y) continue;
                if (i < 0 || i >= n || j < 0 || j >= n) continue; //越界 
                if (h[i][j] != h[t.x][t.y]) // 山脉的边界(不相同的高度)
                {
                	//高 
                    if (h[i][j] > h[t.x][t.y]) has_higher  = true;
                    else has_lower = true; //山谷 
                }
                else if (!st[i][j])  //没有访问过 
                {
                    q[ ++ tt] = {i, j};
                    st[i][j] = true;
                }
            }
    }
}

int main()
{
    scanf("%d", &n);

    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            scanf("%d", &h[i][j]);

    int peak = 0, valley = 0;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            if (!st[i][j])
            {
                bool has_higher = false, has_lower = false;
                bfs(i, j, has_higher, has_lower);
                if (!has_higher) peak ++ ;
                //这里不用加else if 
                if (!has_lower) valley ++ ;
            }

    printf("%d %d\n", peak, valley);

    return 0;
}
```



### 2、

## 四、高级数据结构

### 1、并查集



### 2、树状数组



### 3、线段树

#### (1) pushup

####  3.1 AcWing 1275.最大数    

**[题目：AcWing 1275.最大数   ]()**

**题目描述**

给定一个正整数数列 $a_1,a_2,…,a_n$，每一个数都在 `0∼p−1`之间。

可以对这列数进行两种操作：

1. 添加操作：向序列后添加一个数，序列长度变成 `n+1`；
2. 询问操作：询问这个序列中最后 `L`个数中最大的数是多少。

程序运行的最开始，整数序列为空。

一共要对整数序列进行 `m`次操作。

写一个程序，读入操作的序列，并输出询问操作的答案。

**输入格式**

第一行有两个正整数 `m,p`，意义如题目描述；

接下来 `m`行，每一行表示一个操作。

如果该行的内容是 `Q L`，则表示这个操作是询问序列中最后 `L` 个数的最大数是多少；

如果是 `A t`，则表示向序列后面加一个数，加入的数是`(t+a) mod p`。其中，`t` 是输入的参数，`a`是在这个添加操作之前最后一个询问操作的答案（如果之前没有询问操作，则 `a=0`）。

第一个操作一定是添加操作。对于询问操作，`L>0` 且不超过当前序列的长度。

**输出格式**

对于每一个询问操作，输出一行。该行只有一个数，即序列中最后 `L`个数的最大数。

**数据范围**

$1≤m≤2×10^5$,
$1≤p≤2×10^9$,
$0≤t<p$

**输入样例：**

```
10 100
A 97
Q 1
Q 1
A 17
Q 2
A 63
Q 1
Q 1
Q 3
A 99
```

**输出样例：**

```
97
97
97
60
60
97
```

**样例解释**

最后的序列是 97,14,60,96。

**c++代码实现：**

```
线段树
1.线段树的每个节点都代表一个区间。
2.线段树具有唯一的根结点，代表的区间是整个统计范围，如[1,N]。
3.线段树的每个叶结点都代表一个长度为1的元区间[x,x]。
4.对于每个内部结点[l,r],他的左子结点是[l,mid],右子结点是[mid十1,r],其中mid=(l+r)>>1

线段树Tip
1.线段树是一棵非常漂亮二叉树，(除了最后一层外，是一棵满二叉树)，因此我们采用堆的思想来存整棵树
(1) 编号x的父节点：x/2 , 常书写的代码：x>>1
(2) 编号x的左儿子：2x , 常书写的代码：x<<1
(3) 编号x的右儿子：2x十1，常书写的代码：×<<1|1
2线段的下一层都是把当前层进行平分mid=L l+r>>1」
(1) 左区间为[l，mid]
(2) 右区间为[mid+1,r]
注意，线段树的两个子区间是不允许相交的,这也决定了许多题的分块要进行额外的操作，使之区间不能相交
3.线段树一般开长度为4N的空间
(1) 一个长度为N的区间，最终的叶结点，为N个
(2) 先考虑理想状态下(包含最后一层，整个二叉树都是满二叉树)，N个叶结点的满二叉树有
N+N/2+N/4+.....+2+1=2N-1个结点
(3) 但是线段树的存储方式下，最后一层还会有盈余，最坏情况下，最后一层是倒数第二层（也就是满二叉树的倒数第一层）两倍的点，所以所以保存线段树的数组长度要不小于4N才能保证不会越界

线段树的模版
1,pushup（）:由子结点的信息来计算父结点的信息
2.bui1d（）:将一段区间初始化为线段树
3.modify（）:修改
(1) 单点修改(easy)
(2) 区间修改(hard)：用到pushdown操作，懒标记思想
4.query（）:区间询问(例如：查间[a,b]区间)O(1ogn)最多是4logn的时间，因为最坏有两条链
```

![](https://cdn.mathpix.com/snip/images/XE14-O3uA4REnVjYZYN7zYT8JkDy8PWPX9lZzBWTjpA.original.fullsize.png)

![](https://cdn.mathpix.com/snip/images/J3CnVSr-Heow39Ro4Fs70tGbuX1uXjLRfxR-ol_gcac.original.fullsize.png)

```c
#include <cstdio>
#include <algorithm>
#include <string>
#include <iostream>

#define ac cin.tie(0), cin.sync_with_stdio(0);
#define endl "\n"

using namespace std;

const int N = 2e5+10;

int m,p;

struct Node{
    int l,r;
    int v;  //携带的信息，这里是[l,r]区间的最大值
}tr[N*4];

//pushup操作，由子节点的信息，来计算父节点的信息
void pushup(int u){
    tr[u].v=max(tr[u<<1].v,tr[u<<1|1].v);
}

//build的时候先赋值避免忘记
void build(int u,int l,int r){
    // tr[u]={l,r};
    tr[u].l=l,tr[u].r=r;    //节点u代表区间[l,r]
    if(l==r) return;    //是叶子节点
    int mid=l+r>>1;
    build(u<<1,l,mid),build(u<<1|1,mid+1,r);
}

int query(int u,int l,int r){
    if(tr[u].l>=l && tr[u].r<=r) return tr[u].v;    //查询在区间[l,r]的最大值，包含当前的节点u，则直接回溯返回当前点的值
    int mid=tr[u].l+tr[u].r>>1;
    int v=0;
    // if(l<=mid) v=max(v,query(u<<1,l,r));
    if(l<=mid) v=query(u<<1,l,r);
    if(r>mid) v=max(v,query(u<<1|1,l,r));
    // else v=max(v,query(u<<1|1,l,r));
    return v;
}

void modify(int u,int x,int v){
    if(tr[u].l==x && tr[u].r==x) tr[u].v=v;
    else{
        int mid=tr[u].l+tr[u].r>>1;
        if(x<=mid) modify(u<<1,x,v);
        else modify(u<<1|1,x,v);
        pushup(u);
    }
}

int main(){
    int n=0,last=0;   //last记录题目中所说的上次查询的结果a
    scanf("%d%d",&m,&p);
    build(1,1,m);
    
    int x;
    char op[2];
    while(m--){
        scanf("%s%d",op,&x);
        if(*op=='Q'){
            last=query(1,n-x+1,n);
            printf("%d\n",last);
        }else{
            modify(1,n+1,((long long)last+x)%p);
            n++;
        }
    }
    return 0;
}
```

Q:线段树建树build操作的时候，什么时候需要加pushup，什么时候不加pushup

A：在线段树的建树过程中，通常需要执行pushup操作来更新父节点的信息，以确保它的信息与子节点保持一致。pushup操作的时机取决于当前节点的性质以及子节点的性质，具体情况如下：

1. 对于区间修改操作（如单点修改、区间加、区间赋值等），因为修改操作会改变子节点的值，所以在递归调用build函数时需要先对子节点进行更新，再对父节点进行pushup操作。
2. 对于区间查询操作，因为查询操作只需要使用子节点的信息计算父节点的信息，而不需要修改子节点的信息，所以在递归调用build函数时不需要进行pushup操作。
3. 对于区间合并操作（如区间求和、区间最大值、区间最小值等），由于子节点的信息可以通过简单的合并得到父节点的信息，因此在递归调用build函数时需要先对子节点进行更新，再对父节点进行pushup操作。

总之，需要加pushup的情况是在对子节点进行更新之后，需要确保父节点的信息与子节点保持一致。不需要加pushup的情况是在不需要修改子节点的信息的情况下进行递归调用。

[推荐博客](https://www.cnblogs.com/zheyuanxie/archive/2022/08/09/segment-tree.html)

​        

#### 3.2 AcWing 245. 你能回答这些问题吗      

**[题目：AcWing 245. 你能回答这些问题吗  ]()**

**题目描述**

给定长度为 *N* 的数列 *A*，以及 *M*

 条指令，每条指令可能是以下两种之一：

1. `1 x y`，查询区间 [*x*,*y*]中的最大连续子段和，即$ max_{x≤l≤r≤y}{∑_{i=l}^rA[i]}$。

2. `2 x y`，把 *A*[*x*]改成 *y*

对于每个查询指令，输出一个整数表示答案。

**输入格式**

第一行两个整数 *N*,*M*。

第二行 *N*个整数 *A*[*i*]。

接下来 *M*行每行 3 个整数 *k*,*x*,*y*，*k*=1 表示查询（此时如果 *x*>*y*，请交换 *x*,*y*），*k*=2 表示修改。

**输出格式**

对于每个查询指令输出一个整数表示答案。

每个答案占一行。

**数据范围**

$N≤500000≤M≤100000$,
 $−1000≤A[i]≤1000$,

**输入样例：**

```r
5 3
1 2 -3 4 5
1 2 3
2 2 -1
1 3 2
```

**输出样例：**

```
2
-1
```

**题解：**

``` c
struct Node{
  int l,r;  //区间左右端点
  int sum; //区间和
  int lmax; //最大前缀和
  int rmax; //最大后缀和
  int tmax; //最大连续子段和
  //横跨左右子区间的最大子段和 = 左子区间的最大后缀 + 右子区间的最大前缀
}tr[N*4];

void pushup(Node& u,Node& l,Node& r){
  u.sum=l.sum+r.sum;  //区间和=左区间和+右区间和
  //最大前缀和:左儿子的前缀和（只有左儿子前缀）、左儿子区间和+右儿子的前缀和（覆盖到右儿子）
  u.lmax=max(l.lmax,l.sum+r.lmax);  
  //最大后缀和:右儿子的后缀和（只有右儿子后缀）、左儿子后缀+右儿子的区间和（覆盖到右儿子）
  u.rmax=max(r.rmax,l.rmax+r.sum);  
  //当只有左边或者右边儿子、跨越两个区间左儿子取后缀右儿子取前缀
  u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}
```

**代码：**

```c
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <iostream>

using namespace std;
const int N = 5e5+10;
int w[N];
int n,m;

struct Node{
  int l,r;  //区间左右端点
  int sum; //区间和
  int lmax; //最大前缀和
  int rmax; //最大后缀和
  int tmax; //最大连续子段和
  //横跨左右子区间的最大子段和 = 左子区间的最大后缀 + 右子区间的最大前缀
}tr[N*4];

void pushup(Node& u,Node& l,Node& r){
  u.sum=l.sum+r.sum;  //区间和=左区间和+右区间和
  //最大前缀和:左儿子的前缀和（只有左儿子前缀）、左儿子区间和+右儿子的前缀和（覆盖到右儿子）
  u.lmax=max(l.lmax,l.sum+r.lmax);  
  //最大后缀和:右儿子的后缀和（只有右儿子后缀）、左儿子后缀+右儿子的区间和（覆盖到右儿子）
  u.rmax=max(r.rmax,l.rmax+r.sum);  
  //当只有左边或者右边儿子、跨越两个区间左儿子取后缀右儿子取前缀
  u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u){
  pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r){
  tr[u].l=l,tr[u].r=r;	//	容易忘记写在else里面导致段错误
  //如果是叶子节点
  if(l==r){
    tr[u].sum=w[l];
    tr[u].lmax=w[l];
    tr[u].rmax=w[l];
    tr[u].tmax=w[l];
  }else{
    int mid=l+r>>1;
    build(u<<1,l,mid);
    build(u<<1|1,mid+1,r);
    pushup(u);
  }
}

void modify(int u,int x,int v){
  if(tr[u].l==x && tr[u].r==x){
    tr[u].l=x, tr[u].r=x, tr[u].sum=v, tr[u].lmax=v, tr[u].rmax=v, tr[u].tmax=v;
  }else{
    int mid=tr[u].l + tr[u].r>>1;
    if(x<=mid) modify(u<<1,x,v);
    else modify(u<<1|1,x,v);
    pushup(u);
  }
}

Node query(int u,int l,int r){
  if(tr[u].l>=l && tr[u].r<=r) return tr[u];
  else{
    int mid=tr[u].l+tr[u].r>>1;
    /*
    1、在左区间  r<=mid
    2、在右区间  l>mid
    3、左区间+右区间
    */
    if(r<=mid) return query(u<<1,l,r);
    else if(l>mid) return query(u<<1|1,l,r);
    else{
      Node left=query(u<<1,l,r);
      Node right=query(u<<1|1,l,r);
      Node res;
      pushup(res,left,right);
      return res;
    }
  }
}

int main()
{
  scanf("%d%d",&n,&m);
  //数组下标从1开始
  for(int i=1;i<=n;i++) scanf("%d",&w[i]);
  build(1,1,n);
  
  int k,x,y;
  while(m--){
    scanf("%d%d%d",&k,&x,&y);
    if(k==1){
      if(x>y) swap(x,y);
      printf("%d\n",query(1,x,y).tmax);
    }else modify(1,x,y);
  }
  return 0;
}
```



#### 3.3 AcWing 246. 区间最大公约数   (todo)

**[题目：246. 区间最大公约数 ]()**

**题目描述**

给定一个长度为 *N* 的数列 *A*，以及 *M* 条指令，每条指令可能是以下两种之一：

1、`C l r d`，表示把 $A[l]$,$A[l+1]$,…,$A[r]$都加上 $d$。

2、`Q l r`，表示询问 $A[l]$,$A[l+1]$,…,$A[r]$的最大公约数(GCD）

对于每个询问，输出一个整数表示答案。

**输入格式**

第一行两个整数 *N*,*M*。

第二行 *N*个整数 *A*[*i*]。

接下来 *M*行表示 *M* 条指令，每条指令的格式如题目描述所示。

**输出格式**

对于每个询问，输出一个整数表示答案。

每个答案占一行。

**数据范围**

$N≤500000,M≤100000$,
$1≤A[i]≤10^{18}$,
 $|d|≤10^{18}$

**输入样例：**

```r
5 5
1 3 5 7 9
Q 1 5
C 1 5 1
Q 1 5
C 3 3 6
Q 2 4
```

**输出样例：**

```
1
2
4
```

**题解：**

``` c
怎么将求解一个区间的操作转化为只对某一个点
最大公约数左边等于右边：
(x,y,z)= (x,y-x,z-y)    
(a1, a2, .....an) <= (a, a2-a1, a3-a2, ....an-an-1)
(a1, a2, .....an) >= (a, a2-a1, a3-a2, ....an-an-1)
(a1, a2, .....an) = (a, a2-a1, a3-a2, ....an-an-1) = d  
    
求[l,r]的最大公约数：
gcd(a[l], gcd{b[l+1]~b[r]})
    
用差分来存sum和gcd
```

**代码：**

```c
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 500010;

int n, m;
LL w[N];
struct Node
{
    int l, r;
    LL sum, d;
}tr[N * 4];

LL gcd(LL a, LL b)
{
    return b ? gcd(b, a % b) : a;
}

void pushup(Node &u, Node &l, Node &r)
{
    u.sum = l.sum + r.sum;
    u.d = gcd(l.d, r.d);
}

void pushup(int u)
{
    pushup(tr[u], tr[u << 1], tr[u << 1 | 1]);
}

void build(int u, int l, int r)
{
    if (l == r)
    {
        LL b = w[r] - w[r - 1];
        tr[u] = {l, r, b, b};
    }
    else
    {
        tr[u].l = l, tr[u].r = r;
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
}

void modify(int u, int x, LL v)
{
    if (tr[u].l == x && tr[u].r == x)
    {
        LL b = tr[u].sum + v;
        tr[u] = {x, x, b, b};
    }
    else
    {
        int mid = tr[u].l + tr[u].r >> 1;
        if (x <= mid) modify(u << 1, x, v);
        else modify(u << 1 | 1, x, v);
        pushup(u);
    }
}

Node query(int u, int l, int r)
{
    if (tr[u].l >= l && tr[u].r <= r) return tr[u];
    else
    {
        int mid = tr[u].l + tr[u].r >> 1;
        if (r <= mid) return query(u << 1, l, r);
        else if (l > mid) return query(u << 1 | 1, l, r);
        else
        {
            auto left = query(u << 1, l, r);
            auto right = query(u << 1 | 1, l, r);
            Node res;
            pushup(res, left, right);
            return res;
        }
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) scanf("%lld", &w[i]);
    build(1, 1, n);

    int l, r;
    LL d;
    char op[2];
    while (m -- )
    {
        scanf("%s%d%d", op, &l, &r);
        if (*op == 'Q')
        {
            auto left = query(1, 1, l);
            Node right({0, 0, 0, 0});
            if (l + 1 <= r) right = query(1, l + 1, r);
            printf("%lld\n", abs(gcd(left.sum, right.d)));
        }
        else
        {
            scanf("%lld", &d);
            modify(1, l, d);
            if (r + 1 <= n) modify(1, r + 1, -d);
        }
    }

    return 0;
}
```



#### (2) 赖标记、pushdown

单点修改一般pushup操作就够了

区间修改则需要懒标记-pushdown，思想来源于区间查询

```c
1、修改操作
信息：
    （1）sum:当前区间的总和
    （2）add懒标记，给以当前节点为根的子树中的每个节点，加上add(不包含根节点)
        当前的操作到该根节点之后就不在传播了，直接返回
        
2、查询操作
     查询某一段区间的时候，如果用到的某一个值被add懒标记过了，则需要找到该子节点的父节点，一开始加add懒标记的节点，再将祖宗的root所有的add操作累加到所求点位置，那么可以找到祖宗root节点，每次递归左右儿子加add懒标记，每次懒标记之后清空当前的add懒标记，一直pushdown向下。
     假设祖宗节点root被add懒标记了，root.add
     pushdown操作：
     left.add += root.add;
	 left.sum +=(left.R-left.R+1)*root.add	//	左儿子总和=左边节点个数*add
     right.add += root.add;
     right.sum +=(right.R-right.R+1)*root.add	//	左儿子总和=左边节点个数*add
     root.add = 0  //清空懒标记
```

[推荐](https://leetcode.cn/problems/my-calendar-i/solution/by-ac_oier-hnjl/?orderBy=hot)

#### 3.4  Acwing243. 一个简单的整数问题2             

**[题目：243. 一个简单的整数问题2 ]()**

**题目描述**

给定一个长度为 $N$ 的数列 $A$，以及 $M$条指令，每条指令可能是以下两种之一：

1. `C l r d`，表示把 $A[l]$,$A[l+1]$,…,$A[r]$都加上 $d$。

​    2.`Q l r`，表示询问数列中第 `l∼r`个数的和。

对于每个询问，输出一个整数表示答案。

**输入格式**

第一行两个整数 *N*,*M*。

第二行 *N*个整数 *A*[*i*]。

接下来 *M*行表示 *M* 条指令，每条指令的格式如题目描述所示。

**输出格式**

对于每个询问，输出一个整数表示答案。

每个答案占一行。

**数据范围**

$1≤N,M≤10^5$,
 $|d|≤10000$,
 $|A[i]|≤10^9$,

**输入样例：**

```r
10 5
1 2 3 4 5 6 7 8 9 10
Q 4 4
Q 1 10
Q 2 4
C 3 6 3
Q 2 4
```

**输出样例：**

```
4
55
9
15
```

**题解：**

``` c
维护:
    sum : 如果只考虑当前节点及子节点上的所有标记，当前区间和是多少（没有考虑所有祖先节点上的标记，只考虑当前点及儿子）
    add : 给当前区间的所有儿子加上add
```

**代码：**

```c
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <iostream>
typedef long long LL;
using namespace std;
const int N = 1e5+5;
int w[N];
int n,m;

struct Node{
  int l,r;  //左右区间
  LL sum,add;  //区间里面的总和，以及懒标记
}tr[N*4];

void pushup(int u){
  tr[u].sum = tr[u<<1].sum + tr[u<<1|1].sum;
}

void pushdown(int u){
  auto& root=tr[u],&left=tr[u<<1],&right=tr[u<<1|1];
  //如果存在懒标记
  if(root.add){
    left.add+=root.add, left.sum+=(LL)(left.r-left.l+1)*root.add;
    right.add+=root.add,right.sum+=(LL)(right.r-right.l+1)*root.add;
    //将懒标记清除
    root.add=0;
  }
}

void build(int u,int l,int r){
  if(l==r){
    //懒标记刚build的时候0
    tr[u]={l,r,w[r],0};
  }else{
    tr[u]={l,r}; //不加会段错误
    int mid = l+r>>1;
    build(u<<1,l,mid),build(u<<1|1,mid+1,r);
    pushup(u);
  }
}

void modify(int u,int l,int r,int d)
{
  //包含区间
  if(tr[u].l>=l && tr[u].r<=r){
    tr[u].sum+=(LL)(tr[u].r-tr[u].l+1)*d;
    tr[u].add+=d;
  }else{  //需要分裂，可能存在两边的add数值不一致
    pushdown(u);
    int mid=tr[u].l+tr[u].r>>1;
    if(l<=mid) modify(u<<1,l,r,d);
    if(r>mid) modify(u<<1|1,l,r,d);
    pushup(u);
  }
}

LL query(int u,int l,int r){
  if(tr[u].l>=l && tr[u].r<=r) return tr[u].sum;
  
  pushdown(u);
  int mid=tr[u].l+tr[u].r>>1;
  LL sum=0;
  if(l<=mid) sum=query(u<<1,l,r);
  if(r>mid) sum+=query(u<<1|1,l,r);
  return sum;
}

int main()
{
  scanf("%d%d",&n,&m);
  for(int i=1;i<=n;i++) scanf("%d",&w[i]);
  build(1,1,n);
  
  char op[2];
  int l,r,d;
  
  while(m--){
    scanf("%s%d%d",op,&l,&r);
    if(*op=='C'){
      scanf("%d",&d);
      modify(1,l,r,d);
    }else printf("%lld\n",query(1,l,r));
  }
  
  return 0;
}
```



#### 3.5 AcWing 1277. 维护序列                

**[题目：AcWing 1277. 维护序列 ]()**

**题目描述**

老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。

有长为 $N$的数列，不妨设为 $a1,a2,…,a_N$。

有如下三种操作形式：

1. 把数列中的一段数全部乘一个值；
2. 把数列中的一段数全部加一个值；
3. 询问数列中的一段数的和，由于答案可能很大，你只需输出这个数模 $P$的值。

**输入格式**

第一行两个整数 $N$和 $P$；

第二行含有 $N$个非负整数，从左到右依次为 $a1,a2,…,a_N$；

第三行有一个整数 $M$，表示操作总数；

从第四行开始每行描述一个操作，输入的操作有以下三种形式：

- 操作 1：`1 t g c`，表示把所有满足 $t≤i≤g$ 的 $a_i$ 改为 $a_i×c$；
- 操作 2：`2 t g c`，表示把所有满足 $t≤i≤g$ 的 $a_i$ 改为 $a_i$+c；
- 操作 3：`3 t g`，询问所有满足 $t≤i≤g$ 的 $a_i$ 的和模 $P$ 的值。

同一行相邻两数之间用一个空格隔开，每行开头和末尾没有多余空格。

**输出格式**

对每个操作 3，按照它在输入中出现的顺序，依次输出一行一个整数表示询问结果。

**数据范围**

$1≤N,M≤10^5$,
$ 1≤t≤g≤N$,
 $0≤c,a_i≤10^9$,
 $1≤P≤10^9$,

**输入样例：**

```r
7 43
1 2 3 4 5 6 7
5
1 2 5 5
3 2 4
2 3 7 9
3 1 3
3 4 7
```

**输出样例：**

```
2
35
8
```

**样例解释**

初始时数列为 `{1,2,3,4,5,6,7}`；

经过第 1 次操作后，数列为 `{1,10,15,20,25,6,7}`；

对第 2次操作，和为 `10+15+20=45`，模 43 的结果是 2；

经过第 3次操作后，数列为` {1,10,24,29,34,15,16}`；

对第 4次操作，和为` 1+10+24=35`，模 43 的结果是 35；

对第 5次操作，和为` 29+34+15+16=94`，模 43 的结果是 8。

**题解：**

``` c
1、线段树需要记录的信息：
	L，R
	sum,add,mul
	注意：
    	（1）add表示在区间加一个数，mul表示在区间里面乘一个数
    	（2）考虑先加还是先乘法，应该先乘法后加法(能保证操作前后形式统一)，x表示区间里面每个数
    		①加法的时候(将add + add`记为新的add)：
    				(x * mul + add )+ add` = x * mul + add
    			
    		②乘法的时候(将mul * mul`记为新的mul，同时将add * mul`记为新的add)：
    				(x * mul + add )*mul` = x * mul * mul` + add * mul` = x * mul + add
    
2、优化
    x * c + d
    (1)乘c ,等价与 d=0 , x * c + d = x * c
    (2)加d ,等价与 c=1 , x * 1 + d = x + d
综上：
    记ac为新的mul,bc+d为新的add
    (x * a + b) * c + d = x * ac + bc + d = x * mul + add
```

**代码：**

```c
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>

typedef long long ll;
using namespace std;
const int N = 1e5+10;

int n,m,p;
int w[N];

struct Node{
  int l,r;
  int sum,add,mul;
}tr[N*4];

//pushup操作
void pushup(int u)
{
  tr[u].sum = (tr[u<<1].sum + tr[u<<1|1].sum)%p;
}

void eval(Node& u,int add,int mul)
{
  //先乘法后加法，加的是整个区间的=个数*add
  u.sum = ((ll)u.sum*mul + (ll)(u.r-u.l+1)*add)%p;
  //乘法,直接mul
  u.mul = (ll)u.mul*mul % p;
  //加法,加法前需要先mul操作
  u.add = ((ll)u.add*mul + add)%p;
}

//pushdown操作
void pushdown(int u)
{
  eval(tr[u<<1],tr[u].add,tr[u].mul);
  eval(tr[u<<1|1],tr[u].add,tr[u].mul);
  //清空操作
  tr[u].add = 0,tr[u].mul = 1;
}

void build(int u,int l,int r)
{
  if(l==r) tr[u]={l,r,w[l],0,1};
  else{
    //初始sum为0
    tr[u]={l,r,0,0,1};
    int mid=l+r>>1;
    build(u<<1,l,mid),build(u<<1|1,mid+1,r);
    pushup(u);
  }
}

void modify(int u,int l,int r,int add,int mul)
{
  if(tr[u].l>=l && tr[u].r<=r) eval(tr[u],add,mul);
  else{
    pushdown(u);
    int mid = tr[u].l+tr[u].r>>1;
    if(l<=mid) modify(u<<1,l,r,add,mul);
    if(r>mid) modify(u<<1|1,l,r,add,mul);
    pushup(u);
  }
}

int query(int u,int l,int r)
{
  if(tr[u].l>=l && tr[u].r<=r) return tr[u].sum;
  pushdown(u);
  int mid=tr[u].l+tr[u].r>>1;
  int res=0;
  if(l<=mid) res=query(u<<1,l,r);
  if(r>mid) res=(res+query(u<<1|1,l,r))%p;
  return res;
}

int main(){
  scanf("%d%d",&n,&p);
  for(int i=1;i<=n;i++) scanf("%d",&w[i]);
  build(1,1,n);
  
  scanf("%d", &m);
  while (m -- )
  {
    int t, l, r, d;
    scanf("%d%d%d", &t, &l, &r);
    if (t == 1)
    {
      scanf("%d", &d);
      modify(1, l, r, 0, d);
    }
    else if (t == 2)
    {
      scanf("%d", &d);
      modify(1, l, r, d, 1);
    }
    else printf("%d\n", query(1, l, r));
  }
  return 0;
}
```



#### （3）扫描线

#### 3.6 AcWing 247. 亚特兰蒂斯  （todo）          

**[题目：AcWing 247. 亚特兰蒂斯 ]()**

**题目描述**

有几个古希腊书籍中包含了对传说中的亚特兰蒂斯岛的描述。 

其中一些甚至包括岛屿部分地图。 

但不幸的是，这些地图描述了亚特兰蒂斯的不同区域。 

您的朋友 Bill 必须知道地图的总面积。 

你自告奋勇写了一个计算这个总面积的程序。

**输入格式**

输入包含多组测试用例。

对于每组测试用例，第一行包含整数 $n$，表示总的地图数量。

接下来 $n$ 行，描绘了每张地图，每行包含四个数字 $x1,y1,x2,y2$（不一定是整数），$(x1,y1)$ 和 $(x2,y2)$分别是地图的左上角位置和右下角位置。

注意，坐标轴 $x$轴从上向下延伸，$y$轴从左向右延伸。

当输入用例 $n$=0时，表示输入终止，该用例无需处理。

**输出格式**

每组测试用例输出两行。

第一行输出 `Test case #k`，其中 $k$是测试用例的编号，从 1开始。

第二行输出 `Total explored area: a`，其中 *a*是总地图面积（即此测试用例中所有矩形的面积并，注意如果一片区域被多个地图包含，则在计算总面积时只计算一次），精确到小数点后两位数。

在每个测试用例后输出一个空行。

**数据范围**

$1≤n≤10000$,
 $0≤x1<x2≤100000$,
 $0≤y1<y2≤100000$
 注意，本题 $n$ 的范围上限加强至 10000。

**输入样例：**

```r
2
10 10 20 20
15 15 25 25.5
0
```

**输出样例：**

```
Test case #1
Total explored area: 180.00 
```

**样例解释**

样例所示地图覆盖区域如下图所示，两个矩形区域所覆盖的总面积，即为样例的解。

![](https://cdn.acwing.com/media/article/image/2019/12/26/19_4acba44c27-%E6%97%A0%E6%A0%87%E9%A2%98.png)**题解：**

``` c
操作1：
    将某一个区间[L,R]加一个k(K的取值是取决于y轴坐标，如果是左边取+1，右边取-1)
    
操作2：
    求整个区间中长度大于0的区间总长度是多少？
    
线段树中的节点信息：
	（1）cnt：当前区间整个被覆盖的次数是多少
	（2）len：不考虑所有的祖先节点cnt的前提下，cnt>0的区间总长
注意：线段树的节点，永远只向下看
    
    
扫描线：
（1）永远只考虑根节点的信息----查询query时候不需要调用pushdown
（2）所有的操作均是成对出现，且先加后减----modify的时候不需要pushdown
    对于减法，减完之后>0不影响正确性，=0也是不影响准确性
    对于加法，
    ①cnt > 0,如果被矩形覆盖了，就会被计算，无需向下分裂
    ②cnt = 0,pushdown是与否都一样
    
总的就是，修改的时候不用pushdown，不完全标记，如果完全包含区间的话，就在上面加上权值，往下面递归
   pushup注意当前的cnt==0，值是两个儿子的总和 ，如果不是0就是区间长度
```

**[代码](https://www.acwing.com/activity/content/code/content/167934/)**



## 六、基础算法

### 1、位运算、递推与递归

### 2、前缀和、差分、二分

### 3、排序、RMQ	

#### (1) 排序

#### (2) RMQ

$0------------i----------i+2^j-1--------------------n$
		                                          $f[i][j]$                                    $f[i+2^j-1]$

$f[i][j]$：表示从 $i$ 开始长度是 $2^j$ 的区间中,也就是区间 $[i,i+2^j-1]$ 的最大值是多少,也就是从 $i$ 开始的  $2^j$  个数的最大值
该区间一共有 $2^j$ 个数，如果均分为两个部分，则每个部分就是 $2^{j-1}$ 个数，则区间 $ [i,i+2^j-1]$ 变成区间  $[i+2^{j-1}-1]$ 和 $[i+2^{j-1},i+2^j-1]$

i 到 $i+2^j-1$ 中的最大值，可以分为  $f[i][2^{j-1}]+f[i+2^{j-1}][j-1]$
$f[i][j]=max(f[i][j-1],f[i+2^{j-1}][j-1])$

$----L-----------R------$
设 L 到 R 的长度是 len，找到 $2^k<=len <= 2*2^k=2^{k+1}$,也就是找到小于 len 区间长度的 2 的幂次的最大值 k
则L开始的 $2^k$ 个数  和  以 R 为结尾的 $2^k$ 个数 这两段区间一定覆盖整个区间 $[L,R]$ ,这两段最大值分别是$f[L][k]$ 和 $f[R-2^k+1][k]$
两者最大值就是整个区间的最大值，因为求的是最大值，所以就算是有重叠也没有关系
k可以先预处理好 $logk/log2$

缺点：不能修改，是静态的，线段树可以支持动态修改

#### AcWing 1273. 天才的记忆                 

**[题目：AcWing 1273. 天才的记忆 ]()**

**题目描述**

从前有个人名叫 WNB，他有着天才般的记忆力，他珍藏了许多许多的宝藏。

在他离世之后留给后人一个难题（专门考验记忆力的啊！），如果谁能轻松回答出这个问题，便可以继承他的宝藏。

题目是这样的：给你一大串数字（编号为 1到 *N*，大小可不一定哦！），在你看过一遍之后，它便消失在你面前，随后问题就出现了，给你 *M* 个询问，每次询问就给你两个数字 *A*,*B*，要求你瞬间就说出属于 *A* 到 *B*这段区间内的最大数。

一天，一位美丽的姐姐从天上飞过，看到这个问题，感到很有意思（主要是据说那个宝藏里面藏着一种美容水，喝了可以让这美丽的姐姐更加迷人），于是她就竭尽全力想解决这个问题。

但是，她每次都以失败告终，因为这数字的个数是在太多了！

于是她请天才的你帮他解决。如果你帮她解决了这个问题，可是会得到很多甜头的哦！

**输入格式**

第一行一个整数 *N*表示数字的个数。

接下来一行为 *N* 个数，表示数字序列。

第三行读入一个 *M*，表示你看完那串数后需要被提问的次数。

接下来 *M*行，每行都有两个整数 *A*,*B*。

**输出格式**

输出共 *M* 行，每行输出一个数，表示对一个问题的回答。

**数据范围**

$1≤N≤2×10^5$,
 $1≤M≤10^4$,
$ 1≤A≤B≤N$,

**输入样例：**

```r
6
34 1 8 123 3 2
4
1 2
1 5
3 4
2 3
```

**输出样例：**

```
34
123
123
8
```

**解答：**

```
0------------i----------i+2^j-1----------n
		 f[i][j]          f[i+2^j-1]

f[i][j]：表示从i开始长度是2^j的区间中,也就是区间[i,i+2^j-1]的最大值是多少,也就是从i开始的2^j个数的最大值
该区间一共有2^j个数，如果均分为两个部分，则每个部分就是2^{j-1}个数，则区间[i,i+2^j-1]变成区间[i+2^{j-1}-1]和[i+2^{j-1},i+2^j-1]

i到i+2^j-1中的最大值，可以分为f[i][2^{j-1}]+f[i+2^{j-1}][j-1]
f[i][j]=max(f[i][j-1],f[i+2^{j-1}][j-1])

----L-----------R------
设L到R的长度是len，找到2^k<=len <= 2*2^k=2^{k+1},也就是找到小于len区间长度的2的幂次的最大值k
则L开始的2^k个数  和  以R为结尾的2^k个数 这两段区间一定覆盖整个区间[L,R],这两段最大值分别是f[L][k]和f[R-2^k+1][k]
两者最大值就是整个区间的最大值，因为求的是最大值，所以就算是有重叠也没有关系
k可以先预处理好logk/log2

缺点：不能修改，是静态的，线段树可以支持动态修改
```

**代码：**

``` c
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <cmath>

using namespace std;
//j=log2(2*1e5)    65536=2^16   2^17>>int的值了 
const int N = 2e5+10,M =18;

int n,m;
int w[N];
int f[N][M];

void init()
{
	for(int j=0;j<M;j++){
		//右边不能超过终点,2^j-1的长度 
//		for(int i=1;i<=n-(1<<j)+1;j++){
		for(int i=1;i+(1<<j)-1<=n;i++){
			//表示只有一个数，f[i][0]就是[i,i]区间里面最大值
			if(!j) f[i][j]=w[i];
			//两个区间里面的最大值 
			else f[i][j]=max(f[i][j-1],f[i+(1<<(j-1))][j-1]);	 
		}
	}
} 

int query(int l,int r){
	int len=r-l+1; //长度
	int k=log(len)/log(2);
    //L开始的2^k个数  和  以R为结尾的2^k个数 这两段区间一定覆盖整个区间[L,R],这两段最大值分别是f[L][k]和f[R-2^k+1][k]
	return max(f[l][k],f[r-(1<<k)+1][k]); 
} 

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&w[i]);
	//初始化st表 
	init();
	
	scanf("%d",&m);
	while(m--){
		int l,r;
		scanf("%d%d",&l,&r);
		printf("%d\n",query(l,r));
	}	
	return 0;
} 
```







#### 1.2 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```





#### 1.2 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```





