# 题型整理

[TOC]

## 一、递归

### 1、递归知识点题目

#### **[题目：AcWing 92. 递归实现指数型枚举]()**

**题目描述**

从 1∼n 这 n 个整数中随机选取任意多个，输出所有可能的选择方案。

**输入格式**

输入一个整数 n。

**输出格式**

每行输出一种方案。

同一行内的数必须升序排列，相邻两个数用恰好 1 个空格隔开。

对于没有选任何数的方案，输出空行。

本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。

**数据范围**

$1≤n≤15$

**输入样例：**

```c
3
```

**输出样例：**

```c

3
2
2 3
1
1 3
1 2
1 2 3
```

**题解：**

``` c
dfs
```

**代码：**

```c
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>

using namespace std;

const int N=16;
vector<vector<int>> res;
int st[N];  //状态 0：表示还没考虑  1：选  2：不选

int n;

void dfs(int u){
    if(u>n){
        vector<int> path;
        for(int i=1;i<=n;i++){
            if(st[i]==1)
                path.push_back(i);
        }
        res.push_back(path);
        return;
    }
    
    st[u]=1;    // 选
    dfs(u+1);
    st[u]=0;    //恢复现场
    
    st[u]=2;    //不选
    dfs(u+1);
    st[u]=0;    //恢复现场
}

int main(){
    cin>>n;
    dfs(1);
    for(int i=0;i<res.size();i++){
        for(int j=0;j<res[i].size();j++){
            printf("%d ",res[i][j]);
        }
        puts("");
    }
    return 0;
}
```



#### **[题目：AcWing 94. 递归实现排列型枚举]()**

**题目描述**

把 1∼n 这 n 个整数排成一行后随机打乱顺序，输出所有可能的次序。

**输入格式**

一个整数 n。

**输出格式**

按照从小到大的顺序输出所有方案，每行 1 个。

首先，同一行相邻两个数用一个空格隔开。

其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。

**数据范围**

$1≤n≤9$

**输入样例：**

```c
3
```

**输出样例：**

```c
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```

**题解：**

``` c
排列考虑顺序
    123
    132
    213
    231
    312
    321
组合不考虑顺序
    12345选3个
    1 2 3 
	1 2 4 
	1 2 5 
	1 3 4 
	1 3 5 
	1 4 5 
	2 3 4 
	2 3 5 
	2 4 5 
	3 4 5 
    
顺序1：依次枚举每个数放到哪个位置
顺序2：依次枚举每个位置放哪个数
    递归搜索树
```

**代码：**

```c
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>

using namespace std;
const int N=10;
int st[N];  // 0 表示还没放数，1~n表示放了哪个数
bool used[N];    //是否使用，true表示已经使用，false:表示未使用
int n;

void dfs(int u){
    if(u>n){
        //输出方案
        for(int i=1;i<=n;i++) printf("%d ",st[i]);
        puts("");
        return;
    }
    // 依次枚举每个分支，即当前位置可以填哪些数
    for(int i=1;i<=n;i++){
        if(!used[i]){
            st[u]=i;
            used[i]=true;
            dfs(u+1);
            //恢复现场
            st[u]=0;
            used[i]=false;
        }
    }
}

int main(){
    scanf("%d",&n);
    dfs(1);
    return 0;
}
```



#### **[题目：AcWing 93. 递归实现组合型枚举]()**

**题目描述**

从 1∼n这 n 个整数中随机选出 m 个，输出所有可能的选择方案。

**输入格式**

两个整数 n,m ,在同一行用空格隔开。

**输出格式**

按照从小到大的顺序输出所有方案，每行 1 个。

首先，同一行内的数升序排列，相邻两个数用一个空格隔开。

其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如 `1 3 5 7` 排在 `1 3 6 8` 前面）。

**数据范围**

$n>0 ,$
$0≤m≤n ,$
$n+(n−m)≤25$

**输入样例：**

```c
5 3
```

**输出样例：**

```c
1 2 3 
1 2 4 
1 2 5 
1 3 4 
1 3 5 
1 4 5 
2 3 4 
2 3 5 
2 4 5 
3 4 5 
```

**题解：**

``` c
限制：从小到大排序、
    局部
    只需要保证每次新加入的数大于前一个数a1<a2,a2<a3...
```

**代码：**

```c
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <iostream>

using namespace std;
const int N=30;
int n,m;
int st[N];

//u表示当前位置，start表示下一个可以选择的数
void dfs(int u,int start){
    if(u==m+1){
        for(int i=1;i<=m;i++) printf("%d ",st[i]);
        puts("");
        return;
    }
    for(int i=start;i<=n;i++){
        st[u]=i;    // u位置放i
        dfs(u+1,i+1); // 下一个位置i+1
        st[u]=0;    //  恢复现场
    }
}

int main(){
    scanf("%d%d",&n,&m);
    dfs(1,1);
    return 0;
}
```

**优化剪枝：**

到位置u选择了u-1个数，后面还有n-start+1个数可以选择

如果把后面的所有数都选择还凑不够m个数，则不满足

u-1 + n-start+1<m

u+n+start<m

```c
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <iostream>

using namespace std;
const int N=30;
int n,m;
int st[N];

//u表示当前位置，start表示下一个可以选择的数
void dfs(int u,int start){
    if(u+n+start<m) return; // 剪枝
    if(u==m+1){
        for(int i=1;i<=m;i++) printf("%d ",st[i]);
        puts("");
        return;
    }
    for(int i=start;i<=n;i++){
        st[u]=i;    // u位置放i
        dfs(u+1,i+1); // 下一个位置i+1
        st[u]=0;    //  恢复现场
    }
}

int main(){
    scanf("%d%d",&n,&m);
    dfs(1,1);
    return 0;
}
```



#### **[题目：AcWing 1209. 带分数 ]()**

**题目描述**

100可以表示为带分数的形式：100=3+69258 / 714

还可以表示为：100=82+3546 / 197

注意特征：带分数中，数字 1∼9分别出现且只出现一次（不包含 0）。

类似这样的带分数，100 有 11种表示法。

**输入格式**

一个正整数。

**输出格式**

输出输入数字用数码 1∼9 不重复不遗漏地组成带分数表示的全部种数。

**数据范围**

$1≤N<10^6$

**输入样例：**

```c
100
```

**输出样例：**

```c
11
```

**题解：**

``` c
带分数解法一：全排列分割求法(朴素法)
算法的基本思路：完成从1~9的全排列，将全排列的结果分割为三个数，判断结果是否满足条件
```

**代码：**

```c
#include<iostream>

using namespace std;

const int N=10;
int n;
int res;
bool st[N];
int path[N];

int get(int l,int r)//求解分割过后的数值大小
{
    int m=0;
    for(int i=l;i<=r;i++)
    {
        m=m*10+path[i]; 
    }
    return m;
}

bool check(int a,int b,int c)//判断数值是否满足条件
{
    //n=a+b/c  ==>  nc=ac+b
    if(n*c-a*c==b)return true;
    return false;
}

void dfs(int u)
{
    if(u>=N)//已经完成全排列，用双重循环将全排列划分为三个数字
    {
        //a最大7位数，留两位给b 和c
        for(int i=1;i<=7;i++)
        {
            //因为至少要3个数  所以你的j不能超过8 如果b超过8  那么c就无法是数了
            for(int j=i+1;j<=8;j++)
            {
               //a的位数代表了从第1位到第i位   b的位数代表了从i+1位开始 到第j位  c是第j+1到第9位
                //因为一共就9位  数组从1下标开始    1~9
                int a=get(1,i); //分别将此时a b c的数值表示出来
                int b=get(i+1,j);
                int c=get(j+1,9);
                if(check(a,b,c))res++; //判断是否符合题目条件
            }
        }
        return;
    }
    for(int i=1;i<N;i++)    //dfs求排列型递归
    {
        if(!st[i])
        {
            path[u]=i;
            st[i]=true;
            dfs(u+1);
            st[i]=false;
            path[u]=0;
        }
    }
}

int main()
{
    cin>>n;
    dfs(1);
    cout<<res<<endl;
    return 0;
}
```

**y总优化代码：**

```
1、枚举a   dfs_a()
2、枚举c	dfs_c()
3、判断b是否满足

```

```c
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 10;

int n;
bool st[N], backup[N];
int ans;

//验证
bool check(int a, int c)
{
    long long b = n * (long long)c - a * c;

    if (!a || !b || !c) return false;

    memcpy(backup, st, sizeof st);
    while (b)
    {
        int x = b % 10;     // 取个位
        b /= 10;    // 个位删掉
        //x为0或者之前出现过了
        if (!x || backup[x]) return false;
        backup[x] = true;
    }

    for (int i = 1; i <= 9; i ++ )
        if (!backup[i])
            return false;

    return true;
}

void dfs_c(int u, int a, int c)
{
    //if(u==n) return;
    if (u > 9) return;

    if (check(a, c)) ans ++ ;

    for (int i = 1; i <= 9; i ++ )
        if (!st[i])
        {
            st[i] = true;
            //更新c的值
            dfs_c(u + 1, a, c * 10 + i);
            st[i] = false;
        }
}

//u表示当前已经用了多少数字，a表示当前数
void dfs_a(int u, int a)
{
    if (a >= n) return;
    if (a) dfs_c(u, a, 0);

    for (int i = 1; i <= 9; i ++ )
        if (!st[i])
        {
            st[i] = true;
            //更新a的值，先a*10+i
            dfs_a(u + 1, a * 10 + i);
            st[i] = false;
        }
}

int main()
{
    cin >> n;

    dfs_a(0, 0);

    cout << ans << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/159648/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



### 2、递推

#### **[题目：AcWing 717. 简单斐波那契]()**

**题目描述**

以下数列 `0 1 1 2 3 5 8 13 21 ...` 被称为斐波纳契数列。

这个数列从第 3 项开始，每一项都等于前两项之和。

输入一个整数 N，请你输出这个序列的前 N 项。

**输入格式**

一个整数 N。

**输出格式**

在一行中输出斐波那契数列的前 N 项，数字之间用空格隔开。

**数据范围**

$0<N<46$

**输入样例：**

```c
5
```

**输出样例：**

```c
0 1 1 2 3
```

**题解：**

``` c

```

**代码：**

```c
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

int main()
{
    int a = 0, b = 1;
    int n;
    cin >> n;

    for (int i = 0; i < n; i ++ )
    {
        cout << a << ' ';
        int c = a + b;
        a = b, b = c;
    }

    cout << endl;

    return 0;
}
```



#### **[题目：AcWing 95. 费解的开关]()**

**题目描述**

你玩过“拉灯”游戏吗？

25 盏灯排成一个 5×5 的方形。

每一个灯都有一个开关，游戏者可以改变它的状态。

每一步，游戏者可以改变某一个灯的状态。

游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。

我们用数字 1 表示一盏开着的灯，用数字 0 表示关着的灯。

下面这种状态

```
10111
01101
10111
10000
11011
```

在改变了最左上角的灯的状态后将变成：

```
01111
11101
10111
10000
11011
```

再改变它正中间的灯后状态将变成：

```
01111
11001
11001
10100
11011
```

给定一些游戏的初始状态，编写程序判断游戏者是否可能在 6 步以内使所有的灯都变亮。

**输入格式**

第一行输入正整数 n，代表数据中共有 n 个待解决的游戏初始状态。

以下若干行数据分为 n 组，每组数据有 5 行，每行 5 个字符。

每组数据描述了一个游戏的初始状态。

各组数据间用一个空行分隔。

**输出格式**

一共输出 n 行数据，每行有一个小于等于 6 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。

对于某一个游戏初始状态，若 6 步以内无法使所有灯变亮，则输出 −1。

**数据范围**

$0<n≤500$

**输入样例：**

```c
3
00111
01011
10001
11010
11100

11101
11101
11110
11111
11111

01111
11111
11111
11111
11111
```

**输出样例：**

```c
3
2
-1
```

**题解：**

``` c
递推-算法竞赛进阶指南
```

**代码：**

```c
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <iostream>

using namespace std;
const int N=6;
char g[N][N],backup[N][N];
int dx[5]={0,-1,0,1,0},dy[5]={0,0,1,0,-1};

void turn(int x,int y){
    for(int i=0;i<5;i++){
        int a=x+dx[i],b=y+dy[i];
        if(a<0 || a>=5||b<0 ||b>=5) continue;
        g[a][b]^=1; //如果没有越界，则附近四个位置和中间一个位置，转变为相反的状态
    }
}

int main(){
    int T;
    cin>>T;
    while(T--){
        //每一行一共5个位置，每个位置按或者不按，一共32种可能
        for(int i=0;i<5;i++) cin>>g[i];
        
        int res=10;
        for(int op=0;op<32;op++){
            memcpy(backup,g,sizeof g);
            int k=0;    //操作了多少步
            //先处理第一行
            for(int i=0;i<5;i++){
                //如果当前位为1
                if(op>>i&1){
                    k++;
                    turn(0,i);
                }
            }
            
            //处理到第倒数第二行
            for(int i=0;i<4;i++){
                for(int j=0;j<5;j++){
                    //如果当前位置需要按，则将这个位置的下一行反转
                    if(g[i][j]=='0'){
                        k++;
                        turn(i+1,j);
                    }
                }
            }
            
            //处理最后一行，如果有0则不满足
            bool flag=false;    
            for(int i=0;i<5;i++){
                if(g[4][i]=='0'){
                    flag=true;
                    break;
                }
            }
            if(!flag) 
                res=min(res,k);
            memcpy(g,backup,sizeof g);
        }
        if(res>6) res=-1;
        cout<<res<<endl;
    }
    return 0;
}
```



#### **[题目：AcWing 116. 飞行员兄弟]()**todo

**题目描述**

“飞行员兄弟”这个游戏，需要玩家顺利的打开一个拥有 16 个把手的冰箱。

已知每个把手可以处于以下两种状态之一：打开或关闭。

只有当所有把手都打开时，冰箱才会打开。

把手可以表示为一个4×4 的矩阵，您可以改变任何一个位置$ [i,j] $上把手的状态。

但是，这也会使得第 i 行和第 j 列上的所有把手的状态也随着改变。

请你求出打开冰箱所需的切换把手的次数最小值是多少。

**输入格式**

输入一共包含四行，每行包含四个把手的初始状态。

符号 `+` 表示把手处于闭合状态，而符号 `-` 表示把手处于打开状态。

至少一个手柄的初始状态是关闭的。

**输出格式**

第一行输出一个整数 N，表示所需的最小切换把手次数。

接下来 N 行描述切换顺序，每行输出两个整数，代表被切换状态的把手的行号和列号，数字之间用空格隔开。

**注意**：如果存在多种打开冰箱的方式，则按照优先级整体从上到下，同行从左到右打开。

**数据范围**

$1≤i,j≤4$

**输入样例：**

```c
-+--
----
----
-+--
```

**输出样例：**

```c
6
1 1
1 3
1 4
4 1
4 3
4 4
```

**题解：**

``` c

```

**代码：**

```c

```



#### **[题目：AcWing 1208. 翻硬币  ]()**

**题目描述**

小明正在玩一个“翻硬币”的游戏。

桌上放着排成一排的若干硬币。我们用 * 表示正面，用 o 表示反面（是小写字母，不是零）。

比如，可能情形是：`**oo***oooo`

如果同时翻转左边的两个硬币，则变为：`oooo***oooo`

现在小明的问题是：如果已知了初始状态和要达到的目标状态，每次只能同时翻转相邻的两个硬币,那么对特定的局面，最少要翻动多少次呢？

我们约定：把翻动相邻的两个硬币叫做一步操作。

**输入格式**

两行等长的字符串，分别表示初始状态和要达到的目标状态。

**输出格式**

一个整数，表示最小操作步数

**数据范围**

输入字符串的长度均不超过100。
数据保证答案一定有解。

**输入样例：**

```c
**********
o****o****
```

**输出样例：**

```c
5
```

**题解：**

``` c
递推，同费解的开关
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdio>
using namespace std;

int n;
const int N = 110;
char st[N], ed[N];

void turn(int i)
{
    if (st[i] == '*')
        st[i] = 'o';
    else
        st[i] = '*';
}

int main()
{
    int res = 0;
    cin >> st >> ed;
    n = strlen(st);

    //一定保证存在答案，则最后一下一定不需要反转
    for (int i = 0; i < n - 1; i++)
    {
        if (st[i] != ed[i])
        {
            turn(i), turn(i + 1);
            res++;
        }
    }
    cout << res << endl;
    return 0;
}
```



## 二、二分

### 1、整数二分

#### **[题目：789. 数的范围]()**

**题目描述**

给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。

对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。

如果数组中不存在该元素，则返回 `-1 -1`。

**输入格式**

第一行包含整数 n 和 q，表示数组长度和询问个数。

第二行包含 n 个整数（均在 1∼10000范围内），表示完整数组。

接下来 q 行，每行包含一个整数 k，表示一个询问元素。

**输出格式**

共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。

如果数组中不存在该元素，则返回 `-1 -1`。

**数据范围**

$1≤n≤100000$
$1≤q≤10000$
$1≤k≤10000$

**输入样例：**

```c
6 3
1 2 2 3 3 4
3
4
5
```

**输出样例：**

```c
3 4
5 5
-1 -1
```

**题解：**

``` c
二分模板
```

**代码：**

```c
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>

using namespace std;
const int N = 100010;
int q[N];
int n,m;

int main(){
    scanf("%d%d",&n,&m);
    for(int i=0;i<n;i++) scanf("%d",&q[i]);
    
    for(int i=0;i<m;i++){
        int x;
        scanf("%d",&x);
        //找左端点
        int l=0,r=n-1;
        while(l<r){
            int mid=l+r>>1;
            if(q[mid]>=x) r=mid;
            else l=mid+1;
        }
        if(q[r]==x){
            cout<<r<<" ";
            r=n-1;
            while(l<r){
                int mid=l+r+1>>1;
                if(q[mid]<=x) l=mid;
                else r=mid-1;
            }
            cout<<r<<endl;
        }
        else cout<<"-1 -1"<<endl;
    }
    return 0;
}
```



#### **[题目：730. 机器人跳跃问题]()**

**题目描述**

机器人正在玩一个古老的基于 DOS 的游戏。

游戏中有N+1 座建筑——从 0 到 N 编号，从左到右排列。

编号为 0 的建筑高度为 0 个单位，编号为 i 的建筑高度为 H(i) 个单位。

起初，机器人在编号为 0 的建筑处。

每一步，它跳到下一个（右边）建筑。

假设机器人在第 kk 个建筑，且它现在的能量值是 E，下一步它将跳到第 k+1 个建筑。

如果 H(k+1)>E，那么机器人就失去 H(k+1)−E 的能量值，否则它将得到)E−H(k+1) 的能量值。

游戏目标是到达第 N 个建筑，在这个过程中能量值不能为负数个单位。

现在的问题是机器人至少以多少能量值开始游戏，才可以保证成功完成游戏？

**输入格式**

第一行输入整数 N。

第二行是 N 个空格分隔的整数，H(1),H(2),…,H(N) 代表建筑物的高度。

**输出格式**

输出一个整数，表示所需的最少单位的初始能量值上取整后的结果。

**数据范围**

$1≤N,H(i)≤10^5$

**输入样例1：**

```c
5
3 4 3 2 4
```

**输出样例1：**

```c
4
```

**输入样例2：**

```c
3
4 4 4
```

**输出样例2：**

```c
4
```

**输入样例3：**

```c
3
1 6 4
```

**输出样例3：**

```c
3
```

**题解：**

``` c
1、二段性：
①h(k+1)>E     E-(h(k+1)-E)=2E-h(k+1)
②h(k+1)<E     E+(E-h(k+1))=2E-h(k+1)
    
初始的能量E0可以满足，则是否E0`>=E0是否也一定满足需要？
E0  E1  E2  E3  ...  En  Ei>=0
E0` E1` E2` E3` ...  En` Ei`?>=0
由归纳法：  
E1`=2E0`-h1>=2E0-h1=E1
所以E0`>=E0都满足
    
2、二分
    L..........mid.........R
    mid对应的E满足条件，则mid右边的部分到R都满足，这里题目要找的是最小的值，则答案应该取到mid及mid左边部分
    mid=(l+r)>>1
    if(check(mid)) R=mid;
	else L=mid+1;

3、注意
    假设中间所有建筑物的高度的最大值是maxh
    某一时刻E>=maxh
    更新的时候 maxh-h(i)>=0：
    2E-h(i)=E+E-h(i)>=E+maxh-h(i)>=E,则该位置之后严格单调递增
```

**代码：**

```c
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
using namespace std;

const int N=100010;
int n;
int h[N];

bool check(int e){
    //递归能量
    for(int i=0;i<n;i++){
        e=2*e-h[i];
        //如果大于最大值，则单调递增
        if(e>=1e5) return true;
        if(e<0) return false;
    }
    return true;
}

int main(){
    scanf("%d",&n);
    for(int i=0;i<n;i++) scanf("%d",&h[i]);
    
    int l=0,r=1e5;
    while(l<r){
        int mid=l+r>>1;
        if(check(mid)) r=mid;
        else l=mid+1;
    }
    printf("%d\n",r);
    return 0;
}
```



#### **[题目：1221. 四平方和]()**

**第七届蓝桥杯省赛C++A/B组,第七届蓝桥杯省赛JAVA B/C组**

**题目描述**

四平方和定理，又称为拉格朗日定理：

每个正整数都可以表示为至多 4 个正整数的平方和。

如果把 0 包括进去，就正好可以表示为 4 个数的平方和。

比如：

$5=0^2+0^2+1^2+2^2$
$7=1^2+1^2+1^2+2^2$

对于一个给定的正整数，可能存在多种平方和的表示法。

要求你对 4 个数排序：

$0≤a≤b≤c≤d$

并对所有的可能表示法按 a,b,c,d为联合主键升序排列，最后输出第一个表示法。

**输入格式**

输入一个正整数 N。

**输出格式**

输出4个非负整数，按从小到大排序，中间用空格分开。

**数据范围**

$0<N<5∗10^6$

**输入样例：**

```c
5
```

**输出样例：**

```c
0 0 1 2
```

**代码：**

**暴力**$O(N^3)$

```c
#include <cstring>
#include <cstdio>
#include <iostream>
#include <cmath>

using namespace std;

const int N=2500010;

int n;

int main(){
    scanf("%d",&n);
    
    for(int a=0;a*a<=n;a++){
        for(int b=a;a*a+b*b<=n;b++){
            for(int c=b;a*a+b*b+c*c<=n;c++){
                int t=n-a*a-b*b-c*c;
                int s=sqrt(t);
                if(s*s==t){
                    printf("%d %d %d %d\n",a,b,c,s);
                    return 0;
                }
            }
        }
    }
    return 0;
}
```

**哈希表**$O(N^2)$

```c
#include <cstring>
#include <iostream>
#include <algorithm>
#include <unordered_map>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 2500010;

int n, m;
unordered_map<int, PII> S;

int main()
{
    cin >> n;

    for (int c = 0; c * c <= n; c ++ )
        for (int d = c; c * c + d * d <= n; d ++ )
        {
            int t = c * c + d * d;
            if (S.count(t) == 0) S[t] = {c, d};
        }

    for (int a = 0; a * a <= n; a ++ )
        for (int b = 0; a * a + b * b <= n; b ++ )
        {
            int t = n - a * a - b * b;
            if (S.count(t))
            {
                printf("%d %d %d %d\n", a, b, S[t].x, S[t].y);
                return 0;
            }
        }

    return 0;
}
```

**二分**$O(N^2logN)$

```c
#include <cstring>
#include <cstdio>
#include <iostream>
#include <algorithm>

using namespace std;

const int N=2500010;

int n,m;

struct Sum{
    int s,c,d;
    bool operator<(const Sum &t)const{
        if(s!=t.s) return s<t.s;
        if(c!=t.c) return c<t.c;
        return d<t.d;
    }
}sum[N];

int main(){
    scanf("%d",&n);
    
    for(int c=0;c*c<=n;c++){
        for(int d=c;c*c+d*d<=n;d++){
            int t=c*c+d*d;
            sum[m++]={c*c+d*d,c,d};
        }
    }
    sort(sum,sum+m);
    
    for(int a=0;a*a<=n;a++){
        for(int b=a;a*a+b*b<=n;b++){
            int t=n-a*a-b*b;
            int l=0,r=m-1;
            while(l<r){
                int mid=l+r>>1;
                if(sum[mid].s>=t) r=mid;
                else l=mid+1;
            }
            if(sum[l].s==t){
                printf("%d %d %d %d\n",a,b,sum[l].c,sum[l].d);
                return 0;
            }
        }
    }
    return 0;
}
```



#### **[题目：1227. 分巧克力]()**

**第八届蓝桥杯省赛C++A/B组,第八届蓝桥杯省赛JAVAA/B组**

**题目描述**

儿童节那天有 K 位小朋友到小明家做客。

小明拿出了珍藏的巧克力招待小朋友们。

小明一共有 N 块巧克力，其中第 i 块是$H_i×W_i$ 的方格组成的长方形。

为了公平起见，小明需要从这 N 块巧克力中切出 K 块巧克力分给小朋友们。

切出的巧克力需要满足：

1. 形状是正方形，边长是整数
2. 大小相同

例如一块 6×5 的巧克力可以切出 6 块 2×2 的巧克力或者 2 块 3×3 的巧克力。

当然小朋友们都希望得到的巧克力尽可能大，你能帮小明计算出最大的边长是多少么？

**输入格式**

第一行包含两个整数 N 和 K。

以下 N 行每行包含两个整数 Hi 和 Wi。

输入保证每位小朋友至少能获得一块 1×1 的巧克力。

**输出格式**

输出切出的正方形巧克力最大可能的边长。

**数据范围**

$1≤N,K≤10^5,$
$1≤H_i,W_i≤10^5$

**输入样例：**

```c
2 10
6 5
5 6
```

**输出样例：**

```c
2
```

**题解：**

``` c
假设正方形的边长是mid,则对于长方形h[i]*w[i]可以组成的正方形为(h[i]/mid)*(w[i]/mid)
正方形的最小边长是1,题目保证了最小都有答案1，最大是上界1e5
```

**代码：**

```c
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
using namespace std;

const int N=100010;

int h[N],w[N];

int n,k;

bool check(int mid){
    int res=0;
    for(int i=0;i<n;i++){
        res+=(h[i]/mid)*(w[i]/mid);
        if(res>=k) return true;
    }
    return false;
}

int main(){
    scanf("%d%d",&n,&k);
    for(int i=0;i<n;i++) scanf("%d%d",&h[i],&w[i]);
    
    int l=1,r=1e5;
    while(l<r){
        int mid=(l+r+1)>>1;
        if(check(mid)) l=mid;
        else r=mid-1;
    }
    
    printf("%d",r);
    return 0;
}
```



### 2、实数二分

```
将区间[L,R]划分为[L,Mid]和[Mid,R]
精度为n，则设置eps=1e(-(n+2))
```

#### **[题目：790. 数的三次方根]()**

**题目描述**

 给定一个浮点数 n，求它的三次方根。

**输入格式**

共一行，包含一个浮点数 n。

**输出格式**

共一行，包含一个浮点数，表示问题的解。

注意，结果保留 6 位小数。

**数据范围**

$−10000≤n≤10000$

**输入样例：**

```c
1000.00
```

**输出样例：**

```c
10.000000
```

**题解：**

``` c
注意mid=(l+r)/2
```

**代码：**

```c
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>

using namespace std;

int main(){
    double x;
    cin>>x;
    double l=-10000,r=10000;
    while(r-l>1e-8){
        double mid=(l+r)/2;
        if(mid*mid*mid >=x) r=mid;
        else l=mid;
    }
    printf("%.6lf",r);
    return 0;
}
```



### 3、前缀和

#### **[题目：795. 前缀和](https://www.acwing.com/problem/content/797/)**(一维模板)

**题目描述**

输入一个长度为 n的整数序列。

接下来再输入 m 个询问，每个询问输入一对 l,r。

对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。

**输入格式**

第一行包含两个整数 n 和 m。

第二行包含 n 个整数，表示整数数列。

接下来 m 行，每行包含两个整数 l 和 r，表示一个询问的区间范围。

**输出格式**

共 m 行，每行输出一个询问的结果。

**数据范围**

1≤l≤r≤n,
1≤n,m≤100000，
−1000≤数列中元素的值≤1000

**输入样例：**

```c
5 3
2 1 3 6 4
1 2
1 3
2 4
```

**输出样例：**

```c
3
6
10
```

**题解：**

``` c
前缀和模板
```

**代码：**

```c
#include <bits/stdc++.h>
using namespace std;

const int N=100010;

int n,m;
int a[N],s[N];

int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        s[i]=s[i-1]+a[i];
    }
    while(m--){
        int l,r;
        scanf("%d%d",&l,&r);
        printf("%d\n",s[r]-s[l-1]);
    }
    return 0;
}
```



#### **[题目：796. 子矩阵的和 ]()**（二维模板）

**题目描述**

输入一个 *n* 行 *m* 列的整数矩阵，再输入 *q* 个询问，每个询问包含四个整数 *x*1,*y*1,*x*2,*y*2，表示一个子矩阵的左上角坐标和右下角坐标。对于每个询问输出子矩阵中所有数的和。

**输入格式**

第一行包含三个整数 *n*，*m*，*q*。接下来 *n*行，每行包含 *m*个整数，表示整数矩阵。接下来 *q* 行，每行包含四个整数 *x*1,*y*1,*x*2,*y*2，表示一组询问。

**输出格式**

共 *q* 行，每行输出一个询问的结果。

**数据范围**

1≤*n*,*m*≤1000,
 1≤*q*≤200000,
 1≤*x*1≤*x*2≤*n*,
 1≤*y*1≤*y*2≤*m*,
 −1000≤矩阵内元素的值≤1000

**输入样例：**

```c
3 4 3
1 7 2 4
3 6 2 8
2 1 2 3
1 1 2 2
2 1 3 4
1 3 3 4
```

**输出样例：**

```c
17
27
21
```

**题解：**

``` c
1、如何计算前缀和矩阵（容斥原理）
    S[x][y]=S[x-1][y]+S[x][y-1]-S[x-1][y-1]+a[x][y]
    
2、如何利用前缀和矩阵计算某一个子矩阵的和？（容斥原理）
    [x1][y1]~[x2][y2]=S[x2][y2]-S[x2][y1-1]-S[x1-1][y2]+S[x1-1][y1-1]
    
3、下标从1开始
```

**代码：**

```c
#include <cstring>
#include <cstdio>
#include <iostream>
#include <algorithm>

using namespace std;
const int N=1010;
int n,m,q;

int a[N][N],s[N][N];

int main()
{
    scanf("%d%d%d",&n,&m,&q);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            scanf("%d",&a[i][j]);
            s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];
        }
    }
    while(q--){
        int x1,x2,y1,y2;
        scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
        printf("%d\n",s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1]);
    }
    return 0;
}
```



## 三、数学与简单DP

## 1、数学

#### **[题目：1205. 买不到的数目 ]()**

**题目描述**

小明开了一家糖果店。

他别出心裁：把水果糖包成4颗一包和7颗一包的两种。

糖果不能拆包卖。

小朋友来买糖的时候，他就用这两种包装来组合。

当然有些糖果数目是无法组合出来的，比如要买 10 颗糖。

你可以用计算机测试一下，在这种包装情况下，最大不能买到的数量是17。

大于17的任何数字都可以用4和7组合出来。

本题的要求就是在已知两个包装的数量时，求最大不能组合出的数字。

**输入格式**

两个正整数 *n*,*m*，表示每种包装中糖的颗数。

**输出格式**

一个正整数，表示最大不能买到的糖数。

**数据范围**

$2≤n,m≤1000$，
 保证数据一定有解。

**输入样例：**

```c
4 7
```

**输出样例：**

```c
17
```

**题解：**

[AcWing 525. 小凯的疑惑 ](https://www.acwing.com/solution/content/3165/)

``` c
如果 a,b 均是正整数且互质，那么由 ax+by,x≥0,y≥0 不能凑出的最大数是 ab−a−b。

(1)尽力分析  公约数：d={p、q}>0
    
(2)打表找规律不能凑的数m
{p、q}=1  互质
(p-1)(q-1)-1=m    
打表代码如下：  
#include <iostream>
using namespace std;
//看pq能否凑出来m
bool dfs(int m,int p,int q){
    if(!m) return true;
    if(m>=p && dfs(m-p,p,q)) return true;
    if(m>=q && dfs(m-q,p,q)) return true;
    return false;
}
int main()
{
    int res,p,q;
    cin>>p>>q;
    for(int i=1;i<=1000;i++){
        //如果i不能凑出来
        if(!dfs(i,p,q)) res=i;
    }
    cout<<res<<endl;
    return 0;
}
/*
3 2 1
3 4 5
3 5 7
3 7 11
3 8 13
*/
```

**代码：**

```c
#include <iostream>
using namespace std;

int main()
{
    int res,p,q;
    cin>>p>>q;
    cout<<(p-1)*(q-1)-1<<endl;
    return 0;
}
```



#### **[题目：1211. 蚂蚁感冒 ]()**

**题目描述**

长 100 厘米的细长直杆子上有 *n* 只蚂蚁。

它们的头有的朝左，有的朝右。 

每只蚂蚁都只能沿着杆子向前爬，速度是 1厘米/秒。

当两只蚂蚁碰面时，它们会同时掉头往相反的方向爬行。

这些蚂蚁中，有 1只蚂蚁感冒了。

并且在和其它蚂蚁碰面时，会把感冒传染给碰到的蚂蚁。

请你计算，当所有蚂蚁都爬离杆子时，有多少只蚂蚁患上了感冒。

**输入格式**

第一行输入一个整数 *n*, 表示蚂蚁的总数。

接着的一行是 *n*个用空格分开的整数 $X_i, X_i$ 的绝对值表示蚂蚁离开杆子左边端点的距离。

正值表示头朝右，负值表示头朝左，数据中不会出现 0值，也不会出现两只蚂蚁占用同一位置。

其中，第一个数据代表的蚂蚁感冒了。

**输出格式**

输出1个整数，表示最后感冒蚂蚁的数目。

**数据范围**

$1<n<50$,
 $0<|X_i|<100$

**输入样例1：**

```c
3
5 -2 8
```

**输出样例1：**

```c
1
```

**输入样例2：**

```c
5
-10 8 -20 12 25
```

**输出样例2：**

```c
3
```

**题解：**

``` c
1、性质：掉头等价于穿过，就是所有的蚂蚁都会走出
int left = 0, right = 0;    // 分别表示左边向右走的蚂蚁数量，和右边向左走的蚂蚁数量
2、将感冒的蚂蚁的左右两边分开
    a、感冒的蚂蚁向右走的情况：
    (1) 右边向左走的，必然被感染（算）
	(2) 右边向右走，必然不会被感染
	(3) 左边向左走，必然不会被感染
	(4) 左边向右走：
		1) 右边存在向左走，则必然被感染（算）
		2) 右边不存在向左走，则必然不会被感染
    1表示感冒蚂蚁本身
    if right>0  res=left+right+1;
	if right==0  res=1
    
    b、感冒的蚂蚁向左走的情况：
    (1) 左边向左走的，必然不被感染
	(2) 左边向右走，必然被感染（算）
    (3) 右边向右走，必然不会被感染
	(4) 右边向左走：
		1) 左边存在向右走，则必然被感染（算）
		2) 左边不存在向右走，则必然不会被感染
    if left>0  res=left+right+1;
	if left==0  res=1
```

**代码：**

```c
#include <iostream>
using namespace std;
const int N=55;
int n;
int a[N];

int main()
{
    int left = 0, right = 0;    // 分别表示左边向右走的蚂蚁数量，和右边向左走的蚂蚁数量
    cin>>n;
    for(int i=0;i<n;i++) cin>>a[i];
    
    for(int i=1;i<n;i++){
        if(abs(a[i])<abs(a[0]) && a[i]>0) left++;
        else if(abs(a[i])>abs(a[0]) && a[i]<0) right++;
    }
    //只有感冒蚂蚁，没有相遇res=1
    if (a[0] > 0 && right == 0 || a[0] < 0 && left == 0) cout << 1 << endl;
    else cout << left + right + 1 << endl;
    return 0;
}
```



#### **[题目：1216. 饮料换购 ]()**

**题目描述**

乐羊羊饮料厂正在举办一次促销优惠活动。乐羊羊C型饮料，凭3个瓶盖可以再换一瓶C型饮料，并且可以一直循环下去(但不允许暂借或赊账)。

请你计算一下，如果小明不浪费瓶盖，尽量地参加活动，那么，对于他初始买入的 *n*

 瓶饮料，最后他一共能喝到多少瓶饮料。

**输入格式**

输入一个整数 *n*,表示初始买入的饮料数量。

**输出格式**

输出一个整数，表示一共能够喝到的饮料数量。

**数据范围**

$0<n<10000$

**输入样例：**

```c
100
```

**输出样例：**

```c
149
```

**题解：**

``` c
迭代
    a/b上取整=（a+b-1/b）下取整
```

**代码：**

```c
#include <iostream>
using namespace std;

int main()
{
    int n,res;
    cin>>n;
    res=n;
    while(n>=3){
        //瓶子：n/3
        //盖子：n%3        
        res+=n/3;
        n=n/3+(n%3);
    }
    cout<<res<<endl;
    return 0;
}
```



### 2、简单DP

#### **[题目：AcWing 2. 01背包问题]()**(组合模型)

**题目描述**

有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。

第 i 件物品的体积是 $v_i$，价值是 $w_i$。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

**输入格式**

第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。

接下来有 N 行，每行两个整数$v_i,w_i$，用空格隔开，分别表示第 i 件物品的体积和价值。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

$0 < N,V ≤ 1000$

$0<vi,wi≤1000$

**输入样例：**

```c
4 5
1 2
2 4
3 4
4 5
```

**输出样例：**

```c
8
```

**题解：**

``` c
每件物品最多只能用一次
DP  1.状态(一个集合)表示
		二维：f(i,j)
		1.1 集合：所有选法
				条件：（1）只从前i个物品中选
					 （2）总体积<=j
    
		1.2 属性：max值
    
	2.状态计算:一步一步的将状态计算出来
		集合的划分,不重复（不一定需要必须满足），不遗漏
		f(i,j)集合划分为若干个更小的子集，每个子集都能求出答案
		（1）选法不包含i：f(i-1,j)
			所有从1-i中选，总体积<=j，不包含i
		  =>所有从1~i-1中选，总体积<=j选法
		（2）选法包含i: f(i-1,j-V[i])+Wi
			所有从1-i中选，总体积<=j，包含i中选择
		  =>将V[i]拿走,求不包含V[i]的答案，在加上V[i]的值w[i]
		  =>所有从1~i-1中选，总体积<=j-V[i]，包含i中选择:f(i-1,j-V[i])+W[i]
		  
		  最终f(i,j)=max(f(i-1,j),f(i-1,j-V[i])+W[i])
    3.优化
    	(1)f(i,j)=max(f(i-1,j),f(i-1,j-V[i])+W[i])每个阶段的i的状态只用到了i-1的状态，
            利用“滚动数组”优化，第二维要么是j要么是j-Vi都<=j;
			f[i][j] = f[i - 1][j];
		  =>f[i&1][j] = f[(i - 1)&1][j];

			f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
          =>f[i&1][j] = max(f[i&1][j], f[(i - 1)&1][j - v[i]] + w[i]);
			
			f[n][j]
          =>f[n&1][j]
            i的状态用i&1替代，当i为奇数的时候,i&1=1；当i为偶数的时候，i&1==0
            这样的话dp的状态就相当于在f[1][]和f[0][]两个数组中交替转化，O(NM)变为O(M)
            
            每个阶段实际上是执行了一次从f[i-1][]到f[i][]的拷贝操作，进一步省去f[i]
                
        (2)如果j从小往大遍历，后面的dp[j]可能已经被前面的更新了，相当于dp[i][j - v[i]]
        (3)所以让j从大到小倒序遍历。当j的时候，f数组的后半部分f[j~m]处于i阶段，就是放入第i个物品的		  情况；前半部分f[0~j-1]处于第i-1阶段，也就是没有i的更新；j减小就是用i-1状态去更新i状态。
        (4)如果是正序遍历j的话，可能会覆盖，产生矛盾
            
    4.注意：
    	(1)初值：f[0,0]=0,其余为负无穷
                
```

**代码：**

```c
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 1010;
int n, m;
int v[N], w[N];
int f[N][N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> v[i] >> w[i];
    // f[0~n][0~m]
    // f[0][0~m]=0，一件物品也没有选，都为0,所以不用枚举
    for (int i = 1; i <= n; i++)
    {
        // j=0表示一共选了体积为0的物体
        for (int j = 0; j <= m; j++)
        {
            //选法不包含i
            f[i][j] = f[i - 1][j];
            //选法包含i,第i件物品体积小于等于背包总容量
            if (j >= v[i])
                f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
        }
    }
    cout << f[n][m] << endl;
    return 0;
}
```

**优化后代码：**

```c
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 1010;
int n, m;
int v[N], w[N];
int f[N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> v[i] >> w[i];
    // f[0~n][0~m]
    // f[0][0~m]=0，一件物品也没有选，都为0,所以不用枚举
    for (int i = 1; i <= n; i++)
    {
        // j=0表示一共选了体积为0的物体	
        for (int j = m; j >= v[i]; j--)
        {
            f[j] = max(f[j], f[j - v[i]] + w[i]);
        }
    }
    cout << f[m] << endl;
    return 0;
}
```



#### **[题目：1015. 摘花生    ]()**

**题目描述**

Hello Kitty想摘点花生送给她喜欢的米老鼠。

她来到一片有网格状道路的矩形花生地(如下图)，从西北角进去，东南角出来。

地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。

Hello Kitty只能向东或向南走，不能向西或向北走。

问Hello Kitty最多能够摘到多少颗花生。

![](https://cdn.acwing.com/media/article/image/2019/09/12/19_a8509f26d5-1.gif)



**输入格式**

第一行是一个整数T，代表一共有多少组数据。

接下来是T组数据。

每组数据的第一行是两个整数，分别代表花生苗的行数R和列数 C。

每组数据的接下来R行数据，从北向南依次描述每行花生苗的情况。每行数据有C个整数，按从西向东的顺序描述了该行每株花生苗上的花生数目M。

**输出格式**

对每组输入数据，输出一行，内容为Hello Kitty能摘到得最多的花生颗数。

**数据范围**

$1≤T≤100$,
 $1≤R,C≤100$,
 $0≤M≤1000$

**输入样例：**

```c
2
2 2
1 1
3 4
2 3
2 3 4
1 6 5
```

**输出样例：**

```c
8
16
```

**题解：**

``` c

```

**代码：**

```c
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;

int n, m;
int w[N][N];
int f[N][N];

int main()
{
    int T;
    cin >> T;
    while (T -- )
    {
        cin >> n >> m;
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= m; j ++ )
                cin >> w[i][j];

        memset(f, 0, sizeof f);
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= m; j ++ )
                f[i][j] = max(f[i - 1][j], f[i][j - 1]) + w[i][j];

        cout << f[n][m] << endl;
    }

    return 0;
}
```



#### **[题目：895. 最长上升子序列]()**

**题目描述**

给定一个长度为N的数列，求数值严格单调递增的子序列的长度最长是多少。

**输入格式**

第一行包含整数N。

第二行包含N个整数，表示完整序列。

**输出格式**

输出一个整数，表示最大长度。

**数据范围**

$1≤N≤1000，$

$−10^9≤数列中的数≤10^9$

**输入样例：**

```c
7
3 1 2 1 8 5 6
```

**输出样例：**

```c
4
```

**题解：**

``` c
DP
    1.状态表示 f[i]
    	1.1 集合:所有以第i个数结尾的上升子序列的集合
    	1.2 属性：集合里面每一个上升子序列的长度的最大值Max
    2.状态计算
        集合划分f[i]:0 1 2 3 ....i-1
        (1)集合里面没有数
        (2)集合里面以第1个数结尾，以第2个数结尾，以第3个数结尾，...
        状态转移方程:a[i]=max(f[i],f[j]+1)  a[j]<a[i]  j=0,1,2,..i-1
        时间复杂度=状态数量X转移的计算量=n*n
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int n;
int a[N];
int f[N];

int main()
{
    cin >> n ;
    for (int i = 1; i <= n; i ++ ) cin >> a[i];

    int res = 0;
    for (int i = 1; i <= n; i ++ )
    {
        f[i] = 1;	//以i结尾的，找不同的时候，找倒数第二个元素
        for (int j = 1; j < i; j ++ )
            if (a[i] > a[j])
                f[i] = max(f[i], f[j] + 1);

        res = max(res, f[i]);
    }

    cout << res << endl;

    return 0;
}
```

**分析：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 1010;

int n;
int a[N], f[N];

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    for (int i = 1; i <= n; i++)
    {
        f[i] = 1; //以i结尾的只有一个数a[i]
        for (int j = 1; j < i; j++)
        {
            if (a[j] < a[i])
                f[i] = max(f[i], f[j] + 1);
        }
    }

    int res = 0;
    for (int i = 1; i <= n; i++)
        res = max(res, f[i]);
    cout << res << endl;
    return 0;
}
```

**保存序列（存下状态转移）**

```c
//保存下来序列
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 1010;

int n;
int a[N], f[N], g[N];

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    for (int i = 1; i <= n; i++)
    {
        f[i] = 1; //以i结尾的只有一个数a[i]
        g[i] = 0; //表示只有一个数
        for (int j = 1; j < i; j++)
        {
            if (a[j] < a[i])
            {
                if (f[i] < f[j] + 1)
                {
                    f[i] = f[j] + 1;
                    //记录每个状态是从哪里转移来的
                    g[i] = j;
                }
            }
        }
    }

    //最优解下标
    int k = 1;
    for (int i = 1; i <= n; i++)
        if (f[k] < f[i])
            k = i;

    cout << f[k] << endl;
    for (int i = 0, le = f[k]; i < le; i++)
    {
        cout << a[k] << " ";
        k = g[k];
    }
    return 0;
}
```



#### **[题目：1212. 地宫取宝 ]()**

**题目描述**

X 国王有一个地宫宝库，是 *n*×*m*个格子的矩阵，每个格子放一件宝贝，每个宝贝贴着价值标签。

地宫的入口在左上角，出口在右下角。

小明被带到地宫的入口，国王要求他只能向右或向下行走。

走过某个格子时，如果那个格子中的宝贝价值比小明手中任意宝贝价值都大，小明就可以拿起它（当然，也可以不拿）。

当小明走到出口时，如果他手中的宝贝恰好是 *k* 件，则这些宝贝就可以送给小明。

请你帮小明算一算，在给定的局面下，他有多少种不同的行动方案能获得这 *k*件宝贝。

**输入格式**

第一行 3 个整数，*n*,*m*,*k*，含义见题目描述。

接下来 *n*行，每行有 *m* 个整数 $C_i$ 用来描述宝库矩阵每个格子的宝贝价值。 

**输出格式**

输出一个整数，表示正好取 *k*个宝贝的行动方案数。

该数字可能很大，输出它对 1000000007取模的结果。

**数据范围**

$1≤n,m≤50$,
$ 1≤k≤12$,
 $0≤C_i≤12$

**输入样例1：**

```c
2 2 2 
1 2
2 1
```

**输出样例1：**

```c
2
```

**输入样例2：**

```c
2 3 2
1 2 3
2 1 5
```

**输出样例2：**

```c
14
```

**题解：**

``` c
DP
1、状态表示f[i,j,k,c]
    (1)集合：所有从起点走到(i,j)，并且已经取走了k件物品，且最后一件物品的价值是C的合法方案的集合
    (2)属性：Count
    
2、状态计算
    (1)所有最后一步是从上往下走的走法
    	1）取
    		前一步需要满足f[i-1,j,k-1,c`]并且c`<c
    		当前步需要满足w[i][j]=c
    	2）不取
    		f[i-1,j,k,c]
    (2)所有最后一步是从左往右走的走法
    	1）取
    		前一步需要满足f[i-1,j,k-1,c`]并且c`<c
    		当前步需要满足w[i][j]=c
    	2）不取
    		f[i,j-1,k,c]
    
3、边界
    (1)f[1,1,1,w[1][1]] = 1,第一个位置取第一个物品
    (2)f[1,1,0,-1] = 1,第一个位置不取第一个物品
```

**代码：**

```c
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;
const int N = 55,MOD=1000000007;

int n,m,k;
int w[N][N];
int f[N][N][13][14]; //数据范围k最大为12,Ci是从0到12，本来使用-1表示没有选择，方便处理整体+1

int main()
{
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>w[i][j];
            w[i][j]++;  //将其全部+1处理
        }
    }
    
    //处理边界
    f[1][1][1][w[1][1]]=1; //表示选择第一个
    f[1][1][0][0] = 1; //表示第一个不选择f[1][1][0][-1]
    
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(i==1 && j==1) continue;  //第一个已经处理了
            for(int u=0;u<=k;u++){ //表示选择的个数
                for(int v=0;v<=13;v++){ //Ci的取值12但是整体+1操作了
                    int &val=f[i][j][u][v];
                    //从上到下和从左到右不选择
                    val = (val+f[i-1][j][u][v]) % MOD;
                    val = (val+f[i][j-1][u][v]) % MOD;
                    //选择
                    if(u>0 && v==w[i][j]){ //个数要够并且最后一个的值要满足条件
                        for(int c=0;c<v;c++){
                            val = (val+f[i-1][j][u-1][c]) % MOD;
                            val = (val+f[i][j-1][u-1][c]) % MOD;
                        }
                    }
                }
            }
        }
    }
    int res=0;
    for(int i=0;i<=13;i++) res = (res+f[n][m][k][i]) % MOD;
    cout<<res<<endl;
    return 0;
}
```



#### **[题目：AcWing 1214. 波动数列]()**

**题目描述**

观察这个数列：1 3 0 2 -1 1 -2 …

这个数列中后一项总是比前一项增加2或者减少3，**且每一项都为整数**。

栋栋对这种数列很好奇，他想知道长度为 n和为 s 而且后一项总是比前一项增加 a 或者减少 b 的整数数列可能有多少种呢？

**输入格式**

共一行，包含四个整数 n,s,a,b，含义如前面所述。	

**输出格式**

共一行，包含一个整数，表示满足条件的方案数。

由于这个数很大，请输出方案数除以 100000007 的余数。

**数据范围**

$1≤n≤1000$,
$−10^9≤s≤10^9$,
$1≤a,b≤10^6$

**输入样例：**

```c
4 10 2 3
```

**输出样例：**

```c
2
```

**样例解释**

两个满足条件的数列分别是2 4 1 3和7 4 1 -2。

**题解：**

``` c
假设第一个数是x,长度为n的序列，后面的数都是在前一个数基础上+a或-b，d{i}∈{+a，-b}
    x  
    x+d1
    x+d1+d2
    x+d1+d2+d3
    .......
    x+d1+d2+d3+...+d{n-1}

把上面数加起来整理得到：
    nx +(n-1)d1 +(n-2)d2+....+d{n-1} = S
    x=S-{(n-1)d1 +(n-2)d2+....+d{n-1}} / n
    也就是分子S-{(n-1)d1 +(n-2)d2+....+d{n-1}} 要是n的倍数，等价于：
    {(n-1)d1 +(n-2)d2+....+d{n-1}} 和 S 模 n 的余数相同
    
DP：
1、状态表示f[i][j]
	(1)集合:
			所有只考虑前i项,且当前的总和除以n的余数是j的方案的集合
    (2)属性:count
2、状态计算
    (1)最后一项是+a的所有方案
       f[i-1][(j-i*a ) % n)]
    (2)最后一项是-b的所有方案
       f[i-1][(j+i*b ) % n)]
 
 注意：初始化，一项都不选，总和为0,f[0][0]=1
```

**代码：**

```c
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010, MOD = 100000007;

int f[N][N];

int get_mod(int a, int b)   // 求a除以b的正余数
{
    return (a % b + b) % b;
}

int main()
{
    int n, s, a, b;
    cin >> n >> s >> a >> b;

    f[0][0] = 1;
    for (int i = 1; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            f[i][j] = (f[i - 1][get_mod(j - a * (n - i), n)] + f[i - 1][get_mod(j + b * (n - i), n)]) % MOD;

    cout << f[n - 1][get_mod(s, n)] << endl;

    return 0;
}
```





## 四、枚举、模拟与排序

### 1、枚举

#### **[题目：1210. 连号区间数]()**

**题目描述**

小明这些天一直在思考这样一个奇怪而有趣的问题：

在 1∼*N* 的某个排列中有多少个连号区间呢？

这里所说的连号区间的定义是：

如果区间 [*L*,*R*]里的所有元素（即此排列的第 *L* 个到第 *R* 个元素）递增排序后能得到一个长度为 *R*−*L*+1的“连续”数列，则称这个区间连号区间。

当 *N*很小的时候，小明可以很快地算出答案，但是当 *N* 变大的时候，问题就不是那么简单了，现在小明需要你的帮助。

**输入格式**

第一行是一个正整数 *N*，表示排列的规模。

第二行是 *N*个不同的数字 $P_i$，表示这 *N* 个数字的某一排列。

**输出格式**

输出一个整数，表示不同连号区间的数目。

**数据范围**

$1≤N≤10000$,
 $1≤P_i≤N$

**输入样例1：**

```c
4
3 2 4 1
```

**输出样例1：**

```c
7
```

**输入样例2：**

```c
5
3 4 2 5 1
```

**输出样例2：**

```c
9
```

#### 样例解释

第一个用例中，有 7个连号区间分别是：$[1,1],[1,2],[1,3],[1,4],[2,2],[3,3],[4,4]$
第二个用例中，有 9 个连号区间分别是：$[1,1],[1,2],[1,3],[1,4],[1,5],[2,2],[3,3],[4,4],[5,5]$

**题解：**

``` c

```

**代码：**

```c
#include <bits/stdc++.h>

using namespace std;
const int N = 10010,INF=1e8;
int n;
int a[N];

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(false);
	cout.tie(false);
	int res = 0;
	cin>>n;
	for(int i=0;i<n;i++) cin>>a[i];
	
	for(int i=0;i<n;i++){
		int maxv=-INF,minv=INF;
		for(int j=i;j<n;j++){
			maxv=max(maxv,a[j]);
			minv=min(minv,a[j]);
			if((maxv-minv)==(j-i)) res++;
		}
	}
	cout<<res<<endl;
	return 0;
} 
```





#### **[题目：1236. 递增三元组 ]()**

**题目描述**

给定三个整数数组 $A=[A_1,A_2,⋯ ,A_N]$    ，$B=[B_1,B_2,⋯ ,B_N]$   ，$C=[C_1,C_2,⋯ ,C_N]$ 。

请你统计有多少个三元组 $(i,j,k)$满足：

1. $1≤i,j,k≤N$
2. $A_i<B_j<C_k$

**输入格式**

第一行包含一个整数 *N*。

第二行包含 *N*个整数 $A_1,A_2,…A_N$。

第三行包含 *N*个整数 $B_1,B_2,…B_N$。

第四行包含 *N*个整数$C_1,C_2,…C_N$。

**输出格式**

一个整数表示答案

**数据范围**

对于 30% 的数据，1≤N≤100。

对于 60% 的数据，1≤N≤1000。

对于 100%的数据，$1≤N≤10^5，0≤A_i,B_i,C_i≤10^5$。

**输入样例：**

```c
3
1 1 1
2 2 2
3 3 3
```

**输出样例：**

```c
27
```

**题解：**

``` c
对于每个Bj
    (1)在A中有多少个小于Bj
    	a.前缀和 [0,Bj-1]
    		cnt[i]表示在A中，i这个值出现了多少次
    		for(int i=0;i<n;i++) cnt[A[i]]++；
                cnt===>S[]
                S[i]=cnt[0]+...+cnt[i]
                S[i]表示在A中0~i出现多少次
                S[Bj-1]表示在0~Bj-1中有多少个数
                
    	b.sort+二分
    	c.双指针
    
    (2)在C中有多少个大于Bj
```

**代码：**

```c
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>

using namespace std;
typedef long long ll;
const int N = 1e5+10;
int n;
int a[N],b[N],c[N];
int as[N];  //as[i]表示在A[]中有多少个数小于b[i] 
int cs[N];  //cs[i]表示在C[]中有多少个数大于b[i] 
int cnt[N],s[N];  //前缀和数组 

int main()
{	
	scanf("%d",&n);
	//数据范围从0开始，集体全部都加1不影响整体的个数 
	for(int i=0;i<n;i++) scanf("%d",&a[i]),a[i]++;
	for(int i=0;i<n;i++) scanf("%d",&b[i]),b[i]++;
	for(int i=0;i<n;i++) scanf("%d",&c[i]),c[i]++;
	
	//求as[]
	for(int i=0;i<n;i++) cnt[a[i]]++;
	for(int i=1;i<N;i++) s[i]=s[i-1]+cnt[i]; //求cnt[]的前缀和 
	for(int i=0;i<n;i++) as[i]=s[b[i]-1]; //比b[i]小的数的个数 
	
	//求cs[]
	memset(cnt,0,sizeof cnt);
	memset(s,0,sizeof s);
	for(int i=0;i<n;i++) cnt[c[i]]++;
	for(int i=1;i<N;i++) s[i]=s[i-1]+cnt[i];
	for(int i=0;i<n;i++) cs[i]=s[N-1]-s[b[i]];	//比b[i]大的数的个数，应该是N-1到b[i] 
	
	//枚举每个b[i]
	ll res=0;
	for(int i=0;i<n;i++) res+=(ll)as[i]*cs[i]; 
	cout<<res<<endl;
	return 0;
}
```





#### **[题目：1245. 特别数的和]()**

**题目描述**

小明对数位中含有 2、0、1、9 的数字很感兴趣（不包括前导 0），在 1 到 40 中这样的数包括 1、2、9、10 至 32、39 和 40，共 28 个，他们的和是 574

。请问，在 1到 *n* 中，所有这样的数的和是多少？

**输入格式**

共一行，包含一个整数 *n*。

**输出格式**

共一行，包含一个整数，表示满足条件的数的和。

**数据范围**

1≤*n*≤10000

**输入样例：**

```c
40
```

**输出样例：**

```c
574
```

**题解：**

``` c

```

**代码：**

```c
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>

using namespace std;
typedef long long ll;
int main()
{
	ll res=0;
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		int x=i;
		bool flag=false;
		while(x){
			int t=x%10;
			x/=10;
			if(t==2 || t==0 || t==1 || t==9){
				flag=true;
				break;
			}
		}
		if(flag) res+=i;
	}
	cout<<res<<endl;
	return 0;
}
```



#### **[题目：1204. 错误票据]()**（输入的处理方法）

**题目描述**

某涉密单位下发了某种票据，并要在年终全部收回。

每张票据有唯一的ID号。

全年所有票据的ID号是连续的，但ID的开始数码是随机选定的。

因为工作人员疏忽，在录入ID号的时候发生了一处错误，造成了某个ID断号，另外一个ID重号。

你的任务是通过编程，找出断号的ID和重号的ID。

假设断号不可能发生在最大和最小号。

**输入格式**

第一行包含整数 *N*，表示后面共有 *N*行数据。

接下来 *N* 行，每行包含空格分开的若干个（不大于100个）正整数（不大于100000），每个整数代表一个ID号。

**输出格式**

要求程序输出1行，含两个整数 *m*,*n*，用空格分隔。

其中，*m*表示断号ID，*n*表示重号ID。

**数据范围**

$1≤N≤100$

**输入样例：**

```c
2
5 6 8 11 9 
10 12 9
```

**输出样例：**

```c
7 9
```

**题解：**

``` c
方法1：
st：表示每个数是否出现过
bool  st[N];
for(int i=0;i<n;i++)
{
	if(st[a[i]]) n=a[i]; //重复的
    st[a[i]]=true;
}

start=0;
while(!st[start]) start++;	//找到最小值也就是起点
for(int i=start;;i++)
    if(!st[i]) m=i;

方法2：
sort(a,a+n);
for(int i=1;i<n;i++){
	if(a[i]==a[i-1]) n=a[i]; //重复号
    else if(a[i]>=a[i-1]+2) m=a[i];  //缺失号
}
```

**代码：**

```c
#include <iostream>
#include <sstream>
#include <cstring>
#include <algorithm>

using namespace std;
const int N = 10010;
int n;
int a[N];

int main()
{
	int cnt;
	cin>>cnt;
	string line;
	
	getline(cin,line); //忽略第一行的回车 
	while(cnt--){
		//一行里面有空格用getline 
		getline(cin,line);
		stringstream ssin(line);
		
		while(ssin>>a[n]) n++; 
	}
	
	sort(a,a+n);
	int res1,res2;
	for(int i=1;i<n;i++){
		if(a[i]==a[i-1]) res2=a[i];	//重复
		else if(a[i]>=a[i-1]+2) res1=a[i]-1; //断号  
	}
	cout<<res1<<" "<<res2<<endl; 
	return 0;
}
```

```c
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 5;
int a[N];
int n, p = 0;
int main()
{
    cin >> n;
    while (n--)
    {
        while (cin >> a[p++])
        {
            if (cin.get() == '\n')
                break;
        }
    }
    sort(a, a + p);
    int res = a[0], ans = a[0];
    for (int i = 1; i < p; i++)
    {
        if (a[i] != a[i - 1] && a[i] != a[i - 1] + 1)
        {
            res = a[i - 1] + 1;
        }
        if (a[i] == a[i - 1])
        {
            ans = a[i];
        }
    }
    cout << res << " " << ans << endl;
    return 0;
}
```



#### **[题目：466. 回文日期]()**

**题目描述**

在日常生活中，通过年、月、日这三个要素可以表示出一个唯一确定的日期。

牛牛习惯用 8位数字表示一个日期，其中，前 4 位代表年份，接下来 2 位代表月份，最后 2位代表日期。

显然：一个日期只有一种表示方法，而两个不同的日期的表示方法不会相同。

牛牛认为，一个日期是回文的，当且仅当表示这个日期的 8 位数字是回文的。

现在，牛牛想知道：在他指定的两个日期之间（包含这两个日期本身），有多少个真实存在的日期是回文的。

一个 8 位数字是回文的，当且仅当对于所有的 *i*(1≤*i*≤8) 从左向右数的第 *i* 个数字和第 9−*i* 个数字（即从右向左数的第 *i*个数字）是相同的。

例如：

- 对于 2016年 11 月 19 日，用 8 位数字 20161119表示，它不是回文的。
- 对于 2010 年 1 月 2 日，用 8 位数字 20100102表示，它是回文的。
- 对于 2010年 10 月 2 日，用 8 位数字 20101002 表示，它不是回文的。

**输入格式**

输入包括两行，每行包括一个 8位数字。    

第一行表示牛牛指定的起始日期 $date_1$，第二行表示牛牛指定的终止日期 $date_2$。保证 $date_1 $和 $date_2$ 都是真实存在的日期，且年份部分一定为 4 位数字，且首位数字不为 0。

保证 $date_1$一定不晚于$date_2$。

**输出格式**

输出共一行，包含一个整数，表示在$date_1$和$date_2$之间，有多少个日期是回文的。

**数据范围**

**输入样例：**

```c
20110101
20111231
```

**输出样例：**

```c
1
```

**题解：**

``` c

```

**代码：**

```c
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

int months[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

bool check(int date)
{
    int year = date / 10000;
    int month = date % 10000 / 100;
    int day = date % 100;

    if (!month || month >= 13 || !day) return false;

    if (month != 2 && day > months[month]) return false;
    if (month == 2)
    {
        bool leap = year % 4 == 0 && year % 100 || year % 400 == 0;
        if (day > 28 + leap) return false;
    }

    return true;
}

int main()
{
    int date1, date2;
    cin >> date1 >> date2;

    int res = 0;
    for (int i = 0; i < 10000; i ++ )
    {
        int x = i, r = i;
        for (int j = 0; j < 4; j ++ ) r = r * 10 + x % 10, x /= 10;

        if (r >= date1 && r <= date2 && check(r)) res ++ ;
    }

    printf("%d\n", res);
    return 0;
}
```



## 五、树状数组和线段树

### 1、树状数组

**（1）特点**：代码短、常数很小、能用树状数组就不用线段树

（2）**应用**：快速求解动态前缀和，O(logn)

* 加某个位置上的数，加上一个数（单点修改）

* 求某一个前缀和（区间查询）
  * [ 1 , x ]区间的总和为区间[ 1 , X - lowbit(X) ] 加[X - lowbit(X) , X ]
  * 区间[X - lowbit(X) , X ]的和为C[x]
  * [ 1 , x ]区间的总和 = C[x]+ C[X - lowbit(X)] + .......

**（3）树状数组解决的问题**：单点修改、区间查询

其他方式都需要转化为这个才能使用：

* 区间修改、单点查询（利用差分思想+树状数组）

* 区间修改、区间查询（利用差分思想+树状数组）

* 把某一个数变成一个数v，原始数据x，利用原始数据x-x+v实现

**（4）思路：**

* 树状数组下标1开始
* 树状数组记为C，原数组记为A，C的奇数位置和原数组的奇数位置相同
  * C[1] = A[1]  、C[3] = A[3]、C[5] = A[5]......
* 原始数据怎么判断在第几层，C[x]看X的二进制表示X=(.....)2，X的二进制表示最后有K个0，在第K层，C[x]为某一段区间的和
  * lowbit(x) = x & -x =2^k
  * C[X] = sum(X - 2^k , X] =(X - lowbit(X) , X]
* 树状数组记为C，原数组记为A，C的偶数位置
  * C[2] = C[1] + A[2] = A[1] + A[2]
  * C[4] =C[2] +  C[3] + A[4] = A[1]+ A[2]+ A[3]+ A[4]
  * C[6] = C[5] + A[6].........



#### **[题目：1264. 动态求连续区间和]()**

**题目描述**

给定 *n* 个数组成的一个数列，规定有两种操作，一是修改某个元素，二是求子数列 [*a*,*b*] 的连续和。

**输入格式**

第一行包含两个整数 *n* 和 *m*，分别表示数的个数和操作次数。第二行包含 *n*个整数，表示完整数列。接下来 *m*行，每行包含三个整数 *k*,*a*,*b* （*k*=0，表示求子数列[*a*,*b*]的和；*k*=1，表示第 *a* 个数加 *b*）。数列从 1开始计数。

**输出格式**

输出若干行数字，表示 *k*=0 时，对应的子数列 [*a*,*b*] 的连续和。

**数据范围**

1≤*n*≤100000,
 1≤*m*≤100000，
 1≤*a*≤*b*≤*n*,
 数据保证在任何时候，数列中所有元素之和均在 int 范围内。

**输入样例：**

```c
10 5
1 2 3 4 5 6 7 8 9 10
1 1 5
0 1 3
0 4 8
1 7 5
0 4 8
```

**输出样例：**

```c
11
30
35
```

**代码：**

**树状数组写法**

```c
#include <cstdio>
#include <string>
#include <algorithm>
#include <iostream>

using namespace std;

const int N=1e5+5;

int n,m;
int a[N],tr[N]; //tr表示树状数组

int lowbit(int x){
    return x&-x;
}

//在x位置加上值v
void add(int x,int v){
    for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=v;
}

//查询x的前缀和
int query(int x){
    int res = 0;
    //这里是i>0不是i>=0
    for(int i=x;i>0;i-=lowbit(i)) res+=tr[i];
    return res;
}

int main()
{
    scanf("%d%d",&n,&m);
    //数组下标从1开始，初始化构建树状数组，在i位置加a[i]的值
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    //初始化。假设一开始全为0
    for(int i=1;i<=n;i++) add(i,a[i]);
    while(m--){
        int k,x,y;
        scanf("%d%d%d",&k,&x,&y);
        if(k==0) printf("%d\n",query(y)-query(x-1));
        else add(x,y);
    }
    return 0;
}
```

**线段树写法**

```c
#include <cstdio>
#include <string>
#include <algorithm>
#include <iostream>

using namespace std;

const int N=1e5+5;

int n,m;
int w[N];   

struct Node{
    int l,r;
    int sum;
}tr[N*4];

//u表示当前的根节点
void pushup(int u){
    tr[u].sum=tr[u<<1].sum+tr[u<<1|1].sum;
}

//u表示根节点
void build(int u,int l,int r){
    //如果是叶子节点，则u节点的左右叶子为l和r,sum值为w[r]=w[l]
    if(l==r) tr[u].l=l,tr[u].r=r,tr[u].sum=w[r];
    else{
        //非叶子节点则先赋值左右边界,节点U代表区间
        tr[u].l=l,tr[u].r=r;
        int mid=tr[u].l+tr[u].r>>1;
        // int mid=l+r>>1;
        //递归左右子树处理
        build(u<<1,l,mid),build(u<<1|1,mid+1,r);
        pushup(u);
    }
}

int query(int u,int l,int r){
    //如果当前的节点在查询区间里面，则直接返回
    if(tr[u].l>=l && tr[u].r<=r) return tr[u].sum;
    //树中区间求mid
    int mid=tr[u].l+tr[u].r>>1;
    int sum=0;
    if(l<=mid) sum=query(u<<1,l,r);
    //注意是r>mid
    if(r>mid) sum+=query(u<<1|1,l,r);
    return sum;
}

//x处加入v
void modify(int u,int x,int v){
    //找到节点加v
    if(tr[u].l==tr[u].r) tr[u].sum+=v;
    else{
        int mid=tr[u].l+tr[u].r>>1;
        if(x<=mid) modify(u<<1,x,v);
        else modify(u<<1|1,x,v);
        pushup(u);
    }
}

int main(){
    scanf("%d%d",&n,&m);
    //数组下标1开始
    for(int i=1;i<=n;i++) scanf("%d",&w[i]);
    build(1,1,n);
    
    int k,a,b;
    while(m--){
        scanf("%d%d%d",&k,&a,&b);
        if(k==0) printf("%d\n",query(1,a,b));
        else modify(1,a,b);
    }
    return 0;
}
```



#### **[题目：1265. 数星星]()**

**题目描述**

天空中有一些星星，这些星星都在不同的位置，每个星星有个坐标。如果一个星星的左下方（包含正左和正下）有 *k* 颗星星，就说这颗星星是 *k* 级的。

![1.png](https://cdn.acwing.com/media/article/image/2019/12/11/19_6f40991a1c-1.png) 

例如，上图中星星 5 是 3 级的（1,2,4 在它左下），星星 2,4 是 1级的。

例图中有 1 个 0 级，2 个 1 级，1 个 2 级，1 个 3级的星星。

给定星星的位置，输出各级星星的数目。

换句话说，给定 *N* 个点，定义每个点的等级是在该点左下方（含正左、正下）的点的数目，试统计每个等级有多少个点。

**输入格式**

第一行一个整数 *N*，表示星星的数目；

接下来 *N*行给出每颗星星的坐标，坐标用两个整数 *x*,*y*表示；

不会有星星重叠。星星按 *y*坐标增序给出，*y* 坐标相同的按 *x* 坐标增序给出。

**输出格式**

*N* 行，每行一个整数，分别是 0 级，1 级，2 级，……，*N*−1 级的星星的数目。

**数据范围**

$1≤N≤15000$,
 $0≤x,y≤32000$

**输入样例：**

```c
5
1 1
5 1
7 1
3 3
5 5
```

**输出样例：**

```c
1
2
1
1
0
```

**题解：**

``` c
转化为树状数组
    我们计算一个点(xi,yi)的优先级，就是计算满足
	x≤xi 且 y≤yi的点的数量
    因为y按照从小到大顺序输入的
	因此对于新加入的元素(xi,yi)，∀y∈[y0,yi−1]，都有yi>y
    于是对于新加入的元素(xi,yi)，他的优先级，就是在他之前加入的所有元素中x<xi的点的个数
	观察到一个边插入边求前缀和的数据结构，想到了树状数组
```

**代码：**

```c
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>

using namespace std;
const int N=32010;

int n;
int a[N],tr[N];

int lowbit(int x){
    return x&-x;
}

//x位置加上v
void add(int x,int v){
    //这里的i<N
    for(int i=x;i<N;i+=lowbit(i)) tr[i]+=v;
}

//查询x的前缀和
int sum(int x){
    int res=0;
    for(int i=x;i;i-=lowbit(i)) res+=tr[i];
    return res;
}

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        int x,y;
        scanf("%d%d",&x,&y);
        x++;    // 树状数组的下标是从1开始的，整体把x右移动
        a[sum(x)]++;    // a存有多少星星，sum求的x的数量，但是还要加上新的
        add(x,1);
    }
    for(int i=0;i<n;i++) printf("%d\n",a[i]);
    return 0;
}
```



### 2、线段树

（1）单点修改  0(logn)

（2）区间查询 0(logn)

* pushup:用子节点信息更新当前节点信息（有时候直接写在其他函数内部）
* build：在一段区间上初始化线段树
* modify：修改
* query：查询
* 线段树的总节点需要4n
* x的父节点x>>1
* x的左儿子 2x = x<<1
* x的右儿子 2x+1 = x<<1|1
* 线段树的数据范围最多大概1e5



#### [题目：1275最大数（提高课模板）  ]()

给定一个正整数数列 $a_1,a_2,…,a_n$，每一个数都在 `0∼p−1`之间。

可以对这列数进行两种操作：

1. 添加操作：向序列后添加一个数，序列长度变成 `n+1`；
2. 询问操作：询问这个序列中最后 `L`个数中最大的数是多少。

程序运行的最开始，整数序列为空。

一共要对整数序列进行 `m`次操作。

写一个程序，读入操作的序列，并输出询问操作的答案。

**输入格式**

第一行有两个正整数 `m,p`，意义如题目描述；

接下来 `m`行，每一行表示一个操作。

如果该行的内容是 `Q L`，则表示这个操作是询问序列中最后 `L` 个数的最大数是多少；

如果是 `A t`，则表示向序列后面加一个数，加入的数是`(t+a) mod p`。其中，`t` 是输入的参数，`a`是在这个添加操作之前最后一个询问操作的答案（如果之前没有询问操作，则 `a=0`）。

第一个操作一定是添加操作。对于询问操作，`L>0` 且不超过当前序列的长度。

**输出格式**

对于每一个询问操作，输出一行。该行只有一个数，即序列中最后 `L`个数的最大数。

**数据范围**

$1≤m≤2×10^5$,
$1≤p≤2×10^9$,
$0≤t<p$

**输入样例：**

```
10 100
A 97
Q 1
Q 1
A 17
Q 2
A 63
Q 1
Q 1
Q 3
A 99
```

**输出样例：**

```
97
97
97
60
60
97
```

**样例解释**

最后的序列是 97,14,60,96。

**c++代码实现：**

![image-20230315164557036](../../../zky/Coding/Coderwhy/pic/image-20230315164557036.png)

![image-20230315164624686](../../../zky/Coding/Coderwhy/pic/image-20230315164624686.png)

![image-20230315164641441](../../../zky/Coding/Coderwhy/pic/image-20230315164641441.png)

```c
#include <cstdio>
#include <algorithm>
#include <string>
#include <iostream>

#define ac cin.tie(0), cin.sync_with_stdio(0);
#define endl "\n"

using namespace std;

const int N = 2e5+10;

int m,p;

struct Node{
    int l,r;
    int v;  //携带的信息，这里是[l,r]区间的最大值
}tr[N*4];

//pushup操作，由子节点的信息，来计算父节点的信息
void pushup(int u){
    tr[u].v=max(tr[u<<1].v,tr[u<<1|1].v);
}

void build(int u,int l,int r){
    // tr[u]={l,r};
    tr[u].l=l,tr[u].r=r;    //节点u代表区间[l,r]
    if(l==r) return;    //是叶子节点
    int mid=l+r>>1;
    build(u<<1,l,mid),build(u<<1|1,mid+1,r);
}

int query(int u,int l,int r){
    if(tr[u].l>=l && tr[u].r<=r) return tr[u].v;    //查询在区间[l,r]的最大值，包含当前的节点u，则直接回溯返回当前点的值
    int mid=tr[u].l+tr[u].r>>1;
    int v=0;
    // if(l<=mid) v=max(v,query(u<<1,l,r));
    if(l<=mid) v=query(u<<1,l,r);
    if(r>mid) v=max(v,query(u<<1|1,l,r));
    // else v=max(v,query(u<<1|1,l,r));
    return v;
}

void modify(int u,int x,int v){
    if(tr[u].l==x && tr[u].r==x) tr[u].v=v;
    else{
        int mid=tr[u].l+tr[u].r>>1;
        if(x<=mid) modify(u<<1,x,v);
        else modify(u<<1|1,x,v);
        pushup(u);
    }
}

int main(){
    int n=0,last=0;   //last记录题目中所说的上次查询的结果a
    scanf("%d%d",&m,&p);
    build(1,1,m);
    
    int x;
    char op[2];
    while(m--){
        scanf("%s%d",op,&x);
        if(*op=='Q'){
            last=query(1,n-x+1,n);
            printf("%d\n",last);
        }else{
            modify(1,n+1,((long long)last+x)%p);
            n++;
        }
    }
    return 0;
}
```



#### **[题目：1270. 数列区间最大值]()**

**题目描述**

输入一串数字，给你 *M* 个询问，每次询问就给你两个数字 *X*,*Y*，要求你说出 *X* 到 *Y* 这段区间内的最大数。

**输入格式**

第一行两个整数 *N*,*M*表示数字的个数和要询问的次数；

接下来一行为 *N*个数；

接下来 *M*行，每行都有两个整数 *X*,*Y*。

**输出格式**

输出共 *M* 行，每行输出一个数。

**数据范围**

$1≤N≤105$,
 $1≤M≤106$,
 $1≤X≤Y≤N$,
 数列中的数字均不超过$2^{31}−1$

**输入样例：**

```c
10 2
3 2 4 5 6 8 1 2 9 7
1 4
3 8
```

**输出样例：**

```c
5
8
```

**题解：**

``` c
线段树模板
```

**代码：**

```c
#include <iostream>
#include <cstdio>
#include <cstring>
#include <climits>
#include <algorithm>

using namespace std;
const int N=1e5+5;
int n,m;
int w[N];

struct Node{
    int l,r;
    int maxv;   //区间l到r的最大值
}tr[N*4];

void build(int u,int l,int r){
    tr[u].l=l,tr[u].r=r;
    //叶子节点或者非叶子节点
    if(l==r){
        tr[u].maxv=w[r];
        return;
    }else{
        int mid=l+r>>1;
        //递归遍历左右子树
        build(u<<1,l,mid),build(u<<1|1,mid+1,r);
        //pushup操作
        tr[u].maxv=max(tr[u<<1].maxv,tr[u<<1|1].maxv);  
    }
}

int query(int u,int l,int r){
    //查询区间在lr内部，及区间里面的叶子节点则直接返回
    if(tr[u].l>=l && tr[u].r<=r) return tr[u].maxv;
    int mid=tr[u].l+tr[u].r>>1;
    int res = INT_MIN;
    //左子树和区间lr有重叠，递归左子树
    if(l<=mid) res = query(u<<1,l,r);
    //右子树和区间lr有重叠，递归右子树
    if(r>mid) res = max(res,query(u<<1|1,l,r));
    return res;
}

int main()
{
    scanf("%d%d",&n,&m);
    //注意数组下标为1开始
    for(int i=1;i<=n;i++) scanf("%d",&w[i]);
    build(1,1,n);
    
    int l,r;
    while(m--){
        scanf("%d%d",&l,&r);
        printf("%d\n",query(1,l,r));
    }
    return 0;
}
```



#### **[题目：1215. 小朋友排队]()**（树状数组与逆序对）

**题目描述**

$n$个小朋友站成一排。

现在要把他们按身高从低到高的顺序排列，但是每次只能交换位置相邻的两个小朋友。

每个小朋友都有一个不高兴的程度。

开始的时候，所有小朋友的不高兴程度都是 0。

如果某个小朋友第一次被要求交换，则他的不高兴程度增加 1，如果第二次要求他交换，则他的不高兴程度增加 2（即不高兴程度为 3），依次类推。当要求某个小朋友第 $k$ 次交换时，他的不高兴程度增加 $k$。

请问，要让所有小朋友按从低到高排队，他们的不高兴程度之和最小是多少。

如果有两个小朋友身高一样，则他们谁站在谁前面是没有关系的。

**输入格式**

输入的第一行包含一个整数 $n$，表示小朋友的个数。

第二行包含 $n$个整数 $H_1$,$H_2$,…,$H_n$，分别表示每个小朋友的身高。

**输出格式**

输出一行，包含一个整数，表示小朋友的不高兴程度和的最小值。

**数据范围**

$1≤n≤100000$,
 $0≤H_i≤1000000$

**输入样例：**

```c
3
3 2 1
```

**输出样例：**

```c
9
```

**样例解释**

首先交换身高为3和2的小朋友，再交换身高为3和1的小朋友，再交换身高为2和1的小朋友，每个小朋友的不高兴程度都是3，总和为9。

**题解：**

``` c
贪心证明：
（1）交换次数至少是K
（2）在冒泡排序中，每次必然是交换（Ai,A{i+1}）Ai>A{i+1},因此必然使得逆序数减1，也就是需要交换K次
    综上总的交换次数为K
  
证明K最小：
假设某个小朋友位置的前面，比他高的有K1个人，后面位置比他矮的有K2个人    
则对于所有的小朋友，都存在K1和K2
    K1+K2 K1+K2 ....... K1+K2=2K
    
对于序列中的每个数，K1、K2
    1+2+3+....+K1+K2
冒泡排序就是最优解    
```

**代码：**

```c
//树状数组维护的是每个身高的人数
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 1000010;

int n;
int h[N], tr[N];
int sum[N];

int lowbit(int x)
{
    return x & -x;
}

void add(int x, int v)
{
    for (int i = x; i < N; i += lowbit(i)) tr[i] += v;
}

int query(int x)
{
    int res = 0;
    for (int i = x; i; i -= lowbit(i)) res += tr[i];
    return res;
}

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d", &h[i]), h[i] ++ ;

    // 求每个数前面有多少个数比它大
    for (int i = 0; i < n; i ++ )
    {
        //先算在h[i]前面且比h[i]大的总数，再把h[i]自己加到树状数组中去
        sum[i] = query(N - 1) - query(h[i]);
        //1表示身高是h[i]的小朋友有一个，树状数组维护的是每个身高的人数。
        add(h[i], 1);
    }

    // 每个数后面有多少个数比它小
    memset(tr, 0, sizeof tr);
    for (int i = n - 1; i >= 0; i -- )
    {
        sum[i] += query(h[i] - 1);
        add(h[i], 1);
    }

    LL res = 0;
    for (int i = 0; i < n; i ++ ) res += (LL)sum[i] * (sum[i] + 1) / 2;

    cout << res << endl;

    return 0;
}
```



#### 扫描线

#### **[题目：1228. 油漆面积]()**

**题目描述**

X星球的一批考古机器人正在一片废墟上考古。

该区域的地面坚硬如石、平整如镜。

管理人员为方便，建立了标准的直角坐标系。

每个机器人都各有特长、身怀绝技。

它们感兴趣的内容也不相同。

经过各种测量，每个机器人都会报告一个或多个矩形区域，作为优先考古的区域。

矩形的表示格式为 $(x1,y1,x2,y2)$，代表矩形的两个对角点坐标。

为了醒目，总部要求对所有机器人选中的矩形区域涂黄色油漆。

小明并不需要当油漆工，只是他需要计算一下，一共要耗费多少油漆。

其实这也不难，只要算出所有矩形覆盖的区域一共有多大面积就可以了。

注意，各个矩形间可能重叠。

**输入格式**

第一行，一个整数 *n*，表示有多少个矩形。

接下来的 *n*行，每行有 4 个整数$x1,y1,x2,y2$，空格分开，表示矩形的两个对角顶点坐标。

**输出格式**

一行一个整数，表示矩形覆盖的总面积。

**数据范围**

$1≤n≤10000$,
 $0≤x1,x2,y2,y2≤10000$,
 数据保证 $x1<x2$ 且 $y1<y2。$

**输入样例1：**

```c
3
1 5 10 10
3 1 20 20
2 7 15 17
```

**输出样例1：**

```c
340
```

**输入样例2：**

```c
3
5 2 10 6
2 7 12 10
8 1 15 15
```

**输出样例2：**

```c
128
```

**题解：**

``` c
1、扫描线
    (1)数据量大：
    	数据结构优化（线段树吧）  nlogn
    (2)数据量小：矩形斜着、三角形、圆形
    	计算几何
    
2、此题非常特殊：
	(1)cnt和len是在不考虑父节点信息的情况下的结果（只对下不对上，就是父亲有懒标记，儿子应该是没有0）
	struct Node{
    	int l,r;  //左右边界
    	int cnt; //当前区间被覆盖次数
    	int len; //至少被覆盖1次的区间长度
	}
	(2)延迟更新：懒标记
	   线段树维护纵坐标y
	(3)把一个矩形的点拿出来做四元组：两个点(x1,y1)和(x2,y2)
    	(x1,y1,y2,+1)表示给整体区间y1和y2增加一次（进入该矩形区域）
    	(x2,y1,y2,-1)表示给整体区间y1和y2减少一次（离开该矩形区域）
	(4)区间修改和区间查询
        1）查询的时候直接查询len
		2）修改的时候注意是不下传的，常规是向下递归的时候需要传递懒标记才对，这个题目向下递归不需要传递懒标记，只需要回溯的时候用子节点算当前节点
    	注意特殊：
        	① 所有的操作是成对的，且是先加后减（cnt统计的时候减法之前一定会先加）====>cnt>=0
        	② 只查询根节点，（根节点只需要考虑自己，当前区间的长度就是答案，不需要考虑下面的，不需要考虑根节点的祖宗节点）
        3) 维护的时候是区间不是点，离散化
        	区间[y1,y2]增加一段，是将y1~{y2-1}都加一段，区间个数比点的数目少1（步长和点类比）
```

**代码：**

```c
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 10010;

int n;
struct Segment
{
    int x, y1, y2;
    int k;	//表示是加还是减
    //排序
    bool operator< (const Segment &t)const
    {
        return x < t.x;
    }
}seg[N * 2];

struct Node
{
    int l, r;
    int cnt, len;
}tr[N * 4];
//一个矩形会提供两个线段，亚特兰蒂斯开8倍

void pushup(int u)
{	
    //如果是>0，则直接求该区间长度
    if (tr[u].cnt > 0) tr[u].len = tr[u].r - tr[u].l + 1;
    //叶结点如果被覆盖就是1，没有被覆盖就是0
    else if (tr[u].l == tr[u].r) tr[u].len = 0;
    else tr[u].len = tr[u << 1].len + tr[u << 1 | 1].len;
}

void build(int u, int l, int r)
{
    tr[u] = {l, r};
    if (l == r) return;
    int mid = l + r >> 1;
    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
}

void modify(int u, int l, int r, int k)
{
    if (tr[u].l >= l && tr[u].r <= r)
    {
        tr[u].cnt += k;
        pushup(u);
    }
    else
    {
        int mid = tr[u].l + tr[u].r >> 1;
        if (l <= mid) modify(u << 1, l, r, k);
        if (r > mid) modify(u << 1 | 1, l, r, k);
        pushup(u);
    }
}

int main()
{
    scanf("%d", &n);
    int m = 0;
    for (int i = 0; i < n; i ++ )
    {
        int x1, y1, x2, y2;
        scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
        //左边+1，右边-1表示结束
        seg[m ++ ] = {x1, y1, y2, 1};
        seg[m ++ ] = {x2, y1, y2, -1};
    }

    sort(seg, seg + m);
	//数据范围0~10000
    build(1, 0, 10000);

    int res = 0;
    for (int i = 0; i < m; i ++ )
    {
        //应该从第一个矩形的第二条边算起
        if (i > 0) res += tr[1].len * (seg[i].x - seg[i - 1].x);
        modify(1, seg[i].y1, seg[i].y2 - 1, seg[i].k);
    }

    printf("%d\n", res);

    return 0;
}
```





#### **[题目：1232. 三体攻击 ]()**

**题目描述**



**输入格式**



**输出格式**



**数据范围**

$1≤n≤15$

**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c
Q:从第几轮攻击开始，某个格子上的数小于0了
满足二分的性质，某一次<0，那么之后的也都<0
  
一维：
原始数组：S
差分数组：B
    B[i] = S[i]-S[i-1]
	S[0]=0;
	S[1]=B[1]+S[0]
    S[2]=B[2]+S[1]
        .....
    S[i]=B[i]+S[i-1]
        
二维：

```

这是一道二分 + 前缀和 + 差分的题

因为每一轮造成的伤害结果都是递减的，即血量随着轮数增加而减少，存在单调性，所以可以利用二分找到第一个血量小于零的分界点

对于攻击每一块区域，就是某一块区域内都减去某一个值，这是三维差分

可以推出公式：

$S_{x,y,z} =b_{x,y,z} +S_{x−1,y,z} +S_{x,y−1,z} −S_{x−1,y−1,z} +S_{x,y,z−1} −S_{x−1,y,z−1} −S_{x,y−1,z−1} +S_{ x−1,y−1,z−1}$

S 是原数组，b 是差分数组

那么可以根据此公式计算出每一块的差分，类似于二维差分，可以对某一个点 − h ( h 是 伤 害 值 ) ，其它某些点 + / − h

$b_{x,y,z} −=h,b_{x+1,y,z} +=h$...

可以发现规律，如果 + 1  是偶数个，那么就是 − h  ，奇数个就是 +h ，总共有8 个($2^3$ )

**代码：**

```c
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 2000010;

typedef long long LL;
int A, B, C, m;
LL s[N], b[N], bp[N];
int op[N / 2][7];

const int d[8][4] = {
    {0,0,0,1},
    {0,0,1,-1},
    {0,1,0,-1},
    {0,1,1,1},
    {1,0,0,-1},
    {1,0,1,1},
    {1,1,0,1},
    {1,1,1,-1}
};

int get(int i,int j,int k) {
    
    return (i * B + j) * C + k;
}

bool check(int mid) {
    memcpy(b,bp,sizeof bp);
    for(int i = 1;i <= mid;i ++) {
        int x1 = op[i][0], x2 = op[i][1], y1 = op[i][2], y2 = op[i][3], z1 = op[i][4], z2 = op[i][5], h = op[i][6];
        b[get(x1,     y1,     z1)]     -= h;
        b[get(x1,     y1,     z2 + 1)] += h;
        b[get(x1,     y2 + 1, z1)]     += h;
        b[get(x1,     y2 + 1, z2 + 1)] -= h;
        b[get(x2 + 1, y1,     z1)]     += h;
        b[get(x2 + 1, y1,     z2 + 1)] -= h;
        b[get(x2 + 1, y2 + 1, z1)]     -= h;
        b[get(x2 + 1, y2 + 1, z2 + 1)] += h;
    }
    
    memset(s,0,sizeof s);
    for(int i = 1;i <= A;i ++)
        for(int j = 1;j <= B;j ++)
            for(int k = 1;k <= C;k ++) {
                s[get(i,j,k)] = b[get(i,j,k)];
                for(int u = 1;u < 8;u ++) {
                    int x = i - d[u][0], y = j - d[u][1], z = k - d[u][2], t = d[u][3];
                    s[get(i,j,k)] -= s[get(x,y,z)] * t;
                }
                
                if(s[get(i,j,k)] < 0) return true;
            }
    
    return false;
                
}

int main()
{
    scanf("%d%d%d%d",&A,&B,&C,&m);
    
    for(int i = 1;i <= A;i ++)
        for(int j = 1;j <= B;j ++)
            for(int k = 1;k <= C;k ++)
                scanf("%lld",&s[get(i,j,k)]);
    
    for(int i = 1;i <= A;i ++)
        for(int j = 1;j <= B;j ++)
            for(int k = 1;k <= C;k ++)
                for(int u = 0;u < 8;u ++) {
                    int x = i - d[u][0], y = j - d[u][1], z = k - d[u][2], t = d[u][3];
                    bp[get(i,j,k)] += s[get(x,y,z)] * t;
                }
    
    for(int i = 1;i <= m;i ++) 
        for(int j = 0;j < 7;j ++)
            scanf("%d",&op[i][j]);
            
    int l = 1, r = m;
    while(l < r) {
        int mid = l + r >> 1;
        if(check(mid)) r = mid;
        else l = mid + 1;
    }
    
    printf("%d\n",r);
    return 0;
}
```



## 六、双指针、BFS与图论

### 1、双指针

#### **[题目：1238. 日志统计]()**

**题目描述**

小明维护着一个程序员论坛。现在他收集了一份”点赞”日志，日志共有 N行。

其中每一行的格式是：

```
ts id  
```

表示在 ts 时刻编号 id 的帖子收到一个”赞”。

现在小明想统计有哪些帖子曾经是”热帖”。

如果一个帖子曾在任意一个长度为 D 的时间段内收到不少于 K 个赞，小明就认为这个帖子曾是”热帖”。

具体来说，如果存在某个时刻 T 满足该帖在 [T,T+D) 这段时间内(注意是左闭右开区间)收到不少于 K 个赞，该帖就曾是”热帖”。

给定日志，请你帮助小明统计出所有曾是”热帖”的帖子编号。

**输入格式**

第一行包含三个整数 N,D,K。

以下 N 行每行一条日志，包含两个整数 ts 和 id。

**输出格式**

按从小到大的顺序输出热帖 id。

每个 id 占一行。

**数据范围**

$1≤K≤N≤10^5$,
$0≤ts,id≤10^5$,
$1≤D≤10000$

**输入样例：**

```c
7 10 2
0 1
0 10
10 10
10 1
9 1
100 3
100 3
```

**输出样例：**

```c
1
3
```

**题解：**

``` c

```

**代码：**

```c
#include <bits/stdc++.h>
using namespace std;
#define x first
#define y second
typedef pair<int,int> PII;
const int N = 1e5+5;
int n,k,d;

PII logs[N];
int a[N];
int cnt[N];
bool st[N];  // 记录每个帖子是否是热帖

int main(){
    cin>>n>>d>>k;
    for(int i=0;i<n;i++) cin>>logs[i].x>>logs[i].y;
    sort(logs,logs+n);
    
    for(int i=0,j=0;i<n;i++){
        //拿出id
        int id=logs[i].y;
        cnt[id]++;  //id对于数量增加
        
        //时间段>=d,则移动指针
        while(logs[i].x-logs[j].x>=d){
            //j对于的id数目减少,j后移
            cnt[logs[j].y]--;
            j++;
        }
        //移动后如果id的热度>=k，则标记
        if(cnt[id]>=k) st[id]=true;
    }
    for (int i = 0; i <= 100000; i ++ )
        if (st[i])
            printf("%d\n", i);
    return 0;
}
```



### 2、BFS

```
1、判重数组  st[i],一般是入队列时候判重
2、queue
	queue<-----初始状态
	while(q.size()){
		t<---队头
		for(扩展t){
			ver<——扩展的新节点
			if(!st[ver]){
				ver-->队尾	
			}
		}
	}
3、两种状态
（1）将每个格子当作一个状态
（2）将整个矩阵当作一个状态
注意：BFS相对于DFS能找到合法路径的最小步数
```

#### **[题目：1101. 献给阿尔吉侬的花束]()**

**题目描述**

阿尔吉侬是一只聪明又慵懒的小白鼠，它最擅长的就是走各种各样的迷宫。

今天它要挑战一个非常大的迷宫，研究员们为了鼓励阿尔吉侬尽快到达终点，就在终点放了一块阿尔吉侬最喜欢的奶酪。

现在研究员们想知道，如果阿尔吉侬足够聪明，它最少需要多少时间就能吃到奶酪。

迷宫用一个 R×C的字符矩阵来表示。

字符 S 表示阿尔吉侬所在的位置，字符 E 表示奶酪所在的位置，字符 # 表示墙壁，字符 . 表示可以通行。

阿尔吉侬在 1 个单位时间内可以从当前的位置走到它上下左右四个方向上的任意一个位置，但不能走出地图边界。

**输入格式**

第一行是一个正整数 T，表示一共有 T 组数据。

每一组数据的第一行包含了两个用空格分开的正整数 R和 C，表示地图是一个 R×C 的矩阵。

接下来的 R 行描述了地图的具体内容，每一行包含了 C 个字符。字符含义如题目描述中所述。保证有且仅有一个 S 和 E。

**输出格式**

对于每一组数据，输出阿尔吉侬吃到奶酪的最少单位时间。

若阿尔吉侬无法吃到奶酪，则输出“oop!”（只输出引号里面的内容，不输出引号）。

每组数据的输出结果占一行。

**数据范围**

$1<T≤10$,
$2≤R,C≤200$

**输入样例：**

```c
3
3 4
.S..
###.
..E.
3 4
.S..
.E..
....
3 4
.S..
####
..E.
```

**输出样例：**

```c
5
1
oop!
```

难度：简单
时/空限制：1s / 64MB
总通过数：12826
总尝试数：23812
来源：《信息学奥赛一本通》
算法标签

**题解：**

``` c

```

**代码：**

```c
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 210;

int n, m;
char g[N][N];
int dist[N][N];

int bfs(PII start, PII end)
{
    queue<PII> q;
    memset(dist, -1, sizeof dist);

    dist[start.x][start.y] = 0;
    q.push(start);

    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        for (int i = 0; i < 4; i ++ )
        {
            int x = t.x + dx[i], y = t.y + dy[i];
            if (x < 0 || x >= n || y < 0 || y >= m) continue;  // 出界
            if (g[x][y] == '#') continue;  // 障碍物
            if (dist[x][y] != -1) continue;  // 之前已经遍历过

            dist[x][y] = dist[t.x][t.y] + 1;

            if (end == make_pair(x, y)) return dist[x][y];

            q.push({x, y});
        }
    }

    return -1;
}

int main()
{
    int T;
    scanf("%d", &T);
    while (T -- )
    {
        scanf("%d%d", &n, &m);
        for (int i = 0; i < n; i ++ ) scanf("%s", g[i]);

        PII start, end;
        for (int i = 0; i < n; i ++ )
            for (int j = 0; j < m; j ++ )
                if (g[i][j] == 'S') start = {i, j};
                else if (g[i][j] == 'E') end = {i, j};

        int distance = bfs(start, end);
        if (distance == -1) puts("oop!");
        else printf("%d\n", distance);
    }

    return 0;
}
```



#### **[题目：1113. 红与黑]()**

**题目描述**

有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。

你站在其中一块黑色的瓷砖上，只能向相邻（上下左右四个方向）的黑色瓷砖移动。

请写一个程序，计算你总共能够到达多少块黑色的瓷砖。

**输入格式**

输入包括多个数据集合。

每个数据集合的第一行是两个整数 W 和 H，分别表示 x 方向和 y 方向瓷砖的数量。

在接下来的 H 行中，每行包括 W 个字符。每个字符表示一块瓷砖的颜色，规则如下

1）‘.’：黑色的瓷砖；
2）‘#’：红色的瓷砖；
3）‘@’：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。

当在一行中读入的是两个零时，表示输入结束。

**输出格式**

对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。

**数据范围**

$1≤W,H≤20$

**输入样例：**

```c
6 9 
....#. 
.....# 
...... 
...... 
...... 
...... 
...... 
#@...# 
.#..#. 
0 0
```

**输出样例：**

```c
45
```

**题解：**

``` c
1、DFS  
2、Flood Fill
```

**代码：**

**DFS**

```c
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 25;

int n, m;
char g[N][N];
bool st[N][N];

int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

int dfs(int x, int y)
{
    int cnt = 1;

    st[x][y] = true;
    for (int i = 0; i < 4; i ++ )
    {
        int a = x + dx[i], b = y + dy[i];
        if (a < 0 || a >= n || b < 0 || b >= m) continue;
        if (g[a][b] != '.') continue;
        if (st[a][b]) continue;

        cnt += dfs(a, b);
    }

    return cnt;
}

int main()
{
    while (cin >> m >> n, n || m)
    {
        for (int i = 0; i < n; i ++ ) cin >> g[i];

        int x, y;
        for (int i = 0; i < n; i ++ )
            for (int j = 0; j < m; j ++ )
                if (g[i][j] == '@')
                {
                    x = i;
                    y = j;
                }

        memset(st, 0, sizeof st);
        cout << dfs(x, y) << endl;
    }

    return 0;
}
```

**BFS**

```c
#include<iostream>
#include<cstring>
#include<queue>
#define x first
#define y second

using namespace std;
typedef pair<int,int> PII;

const int N=30;

char g[N][N];
int n,m;
int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};
bool st[N][N];

int bfs(int x,int y)
{
    int cnt=1;
    queue<PII> q;
    q.push({x,y});
    while(q.size())
    {
        PII t=q.front();
        q.pop();
        int x=t.x,y=t.y;
        for(int i=0;i<4;i++)
        {
            int a=x+dx[i],b=y+dy[i];
            if(a<0 || a>=n || b<0 || b>=m) continue;
            if(st[a][b]) continue;
            if(g[a][b]!='.') continue;
            st[a][b]=true;
            q.push({a,b});
            cnt++;
        }
    }
    return cnt;
}


int main()
{
    while(cin>>m>>n,n||m)
    {
        memset(st,0,sizeof st);
        for(int i=0;i<n;i++) scanf("%s",g[i]);
        int x,y,flag=0;
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<m;j++)
                if(g[i][j]=='@')
                {
                    x=i,y=j;
                    flag=1;
                }
            if(flag) break;
        }
        cout<< bfs(x,y) <<endl;
    }
    return 0;
}
```



### 3、图论

#### **[题目：1224. 交换瓶子 ]()**

**题目描述**

有 *N* 个瓶子，编号 1∼*N*，放在架子上。

比如有 5个瓶子：

```
2 1 3 5 4
```

要求每次拿起 2个瓶子，交换它们的位置。

经过若干次后，使得瓶子的序号为：

```
1 2 3 4 5
```

对于这么简单的情况，显然，至少需要交换 2 次就可以复位。

如果瓶子更多呢？你可以通过编程来解决。

**输入格式**

第一行包含一个整数 *N*，表示瓶子数量。

第二行包含 *N*个整数，表示瓶子目前的排列状况。

**输出格式**

输出一个正整数，表示至少交换多少次，才能完成排序。

**数据范围**

$1≤N≤10000,$

**输入样例1：**

```c
5
3 1 2 5 4
```

**输出样例1：**

```c
3
```

**输入样例2：**

```c
5
5 4 3 2 1
```

**输出样例2：**

```c
2
```

**题解：**

``` c
1、分析
位置： 1   2   3   4   5
瓶子： 3   1   2   5   4
   
将i位置的瓶子a[i]连接a[i]位置a[a[i]]
    a[1]=3--->a[a[1]]=a[3]=2---->a[2]=1---->a[1]=3
    a[4]=5---->a[5]=4

最终的样子（交换为顺序则变成n个单独环）：
    a[1]=a[1],a[2]=a[2]....a[5]=a[5]得到五个单独的环

2、操作：
	（1）交换同一个环内的点，则会裂开为两个单独环
    （2）交换不同环中的点，合并两个环
k个环变成n个独立环，最少需要交换n-k次
```

**代码：**

```c
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;
const int N = 10010;
int a[N];
bool st[N];

int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    
    int cnt=0;
    for(int i=1;i<=n;i++){
        //如果之前没有出现过，则说明是一个新环
        if(!st[i]){
            cnt++;
            //将下一个位置指向a[j]
            for(int j=i;!st[j];j=a[j]){
                st[j]=true;
            }
        }
    }
    cout<<n-cnt<<endl;
    return 0;
}
```



### 4、题目

#### **[题目：1240. 完全二叉树的权值]()**

**题目描述**

给定一棵包含 *N* 个节点的完全二叉树，树上每个节点都有一个权值，按从上到下、从左到右的顺序依次是 $A_1,A_2,⋅⋅⋅A_N$，如下图所示：

![](https://cdn.acwing.com/media/article/image/2019/12/05/19_2f0cae5817-QQ%E6%88%AA%E5%9B%BE20191205124611.png)

现在小明要把相同深度的节点的权值加在一起，他想知道哪个深度的节点权值之和最大？

如果有多个深度的权值和同为最大，请你输出其中最小的深度。

注：根的深度是 1。

**输入格式**

第一行包含一个整数 N。

第二行包含 *N*个整数 $A_1,A_2,⋅⋅⋅A_N$。

**输出格式**

输出一个整数代表答案。

**数据范围**

$1≤N≤10^5$,
 $−10^5≤A_i≤10^5$

**输入样例：**

```c
7
1 6 5 4 3 2 1
```

**输出样例：**

```c
2
```

**题解：**

``` c
d:深度也就是层数
i:每层的起点
```

**代码：**

```c
 #include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>

using namespace std;
typedef long long LL;
const int N =100010;

int n;
int a[N];

int main()
{
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    
    LL maxs = -1e18;
    int depth=0;
    
    //按照层来遍历
    for(int d=1,i=1;i<=n;i*=2,d++){
        //求d层的前缀和
        LL s=0;
        for(int j=i;j<i+(1<<d-1) && j<=n;j++) s+=a[j];
        if(s>maxs){
            maxs=s;
            depth=d;
        }
    }
    cout<<depth<<endl;
    return 0;
}
```



#### **[题目：1096. 地牢大师 ]()**

**题目描述**

你现在被困在一个三维地牢中，需要找到最快脱离的出路！ 

地牢由若干个单位立方体组成，其中部分不含岩石障碍可以直接通过，部分包含岩石障碍无法通过。 

向北，向南，向东，向西，向上或向下移动一个单元距离均需要一分钟。 

你不能沿对角线移动，迷宫边界都是坚硬的岩石，你不能走出边界范围。

请问，你有可能逃脱吗？ 

如果可以，需要多长时间？

**输入格式**

输入包含多组测试数据。

每组数据第一行包含三个整数 *L*,*R*,*C* 分别表示地牢层数，以及每一层地牢的行数和列数。

接下来是 *L* 个 *R* 行 *C* 列的字符矩阵，用来表示每一层地牢的具体状况。

每个字符用来描述一个地牢单元的具体状况。

其中, 充满岩石障碍的单元格用”#”表示，不含障碍的空单元格用”.”表示，你的起始位置用”S”表示，终点用”E”表示。

每一个字符矩阵后面都会包含一个空行。

当输入一行为”0 0 0”时，表示输入终止。

**输出格式**

每组数据输出一个结果，每个结果占一行。

如果能够逃脱地牢，则输出”Escaped in x minute(s).”，其中X为逃脱所需最短时间。

如果不能逃脱地牢，则输出”Trapped!”。

**数据范围**

$1≤L,R,C≤100$

**输入样例：**

```c
3 4 5
S....
.###.
.##..
###.#

#####
#####
##.##
##...

#####
#####
#.###
####E

1 3 3
S##
#E#
###

0 0 0
```

**输出样例：**

```c
Escaped in 11 minute(s).
Trapped!
```

**题解：**

``` c
三维BFS
```

**代码：**

```c
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 110;
int L,R,C;
struct Point
{
    int x,y,z;
}q[N*N*N];
char g[N][N][N];
int dist[N][N][N];

int dx[6]={1,-1,0,0,0,0};
int dy[6]={0,0,1,-1,0,0};
int dz[6]={0,0,0,0,1,-1};

int bfs(Point st,Point ed){
    int hh=0,tt=0;
    q[0]=st;
    memset(dist,-1,sizeof dist);
    dist[st.x][st.y][st.z]=0;
    
    while(hh<=tt){
        Point t = q[hh++]; //取队列头元素并且出队列
        for(int i=0;i<6;i++){
            int x=t.x+dx[i],y=t.y+dy[i],z=t.z+dz[i];
            if(x<0 || x>=L || y<0 || y>=R || z<0 || z>=C) continue;  //越界
            if(g[x][y][z]=='#') continue;   //障碍物
            if(dist[x][y][z]!=-1) continue; //已经访问
            dist[x][y][z]=dist[t.x][t.y][t.z]+1;
            if(x==ed.x && y==ed.y && z==ed.z) return dist[x][y][z];
            q[++tt]={x,y,z};  //入队列
        }
    }
    return -1;
}

int main()
{
    while(scanf("%d%d%d",&L,&R,&C),L || R ||C){
        Point st,ed;
        for(int i=0;i<L;i++){
            for(int j=0;j<R;j++){
                scanf("%s",g[i][j]);
                for(int k=0;k<C;k++){
                    char c = g[i][j][k];
                    if(c=='S') st={i,j,k};
                    else if(c=='E') ed={i,j,k};
                }
            }
        }
        int distance = bfs(st,ed);
        if(distance==-1) puts("Trapped!");
        else printf("Escaped in %d minute(s).\n",distance);
    }
    return 0;
}
```



#### **[题目：1233. 全球变暖]()**

**题目描述**

你有一张某海域 *N*×*N* 像素的照片，”.”表示海洋、”#”表示陆地，如下所示：

```
.......
.##....
.##....
....##.
..####.
...###.
.......
```

其中”上下左右”四个方向上连在一起的一片陆地组成一座岛屿，例如上图就有 2座岛屿。  

由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。

具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。  

例如上图中的海域未来会变成如下样子：

```
.......
.......
.......
.......
....#..
.......
.......
```

请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。 

**输入格式**

第一行包含一个整数N。

以下 *N*行 *N* 列，包含一个由字符”#”和”.”构成的 *N*×*N*

 字符矩阵，代表一张海域照片，”#”表示陆地，”.”表示海洋。

照片保证第 1行、第 1 列、第 *N* 行、第 *N* 列的像素都是海洋。

**输出格式**

一个整数表示答案。

**数据范围**

$1≤N≤1000$

**输入样例1：**

```c
7
.......
.##....
.##....
....##.
..####.
...###.
.......
```

**输出样例1：**

```c
1
```

**输入样例2：**

```c
9
.........
.##.##...
.#####...
.##.##...
.........
.##.#....
.#.###...
.#..#....
.........
```

**输出样例2：**

```c
1
```

**题解：**

``` c

```

**代码：**

```c
/*
1、求有多少个连通块
	(1)遍历：BFS、DFS
	(2)并查集 
2、连通块有多少个会被淹没
	(1)多少个单元是和海相连 total
	(2)单元里面有多少是和边界相连  bound
	total==bound说明岛屿被淹没，答案++ 
*/
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdio>
#define x first
#define y second

using namespace std;
typedef pair<int,int> PII;

const int N = 1010;
int n;
char g[N][N];
bool st[N][N]; 
int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};
PII q[N*N];

void bfs(int x,int y,int &total,int &bound){
	int hh=0,tt=0;
	q[0]={x,y};	  //起点加入队列 
	st[x][y]=true;   //标记为已经访问 
	
	while(hh<=tt){
		PII t=q[hh++];
		
		total++;  //点的总数量增加 
		bool is_bound=false;
		
		for(int i=0;i<4;i++){
			int a=t.x+dx[i],b=t.y+dy[i];
			if(a<0 || a>=n || b<0 || b>=n) continue; //越界了
			if(st[a][b]) continue;	//已经访问
			if(g[a][b]=='.'){
				is_bound=true;
				continue;
			} 
			q[++tt]={a,b};
			st[a][b]=true;
		}
		if(is_bound) bound++;
	} 
}

int main()
{
//	ios::sync_with_stdio(false);
//	cin.tie(0);
//	cout.tie(0);
	scanf("%d",&n);
//	cin>>n;
	
	for(int i=0;i<n;i++) scanf("%s",g[i]);
	
	int res=0;
	for(int i=0;i<n;i++){
		for(int j=0;j<n;j++){
			if(g[i][j]=='#' && !st[i][j]){
				int total=0,bound=0;
				bfs(i,j,total,bound);
				if(total==bound) res++;	
			}
		}
	}
	
	printf("%d\n",res);
	return 0;
} 
```



#### **[题目：[蓝桥杯 2013 省 A] 大臣的旅费]()**

**题目描述**

很久以前，T 王国空前繁荣。为了更好地管理国家，王国修建了大量的快速路，用于连接首都和王国内的各大城市。

为节省经费，T 国的大臣们经过思考，制定了一套优秀的修建方案，使得任何一个大城市都能从首都直接或者通过其他大城市间接到达。同时，如果不重复经过大城市，从首都到达每个大城市的方案都是唯一的。

J 是 T 国重要大臣，他巡查于各大城市之间，体察民情。所以，从一个城市马不停蹄地到另一个城市成了 J 最常做的事情。他有一个钱袋，用于存放往来城市间的路费。

聪明的 J 发现，如果不在某个城市停下来修整，在连续行进过程中，他所花的路费与他已走过的距离有关，在走第 x千米到第 x+1 千米这一千米中（x 是整数），他花费的路费是 x+10这么多。也就是说走 1 千米花费 11，走 2 千米要花费 23。

J 大臣想知道：他从某一个城市出发，中间不休息，到达另一个城市，所有可能花费的路费中**最多**是多少呢？

**输入格式**

输入的第一行包含一个整数 $n(n≤10^5)$，表示包括首都在内的 T 王国的城市数。

城市从 1 开始依次编号，1 号城市为首都。

接下来 n−1行，描述 T 国的高速路（T 国的高速路一定是 n−1 条）。

每行三个整数$ P_i,Q_i,D_i$，表示城市$ P_i$ 和城市 $Q_i$ 之间有一条高速路，长度为$ D_i(D_i≤1000)$米。

**输出格式**

输出一个整数，表示大臣J最多花费的路费是多少。

**数据范围**

$1≤n≤10^5$,
$ 1≤P_i,Q_i≤n$,
 $1≤D_i≤1000$

**输入样例：**

```c
5
1 2 2
1 3 1
2 4 5
2 5 4
```

**输出样例：**

```c
135
```

**题解：**

``` c
数的直径：
    (1)任取一点x作为起点，求出其他点到x的距离dist[x]
    (2)找到距离x最远的距离的点y,再求其他点到y的最大值dist[],该最大值就是树直径
树的存储：
     
```

**代码：**

```c
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>

using namespace std;
const int N = 1e5+5;
int n;
struct Edge{
	//id表示和当前点相连的点，w表示两点之间的权重 
	int id,w;
};

vector<Edge> h[N];	//存储所有的点和边
int dist[N]; 

//u表示当前点 
void dfs(int u, int father, int distance)
{
    dist[u] = distance;

    for (auto node : h[u])
        if (node.id != father)
            dfs(node.id, u, distance + node.w);
}

int main()
{	
	scanf("%d",&n);
	for(int i=0;i<n-1;i++){
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		h[a].push_back({b,c});
		h[b].push_back({a,c});
	}
	//从第一个1开始搜 
	dfs(1,-1,0);
	int u=1;
	for(int i=1;i<=n;i++)
		if(dist[i]>dist[u])
			u=i;
	
	dfs(u,-1,0);
	for(int i=1;i<=n;i++)
		if(dist[i]>dist[u])
			u=i;
	int s=dist[u];
	printf("%lld\n", s * 10 + s * (s + 1ll) / 2);
	return 0;
} 
```




