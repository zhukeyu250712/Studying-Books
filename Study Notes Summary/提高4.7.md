## 一、DP

### 1.数字三角形模型（路径DP）

#### 1.1  摘花生

**[题目：AcWing1015. 摘花生](https://www.acwing.com/activity/content/problem/content/1256/)**

**题目描述**

Hello Kitty想摘点花生送给她喜欢的米老鼠。

她来到一片有网格状道路的矩形花生地(如下图)，从西北角进去，东南角出来。

地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。

Hello Kitty只能向东或向南走，不能向西或向北走。

问Hello Kitty最多能够摘到多少颗花生。

![](https://cdn.acwing.com/media/article/image/2019/09/12/19_a8509f26d5-1.gif)

**输入格式**

第一行是一个整数T，代表一共有多少组数据。

接下来是T组数据。

每组数据的第一行是两个整数，分别代表花生苗的行数R和列数 C。

每组数据的接下来R行数据，从北向南依次描述每行花生苗的情况。每行数据有C个整数，按从西向东的顺序描述了该行每株花生苗上的花生数目M。

**输出格式**

对每组输入数据，输出一行，内容为Hello Kitty能摘到得最多的花生颗数。

**数据范围**

$1≤T≤100$,
$1≤R,C≤100$,
$0≤M≤1000$

**输入样例：**

```c
2
2 2
1 1
3 4
2 3
2 3 4
1 6 5
```

**输出样例：**

```c
8
16
```

**题解：**

``` c
DP  1.状态(一个集合)表示
		二维：f(i,j)
		1.1 集合：所有选法
				条件：（1）所有从(1,1)走到(i,j)的所有路线
					 （2）所有路线的最大值max
    
		1.2 属性：max值
    
	2.状态计算:一步一步的将状态计算出来
		(1)总结：
        	1)集合的划分原则：
        		a.重复(不一定需要必须满足)
        		b.不遗漏(必须满足)
        	2)很重要的划分依据"最后",大部分题目依据最后一步来划分
        
		(2)f(i,j)集合划分为若干个更小的子集，每个子集都能求出答案
            1)最后一步是从上面下来的
        		(1,1)-->(i-1,j)-->(i,j)
        		f[i-1][j]+w[i][j]
            2)最后一步是从左边下来的
        		(1,1)-->(i,j-1)-->(i,j)
        		f[i][j-1]+w[i][j]
		  
		最终f[i][j]=max(f[i-1][j]+w[i][j],f[i][j-1]+w[i][j])
    3.优化
    4.注意       
```

**代码：**

```c
#include <bits/stdc++.h>
using namespace std;
const int N = 110;
int w[N][N];
int f[N][N];

int main()
{
  int T;
  scanf("%d",&T);
  while(T--){
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
      for(int j=1;j<=m;j++){
        scanf("%d",&w[i][j]);
      }
    }
    for(int i=1;i<=n;i++){
      for(int j=1;j<=m;j++){
        f[i][j]=max(f[i-1][j],f[i][j-1])+w[i][j];
      }
    }
    printf("%d\n",f[n][m]);
  }
  return 0;
}
```

#### 1.2 最低通行费

**[题目：AcWing1018. 最低通行费](https://www.acwing.com/problem/content/1020/)**

**题目描述**

一个商人穿过一个 N×N 的正方形的网格，去参加一个非常重要的商务活动。

他要从网格的左上角进，右下角出。

每穿越中间 1个小方格，都要花费 1个单位时间。

商人必须在 (2N−1)个单位时间穿越出去。

而在经过中间的每个小方格时，都需要缴纳一定的费用。

这个商人期望在规定时间内用最少费用穿越出去。

请问至少需要多少费用？

注意：不能对角穿越各个小方格（即，只能向上下左右四个方向移动且不能离开网格）。

**输入格式**

第一行是一个整数，表示正方形的宽度 N。

后面 N 行，每行 N 个不大于 100 的正整数，为网格上每个小方格的费用。

**输出格式**

输出一个整数，表示至少需要的费用。

**数据范围**

1≤N≤100

**输入样例：**

```c
5
1  4  6  8  10
2  5  7  15 17
6  8  9  18 20
10 11 12 19 21
20 23 25 29 33
```

**输出样例：**

```c
109
```

**样例解释:**

样例中，最小值为 109=1+2+5+7+9+12+19+21+33。

**题解：**

``` c
DP  1.状态(一个集合)表示
		二维：f(i,j)
		1.1 集合：所有选法
				条件：（1）所有从(1,1)走到(i,j)的所有路线
    				 （2）2n-1步等价于不能走回头路
					 （3）所有路线的最小值Min
    
		1.2 属性：max值
    
	2.状态计算:一步一步的将状态计算出来
		(1)总结：
        	1)集合的划分原则：
        		a.重复(不一定需要必须满足)
        		b.不遗漏(必须满足)
        	2)很重要的划分依据"最后",大部分题目依据最后一步来划分
        
		(2)f(i,j)集合划分为若干个更小的子集，每个子集都能求出答案
            1)最后一步是从上面下来的
        		(1,1)-->(i-1,j)-->(i,j)
        		f[i-1][j]+w[i][j]
            2)最后一步是从左边下来的
        		(1,1)-->(i,j-1)-->(i,j)
        		f[i][j-1]+w[i][j]
		  
		最终f[i][j]=min(f[i][j],f[i-1][j]+w[i][j],f[i][j-1]+w[i][j])
    3.优化
    4.注意       
```

**代码：求最小值需要考虑边界问题**

```c
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 110,INF = 1e9;

int n;
int w[N][N];
int f[N][N];

int main() {
  scanf("%d",&n);
  for(int i = 1; i <= n; i++) {
    for(int j = 1; j <= n; j++){
      scanf("%d",&w[i][j]);
    }
  }

  for(int i = 1; i <= n; i++) {
    for(int j = 1; j <= n; j++) {
      //特判下第一行和第一列
      if(i==1 && j==1) f[i][j] = w[i][j];  //特判左上角
      else {
        f[i][j] = INF;
        //只有不在第一行的时候，才可以从上面过来
        if(i>1) f[i][j] = min(f[i][j],f[i-1][j] + w[i][j]); 
        //只有不在第一列的时候，才可以从左边过来
        if(j>1) f[i][j] = min(f[i][j],f[i][j-1] + w[i][j]);
      }
    }
  }
  printf("%d\n",f[n][n]);
  return 0;
}
```



#### 1.3  方格取数

**[题目：AcWing.1027方格取数](https://www.acwing.com/problem/content/1029/)**

**题目描述**

设有 N×N 的方格图，我们在其中的某些方格中填入正整数，而其它的方格中则放入数字0。如下图所示：

![](https://cdn.acwing.com/media/article/image/2019/09/12/19_764ece6ed5-2.gif)

某人从图中的左上角 A 出发，可以向下行走，也可以向右行走，直到到达右下角的 B 点。

在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。

此人从 A 点到 B 点共走了两次，试找出两条这样的路径，使得取得的数字和为最大。

**输入格式**

第一行为一个整数N，表示 N×N 的方格图。

接下来的每行有三个整数，第一个为行号数，第二个为列号数，第三个为在该行、该列上所放的数。

行和列编号从 1 开始。

一行“0 0 0”表示结束。

**输出格式**

输出一个整数，表示两条路径上取得的最大的和。

**数据范围**

$N≤10$

**输入样例：**

```c
8
2 3 13
2 6 6
3 5 7
4 4 14
5 2 21
5 6 4
6 3 15
7 2 14
0 0 0
```

**输出样例：**

```c
67
```

**题解：**

``` c
如何处理同一个格子不能被重复选择？
    只有在ii+j1 == i2+j2时候，两条路径才可能重合
    
DP  1.状态(一个集合)表示
		四维：f(i1,j1,i2,j2)
    		 只有在ii+j1 == i2+j2时候，两条路径才可能重合
    		 f(k,i1,i2)表示所有从(1,1),(1,1)分别走到(i1,k-i1),(i2,k-i2)的路径的最大值
    		 k = i1+j1 = i2+j2
    
		1.1 集合：所有选法
				条件：（1）从(1,1),(1,1)分别走到(i1,k-i1),(i2,k-i2)的路径的最大值
					 （2）路线的最大值max
    
		1.2 属性：max值
    
	2.状态计算:一步一步的将状态计算出来
		(1)总结：
        	1)集合的划分原则：
        		a.重复(不一定需要必须满足)
        		b.不遗漏(必须满足)
        	2)很重要的划分依据"最后",大部分题目依据最后一步来划分
        
		(2)f(k,i1,i2)集合划分为若干个更小的子集，每个子集都能求出答案
            1)第一条路线向下走，第二条路线向下走
        		第一条路线:(1,1)->(i1-1,j1)->(i1,j1)
        		第二条路线:(1,1)->(i2-1,j2)->(i2,j2)
                ①前部部分的状态;f(k-1,i1-1,i2-1)
                ②后面部分判断(i1,j1)和(i2,j2)是否重合
                    重合则加 w(i1,j1)
                    不重合加 w(i1,j1)+w(i2,j2)
 
            2)第一条路线向下走，第二条路线向右走
        
        	3)第一条路线向右走，第二条路线向下走
        
        	4)第一条路线向右走，第二条路线向右走
        		
		最终4种情况取最大值
    3.优化
    4.注意       
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 15;

int n;
int w[N][N];
int f[N*2][N][N];

int main() {
  scanf("%d",&n);

  int a,b,c;
  while(cin>>a>>b>>c, a || b || c) w[a][b] = c;

  for(int k  =2; k <=n+n; k++) {
    for(int i1 = 1; i1 <= n; i1++){
      for(int i2 = 1; i2 <= n; i2++) {
        int j1 = k - i1, j2 = k - i2;
        if(j1 >=1 && j1 <=n && j2>=1 && j2<=n) {
          int t = w[i1][j1];
          if(i1!=i2 && j1!=j2) t+=w[i2][j2];
          // f[k][i1][i2] = max(f[k][i1][i2],f[k-1][i1-1][i2-1]+t);
          int &x = f[k][i1][i2];
          x = max(x,f[k-1][i1-1][i2-1] + t);
          x = max(x,f[k-1][i1-1][i2] + t);
          x = max(x,f[k-1][i1][i2-1] + t);
          x = max(x,f[k-1][i1][i2] + t);
        }
      }
    }
  }
  printf("%d",f[n*2][n][n]);
  return 0;
}
```



#### 1.4 传纸条(todo)

[Acwing275. 传纸条](https://www.acwing.com/problem/content/277/)

**题目描述**

小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。

一次素质拓展活动中，班上同学安排坐成一个 m 行 n 列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。

幸运的是，他们可以通过传纸条来进行交流。

纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标 (1,1)，小轩坐在矩阵的右下角，坐标 (m,n)。

从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。 

在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。

班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙，反之亦然。 

还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用 00 表示），可以用一个 0∼100 的自然数来表示，数越大表示越好心。

小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度之和最大。

现在，请你帮助小渊和小轩找到这样的两条路径。

**输入格式**

第一行有 2 个用空格隔开的整数 m 和 n，表示学生矩阵有 m 行 n 列。

接下来的 m 行是一个 m×n 的矩阵，矩阵中第 i 行 j 列的整数表示坐在第 i 行 j 列的学生的好心程度，每行的 n 个整数之间用空格隔开。

**输出格式**

输出一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。

**数据范围**

$1≤n,m≤50$

**输入样例：**

```c
3 3
0 3 9
2 8 5
5 7 0
```

**输出样例：**

```c
34
```

**题解：**

``` c

```

**代码：**

```c

```



### 2、最长上升子序列模型(LIS)（序列DP）

**[题目：AcWing 1017. 怪盗基德的滑翔翼  ](https://www.acwing.com/activity/content/problem/content/1259/)**

#### 2.1 怪盗基德的滑翔翼

**题目描述**

怪盗基德是一个充满传奇色彩的怪盗，专门以珠宝为目标的超级盗窃犯。

而他最为突出的地方，就是他每次都能逃脱中村警部的重重围堵，而这也很大程度上是多亏了他随身携带的便于操作的滑翔翼。

有一天，怪盗基德像往常一样偷走了一颗珍贵的钻石，不料却被柯南小朋友识破了伪装，而他的滑翔翼的动力装置也被柯南踢出的足球破坏了。

不得已，怪盗基德只能操作受损的滑翔翼逃脱。

假设城市中一共有N幢建筑排成一条线，每幢建筑的高度各不相同。

初始时，怪盗基德可以在任何一幢建筑的顶端。

他可以选择一个方向逃跑，但是不能中途改变方向（因为中森警部会在后面追击）。

因为滑翔翼动力装置受损，他只能往下滑行（即：只能从较高的建筑滑翔到较低的建筑）。

他希望尽可能多地经过不同建筑的顶部，这样可以减缓下降时的冲击力，减少受伤的可能性。

请问，他最多可以经过多少幢不同建筑的顶部(包含初始时的建筑)？

**输入格式**

输入数据第一行是一个整数K，代表有K组测试数据。

每组测试数据包含两行：第一行是一个整数N，代表有N幢建筑。第二行包含N个不同的整数，每一个对应一幢建筑的高度h，按照建筑的排列顺序给出。

**输出格式**

对于每一组测试数据，输出一行，包含一个整数，代表怪盗基德最多可以经过的建筑数量。

**数据范围**

$1≤K≤100,$
$1≤N≤100$,
$0<h<10000$

**输入样例：**

```c
3
8
300 207 155 299 298 170 158 65
8
65 158 170 298 299 155 207 300
10
2 1 3 4 5 6 7 8 9 10
```

**输出样例：**

```c
6
6
9
```

**题解：**

``` c
当确定方向和起点之后，最长的距离是多少？
    起点:a[i]
    最长距离：以a[i]记为的最长上升子序列
    步骤：选择向左的时候，从左到a[i]求LIS；选择向右的时候，从结尾到a[i]求LIS
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;

int n;
int a[N],f[N];

int main() {
  int T;
  scanf("%d",&T);
  while(T--) {
    scanf("%d",&n);
    for(int i = 1; i <= n; i++) scanf("%d",&a[i]);

    //先正向求解LIS问题
    int res = 0;
    for(int i = 1; i <= n; i++) {
      f[i] = 1;
      for(int j = 1; j< i; j++) {
        if(a[i] > a[j]){
          f[i] = max(f[i],f[j]+1);
        }
      }
      res = max(res,f[i]);
    }

    // 反向求解LIS问题
    for(int i = n; i ; i--) {
      f[i] = 1;
      for(int j = n; j > i; j--) {
        if(a[i] > a[j]) {
          f[i] = max(f[i],f[j] + 1);
        }
      }
      res = max(res, f[i]);
    }

    printf("%d\n",res);
  }
  return 0;
}
```



**[题目：AcWing 1014. 登山  ](https://www.acwing.com/problem/content/1016/)**

#### 2.2 登山

**题目描述**

五一到了，ACM队组织大家去登山观光，队员们发现山上一共有N个景点，并且决定按照顺序来浏览这些景点，即每次所浏览景点的编号都要大于前一个浏览景点的编号。

同时队员们还有另一个登山习惯，就是不连续浏览海拔相同的两个景点，并且一旦开始下山，就不再向上走了。

队员们希望在满足上面条件的同时，尽可能多的浏览景点，你能帮他们找出最多可能浏览的景点数么？

**输入格式**

第一行包含整数N，表示景点数量。

第二行包含N个整数，表示每个景点的海拔。

**输出格式**

输出一个整数，表示最多能浏览的景点数。

**数据范围**

$2≤N≤1000$

**输入样例：**

```c
8
186 186 150 200 160 130 197 220
```

**输出样例：**

```c
4
```

**题解：**

``` c
条件1：按照编号递增的顺序来浏览，也就是必须是子序列
条件2：相邻两个景点不能相同
条件3：一旦开始下降，就不能上升了
形状：先严格单调上升，后单调下降的路线(存在一个峰值a[k])
目标：求最多能浏览多少景点
目标：所有形状是上面这种子序列长度的最大值
    
    
集合划分：以 a[1],a[2],a[3],a[4]..a[k]..a[n-1],a[n] 这些点为峰值
    左边以a[k]为结尾的最长上升子序列，记为f[i]，右边以a[k]为开始到结尾的最长下降子序列,记为g[i]
    最后的答案f[k]+g[k]-1（中间的a[k]算了两次）
    
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 1010;
int n;
int a[N],f[N],g[N];

int main() {
  scanf("%d",&n);
  for(int i = 1; i <= n; i++) scanf("%d",&a[i]);

  for(int i = 1; i <= n; i++) {
    f[i] = 1;
    for(int j = 1; j < i; j++){
      if(a[j] < a[i]) {
        f[i] = max(f[i],f[j]+1);
      }
    }
  } 

  for(int i = n; i ; i--) {
    g[i] = 1;
    for(int j = n; j > i; j--) {
      if(a[j] < a[i]) {
        g[i] = max(g[i],g[j]+1);
      }
    }
  }

  int res = 0;
  for(int i = 1; i <= n; i++) res = max(res, f[i]+g[i]-1);
  printf("%d",res);
  return 0;
}
```



**[题目：AcWing 482. 合唱队形  ](https://www.acwing.com/problem/content/484/)**

#### 2.3 合唱队形

**题目描述**

$N$ 位同学站成一排，音乐老师要请其中的$(N−K)$位同学出列，使得剩下的 $K$位同学排成合唱队形。     

合唱队形是指这样的一种队形：设 $K$ 位同学从左到右依次编号为 $1，2…，K$，他们的身高分别为$T_1，T_2，…，T_K$，  则他们的身高满足 $T_1<…< T_i >T_{i+1}>…> T_K (1≤i≤K)$。     

你的任务是，已知所有 $N$ 位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。

**输入格式**

输入的第一行是一个整数 $N$，表示同学的总数。

第二行有 $N$ 个整数，用空格分隔，第 i 个整数 $T_i$是第 $i$ 位同学的身高(厘米)。

**输出格式**

输出包括一行，这一行只包含一个整数，就是最少需要几位同学出列。

**数据范围**

$2≤N≤100$,
$130≤Ti≤230$

**输入样例：**

```c
8
186 186 150 200 160 130 197 220
```

**输出样例：**

```c
4
```

**题解：**

``` c
同登山
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 110;
int n;
int a[N],f[N],g[N];

int main() {
  scanf("%d",&n);
  for(int i = 1; i <= n; i++) scanf("%d",&a[i]);

  for(int i = 1; i <= n; i++) {
    f[i] = 1;
    for(int j = 1; j < i; j++){
      if(a[j] < a[i]) {
        f[i] = max(f[i],f[j]+1);
      }
    }
  } 

  for(int i = n; i ; i--) {
    g[i] = 1;
    for(int j = n; j > i; j--) {
      if(a[j] < a[i]) {
        g[i] = max(g[i],g[j]+1);
      }
    }
  }

  int res = 0;
  for(int i = 1; i <= n; i++) res = max(res, f[i]+g[i]-1);
  printf("%d",n-res);
  return 0;
}
```



**[题目：AcWing 1012. 友好城市  ](https://www.acwing.com/problem/content/1014/)**

#### 2.4 友好城市（问题转化？）

**题目描述**

Palmia国有一条横贯东西的大河，河有笔直的南北两岸，岸上各有位置各不相同的N个城市。

北岸的每个城市有且仅有一个友好城市在南岸，而且不同城市的友好城市不相同。

每对友好城市都向政府申请在河上开辟一条直线航道连接两个城市，但是由于河上雾太大，政府决定避免任意两条航道交叉，以避免事故。

编程帮助政府做出一些批准和拒绝申请的决定，使得在保证任意两条航线不相交的情况下，被批准的申请尽量多。

**输入格式**

第1行，一个整数N，表示城市数。

第2行到第n+1行，每行两个整数，中间用1个空格隔开，分别表示南岸和北岸的一对友好城市的坐标。

**输出格式**

仅一行，输出一个整数，表示政府所能批准的最多申请数。

**数据范围**

$1≤N≤5000$,
$0≤x_i≤10000$

**输入样例：**

```c
7
22 4
2 6
10 3
15 12
9 8
17 17
4 2
```

**输出样例：**

```c
4
```

**题解：**

``` c
条件1：每个城市上只能建立一座桥
条件2：所有的桥与桥之间不能相交
目标：最多可以建多少桥
    
集合1：所有合法的建桥方式
集合2：上升子序列
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;
typedef pair<int,int> PII;
const int N = 5010;

int n;
PII q[N];
int f[N];

int main() {
  scanf("%d",&n);
  for(int i = 0; i < n; i++) scanf("%d%d",&q[i].first,&q[i].second);
  sort(q,q+n);

  int res = 0;
  for(int i = 0; i < n; i++) {
    f[i] = 1;
    for(int j = 0; j < i; j++) {
      if(q[i].second > q[j].second) {
        f[i] = max(f[i], f[j]+1);
      }
    }
    res = max(res,f[i]);
  }
  printf("%d\n",res);
  return 0;
}
```



**[题目：AcWing 1016. 最大上升子序列和   ](https://www.acwing.com/problem/content/1018/)**

#### 2.5 最大上升子序列和 

**题目描述**

一个数的序列 $b_i$，当 $b_1<b_2<…<b_S$ 的时候，我们称这个序列是上升的。

对于给定的一个序列$(a_1,a_2,…,a_N)$，我们可以得到一些上升的子序列$(a_{i1},a_{i2},…,a_{iK})$，这里$1≤i_1<i_2<…<i_K≤N$。

比如，对于序列$(1,7,3,5,9,4,8)$，有它的一些上升子序列，如$(1,7),(3,4,8)$等等。

这些子序列中和最大为$18$，为子序列$(1,3,5,9)$的和。

你的任务，就是对于给定的序列，求出最大上升子序列和。

注意，最长的上升子序列的和不一定是最大的，比如序列$(100,1,2,3)$的最大上升子序列和为$100$，而最长上升子序列为$(1,2,3)$。

**输入格式**

输入的第一行是序列的长度$N$。

第二行给出序列中的$N$个整数，这些整数的取值范围都在$0$到$10000$(可能重复)。

**输出格式**

输出一个整数，表示最大上升子序列和。

**数据范围**

$1≤N≤1000$

**输入样例：**

```c
7
1 7 3 5 9 4 8
```

**输出样例：**

```c
18
```

**题解：**

``` c
DP
    (1)状态表示f[i]
    1)集合表示：所有以a[i]结尾的上升子序列
    2)属性:和的最大值
    
    (2)状态计算
        集合划分：
        最后一个以 ：空,a[1],a[2].....a[i-1] 结尾
        倒数第2个数是a[k],最后一个是a[i]，则求最大值 max(所有以k结尾的最长上升子序列，也就是f[k])+a[i]
        只要a[k] < a[i]就满足
        
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int n;
int a[N],f[N];

int main() {
  scanf("%d",&n);
  for(int i = 1; i <= n; i++) scanf("%d",&a[i]);

  int res = 0;
  for(int i = 1; i <= n; i++) {
    f[i] = a[i];
    for(int j = 1; j < i; j++) {
      if(a[j] < a[i]) {
        f[i] = max(f[i],f[j]+a[i]);
      }
    }
    res = max(res,f[i]);
  }
  printf("%d",res);
  return 0;
}
```



**[题目：AcWing 1010. 拦截导弹  ](https://www.acwing.com/problem/content/1012/)**

#### 2.6 拦截导弹（推荐）

**题目描述**

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。

但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。

某天，雷达捕捉到敌国的导弹来袭。

由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

输入导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数，导弹数不超过1000），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。

**输入格式**

共一行，输入导弹依次飞来的高度。

**输出格式**

第一行包含一个整数，表示最多能拦截的导弹数。

第二行包含一个整数，表示要拦截所有导弹最少要配备的系统数。

**数据范围**

雷达给出的高度数据是不大于 30000 的正整数，导弹数不超过 1000 。

**输入样例：**

```c
389 207 155 300 299 170 158 65
```

**输出样例：**

```c
6
2
```

**题解：**

``` c
389 207 155 300 299 170 158 65
第一问：389 300 299 170 158 65
第二问: 
	   207有两种选择
           选择1：接在现有的某个子序列之后
           选择2：创建一个新的系统
       贪心流程：
           从前往后扫描每个数，对于每个数：
           情况1：如果现在的子序列的结尾都小于当前数，则创建新子序列
           情况2：将当前数放到结尾大于等于它的最小的子序列后面 
           
        如何证明两个数相等？ A>=B A<=B
           A表示贪心算法得到的序列个数，B表示最优解
           B<=A
           A<=B，调整法
           		假设最优解对应的方案和当前方案不同
           		找到第一个不同的数，将贪心法和最优解不同数后面交换下，可以在有限步内将最优解调整为贪心法的序列，且交换后序列的长度不变
           		贪心法：
           		最优解：
```

**代码：**

```java
import java.util.*;
public class Main{
    static int N = 1010;
    static int n;
    static int[] f = new int[N];//存的是以第i个数结尾的最长下降子序列
    static int[] g = new int[N];//存的是每个下降子序列的最后一个数
    static int[] a = new int[N];//输入
    public static void main(String[] args){
        Scanner scan = new Scanner(System.in);
        while(scan.hasNext()){
            a[n ++ ] = scan.nextInt();
        }
        int res = 0;
        for(int i = 0 ; i < n ; i ++ ){ 
            f[i] = 1;
            for(int j = 0 ; j < i ; j ++ ){
                //后面的导弹不能高于前面的，但是可以等于
                if(a[i] <= a[j]) {
                    f[i] = Math.max(f[i],f[j] + 1);
                }
            }
            res = Math.max(res,f[i]);
        }

        System.out.println(res);

        int cnt = 0;//表示可以覆盖全部输入的下降子序列的数量
        for(int i = 0 ; i < n ; i ++ ){
            //表示从前往后枚举所有子序列,因为子序列的结尾的数是单调上升的，
            //所以只要枚举到比自己大的第一个数就可以直接替换掉这个比自己大的数
            int k = 0;
            while(k < cnt && g[k] < a[i]) k ++ ;
            //如果第一个大于当前数的就是第k个，所以直接将第k个序列的结尾替换成当前数就行
            g[k] = a[i];
            //如果枚举超过了我们的全部序列，就说明没有一个数是比我们大的，就需要新开组别
            if(k >= cnt) cnt ++ ;
        }
        System.out.println(cnt);
    }
}
```



**[题目：AcWing 187. 导弹防御系统 ](https://www.acwing.com/problem/content/189/)**

#### 2.7 导弹防御系统（回）

**题目描述**

为了对抗附近恶意国家的威胁，R 国更新了他们的导弹防御系统。

一套防御系统的导弹拦截高度要么一直 **严格单调** 上升要么一直 **严格单调** 下降。

例如，一套系统先后拦截了高度为 3 和高度为 4 的两发导弹，那么接下来该系统就只能拦截高度大于 4 的导弹。

给定即将袭来的一系列导弹的高度，请你求出至少需要多少套防御系统，就可以将它们全部击落。

**输入格式**

输入包含多组测试用例。

对于每个测试用例，第一行包含整数 n ，表示来袭导弹数量。

第二行包含 n 个**不同的**整数，表示每个导弹的高度。

当输入测试用例 n=0 时，表示输入终止，且该用例无需处理。

**输出格式**

对于每个测试用例，输出一个占据一行的整数，表示所需的防御系统数量。

**数据范围**

$1≤n≤50$

**输入样例：**

```c
5
3 5 2 4 1
0 
```

**输出样例：**

```c
2
```

**样例解释**

对于给出样例，最少需要两套防御系统。

一套击落高度为 3,4 的导弹，另一套击落高度为 5,2,1 的导弹。

**题解：**

``` c
389 207 155 300 299 170 158 65
第一问：389 300 299 170 158 65
第二问: 
	   207有两种选择
           选择1：接在现有的某个子序列之后
           选择2：创建一个新的系统
       贪心流程：
           （1）上升子序列
           从前往后扫描每个数，对于每个数：
           情况1：如果现在的子序列的结尾都小于当前数，则创建新子序列
           情况2：将当前数放到结尾大于等于它的最小的子序列后面 
           
           （2）下降子序列
           需要考虑上升子序列和下降子序列两种情况，所以使用dfs+dp的方法来处理
           
        dfs求最小步数
           （1）方式1：记一个最小步数并不断更新
           （2）方式2：迭代加深
           
        如何证明两个数相等？ A>=B A<=B
           A表示贪心算法得到的序列个数，B表示最优解
           B<=A
           A<=B，调整法
           		假设最优解对应的方案和当前方案不同
           		找到第一个不同的数，将贪心法和最优解不同数后面交换下，可以在有限步内将最优解调整为贪心法的序列，且交换后序列的长度不变
           		贪心法：
           		最优解：
```

**代码：**

```c
/*
 * @Descripttion: 
 * @version: 
 * @Author: ZKYAAA
 * @Date: 2023-07-21 21:36:02
 * @LastEditors: 请叫我ZK谕啊啊啊
 * @LastEditTime: 2023-07-21 21:57:37
 */
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 55;

int n;
int q[N];
int up[N],down[N];  //  up表示上升子序列的结尾，down表示下降子序列结尾
int ans;

/*
u:表示当前枚举到的位置
su:表示上升子序列的个数
sd:表示下降子序列的个数
*/
void dfs(int u, int su,int sd) {
    //剪纸1:当目前的方案是已经大于ans则直接返回
    if(su+sd >= ans) return ;
    //当枚举的位置已经到最后了，则更新答案
    if(u==n){
        ans = su+sd;
        return;
    }

    //情况1：将当前数放到上升子序列中
    int k = 0;
    while(k < su && up[k]>=q[u]) k++;
    int t = up[k];  //备份现场
    up[k] = q[u];
    if(k < su) dfs(u+1,su,sd);  //不需要开辟
    else dfs(u+1,su+1,sd); //开辟上升子序列
    up[k] = t;  //恢复现场
    
    //情况2：将当前数放到下降子序列中
    k = 0;
    while(k < sd && down[k]<=q[u]) k++;
    t = down[k];
    down[k] = q[u];
    if(k < sd) dfs(u+1,su,sd);
    else dfs(u+1,su,sd+1);
    down[k] = t;
}

int main() {
    while(cin>>n, n) {
        for(int i = 0; i < n; i++) cin>>q[i];

        ans = n;    //最坏的情况下是每个数字都需要一个导弹防御系统
        dfs(0,0,0);
        cout<<ans<<endl;
    }
    return 0;
}
```



**[题目：AcWing 272. 最长公共上升子序列  ](https://www.acwing.com/problem/content/274/)**

#### 2.8  最长公共上升子序列（回）

**题目描述**

熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目。

小沐沐先让奶牛研究了最长上升子序列，再让他们研究了最长公共子序列，现在又让他们研究最长公共上升子序列了。

小沐沐说，对于两个数列 A  和 B ，如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一段数是两个数列的公共上升子序列，而所有的公共上升子序列中最长的就是最长公共上升子序列了。

奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。

不过，只要告诉奶牛它的长度就可以了。

数列 A 和 B 的长度均不超过 3000 。

**输入格式**

第一行包含一个整数 N，表示数列 A，B 的长度。

第二行包含 N 个整数，表示数列 A。

第三行包含 N 个整数，表示数列 B。

**输出格式**

输出一个整数，表示最长公共上升子序列的长度。

**数据范围**

$1≤N≤3000$,序列中的数字均不超过 $2^{31}−1$。

**输入样例：**

```c
4
2 2 1 3
2 1 2 3
```

**输出样例：**

```c
2
```

**题解：**

``` c
DP
    （1）状态表示：f[i][j]
      1）集合：所有由第一个序列的前i个字母，和第二个序列的前j个字母构成的，且以b[j]结尾的公共上升子序
      2) 属性：最大值
    （2）状态计算
      1）所有包含a[i]的公共上升子序列
    	 结合是以b[j]结尾的，则a[i]==b[j],也就是序列的倒数第一个数不需要考虑
    	 进一步划分序列的倒数第二个数：
    		倒数第2个数为: 空
                1
    		倒数第2个数为: b[1]
                -----b[1]-b[j] 倒数第2个是b[1]以b[j]结尾的
                f[i-1][1]+1
            倒数第2个数为: b[2]
                -----b[2]-b[j] 倒数第2个是b[2]以b[j]结尾的
                f[i-1][2]+1
            ......
            倒数第2个数为: b[j-1]
                
            总结：f[i-1][k]+1
    		
      2）所有不包含a[i]的公共上升子序列
    	 f[i-1][j]
```

**代码：**

**暴力**

```c
/*
 * @Descripttion: 
 * @version: 
 * @Author: ZKYAAA
 * @Date: 2023-07-21 22:56:49
 * @LastEditors: 请叫我ZK谕啊啊啊
 * @LastEditTime: 2023-07-21 23:02:51
 */
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 3010;

int n;
int a[N],b[N];
int f[N][N];

int main() {
    scanf("%d",&n);
    for(int i = 1; i <= n; i++) scanf("%d",&a[i]);
    for(int i = 1; i <= n; i++) scanf("%d",&b[i]);

    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= n; j++) {
            f[i][j] = f[i-1][j];    //所有不包含a[i]的公共上升子序列
            // 所有包含a[i]的公共上升子序列
            if(a[i]==b[j]){
                f[i][j] = max(f[i][j],1);   //处理倒数第2个数为: 空
                for(int k = 1; k < j; k++) {
                    if(b[k] < b[j]) {
                        f[i][j] = max(f[i][j],f[i][k]+1);
                    }
                }
            }
        }
    }

    int res = 0;
    for(int i = 1; i <= n; i++) res = max(res,f[n][i]);
    printf("%d",res);
    return 0;
}
```

**优化**

```c
#include <iostream>

using namespace std;

const int N = 3010;

int n;
int a[N], b[N];
int f[N][N];

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i ++ ) cin >> a[i];
    for (int i = 1; i <= n; i ++ ) cin >> b[i];

    for (int i = 1; i <= n; i ++ )
    {
        int maxv = 1;
        for (int j = 1; j <= n; j ++ )
        {
            f[i][j] = f[i - 1][j];
            if (a[i] == b[j]) f[i][j] = max(f[i][j], maxv);

            if (b[j] < a[i])
                maxv = max(maxv, f[i - 1][j] + 1);
        }
    }

    int res = 0;
    for (int i = 1; i <= n; i ++ ) res = max(res, f[n][i]);
    cout << res << endl;

    return 0;
}
```



### 3、背包模型（组合类型DP）

```
当空间优化为1维之后，只有完全背包问题的体积是从小到大循环的（多重背包特殊）
for 物品
	for 体积
		for 决策(划分子集)
		
完全背包：求所有前缀和最大值
多重背包：求滑动窗口内的最大值
		
背包问题：
（1）状态表示f[i][j]
	1）集合：所有只从前i个物品中选，且总体积不超过j的选法的集合
	2）属性：max
（2）状态计算
	集合划分（划分依据：用最后一步来划分）
	1) 01背包：每个物品选或者不选(体积从大到小循环)
		① 选择第i个武平的所有方案
			-------  物品i
			-------  物品i
			-------  物品i
			。。。。。
			-------  物品i
			
			物品i的占用了Vi,所以左边部分 ------- <= J-Vi
			f[i-1][j-vi] + wi
		② 不选择第i个物品的所有的方案
			f[i-1][j]
		两种方法取最大：res = max(f[i-1][j],f[i-1][j-vi] + wi)
		
	2） 完全背包：每个物品选0，选1个，选2个....选s个
		① 选择第i个武平的所有方案
			-------  物品i选0个
				f[i-1][j]
			-------  物品i选1个
				f[i-1][j-vi] + wi
			-------  物品i选2个
				f[i-1][j-2*vi] + 2*wi
			。。。。。
			-------  物品i选s个
				f[i-1][j-s*vi] + s*wi
			
			物品i的占用了Vi,所以左边部分 ------- <= J-Vi
			f[i-1][j-vi] + wi
		② 优化
			
		两种方法取最大：
			f[i][j] = max( f[i-1][j], f[i-1][j-vi] + wi, f[i-1][j-2*vi] + 2*wi, ....,f[i-1][j-s*vi] + s*wi)
			f[i][j-vi] = max( f[i-1][j-vi], f[i-1][j-2*vi] + wi, f[i-1][j-3*vi] + 2*wi, ....,f[i-1][j-s*vi] + s*wi)
			
			f(i,j)=max(f(i-1,j) , f(i-1,j-v)+w , f(i-1,j-2*v)+2w , f(i-1,j-3*v)+3w ,.. )
            f(i,j-v)=max(         f(i-1,j-v)   , f(i-1,j-2*v)+ w , f(i-1,j-3*v)+2w ,.. )       
            		=>f(i,j)=max(f(i-1,j),f(i-1,j-v)+w)
	
	3） 多重背包(队列优化)：每个物品选0个，选1个，....选si个
		集合的划分:分若干组，按照第i个物品选多少个分(完全背包类似)
            0 1 2 3 4 5 .... s[i]  第i个物品选了0~k个
            注意：下面的式子是理想情况，当j不够的时候，边界情况需要额外考虑
            f(i,j)=max(f(i-1,j) , f(i-1,j-v)+w , f(i-1,j-2*v)+2w , f(i-1,j-3*v)+3w ,..f(i-1,j-s*v)+sw )
            f(i,j-v)=max(         f(i-1,j-v)   , f(i-1,j-2*v)+ w , f(i-1,j-3*v)+2w ,..         f(i-1,j-(s+1)*v)+sw )       
            	和完全背包不同的是第二个式子最后一项，是 -(s+1)*v，求j-v前面到j-sv的最大值
            f(i,j-2v)=max(                       f(i-1,j-2*v)     , f(i-1,j-3*v)+w ,..         f(i-1,j-(s+1)*v)+(s-1)*w...)  
            f(i,j-3v)=
            ........
            
            j,-v,j-2v,j-3v.....都是j mod v的余数
            设r为j mod v的余数
            r	    r+v	   r+2v	   r+3v	  r+4v	r+5v	.....	j-v		j
           -0*w    -1*w    -2*w    -3*w   -4*w   .....
            当求f[j]的时候，就是求f[j-v]前面n步的最大值（滑动窗口）
            		
		状态转移方程：f(i,j)=max(f[i][j],f[i-1][j-v[i]*k]+w[i]*k)  k=0,1,2.....s[i]
```

### （零）背包问题

```
DP  1.状态(一个集合)表示
		二维：f(i,j)
		1.1 集合：所有选法
				条件：（1）只从前i个物品中选
					 （2）总体积<=j
		1.2 属性：max值,min值,元素数量
	2.状态计算:一步一步的将状态计算出来
		集合的划分,不重复（不一定需要必须满足），不遗漏
		f(i,j)集合划分为若干个更小的子集，每个子集都能求出答案
		（1）选法不包含i：f(i-1,j)
			所有从1-i中选，总体积<=j，不包含i中选择
			所有从1~i-1中选，总体积<=j选法
		（2）选法包含i: f(i-1,j-Vi)+Wi
			所有从1-i中选，总体积<=j，包含i中选择
		  =>将Vi拿走结果不变
		  =>所有从1~i-1中选，总体积<=j-Vi，包含i中选择:f(i-1,j-Vi)+Wi
		  
		  最终f(i,j)=max(f(i-1,j),f(i-1,j-Vi)+Wi)
	3.dp优化
		对dp的代码和计算方程进行变形
```

```
1.01背包 ： 每件物品最多只能用一次
2.完全背包 ： 每件物品有无限个
3.多重背包及优化版本：每个物品有有限个，告诉限制个数
4.分组背包 ： 有N组，每组里面有若干元素，每组里面最多选择一个物品
```



#### 0.1  01背包问题

**[题目：AcWing 2. 01背包问题]()**

**题目描述**

有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。

第 i 件物品的体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

**输入格式**

第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。

接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

$0 < N,V ≤ 1000$

$0<vi,wi≤1000$

**输入样例：**

```c
4 5
1 2
2 4
3 4
4 5
```

**输出样例：**

```c
8
```

**题解：**

``` c
每件物品最多只能用一次
DP  1.状态(一个集合)表示
		二维：f(i,j)
		1.1 集合：所有选法
				条件：（1）只从前i个物品中选
					 （2）总体积<=j
    
		1.2 属性：max值
    
	2.状态计算:一步一步的将状态计算出来
		集合的划分,不重复（不一定需要必须满足），不遗漏
		f(i,j)集合划分为若干个更小的子集，每个子集都能求出答案
		（1）选法不包含i：f(i-1,j)
			所有从1-i中选，总体积<=j，不包含i
		  =>所有从1~i-1中选，总体积<=j选法
		（2）选法包含i: f(i-1,j-V[i])+Wi
			所有从1-i中选，总体积<=j，包含i中选择
		  =>将V[i]拿走,求不包含V[i]的答案，在加上V[i]的值w[i]
		  =>所有从1~i-1中选，总体积<=j-V[i]，包含i中选择:f(i-1,j-V[i])+W[i]
		  
		  最终f(i,j)=max(f(i-1,j),f(i-1,j-V[i])+W[i])
    3.优化
    	(1)f(i,j)=max(f(i-1,j),f(i-1,j-V[i])+W[i])每个阶段的i的状态只用到了i-1的状态，
            利用“滚动数组”优化，第二维要么是j要么是j-Vi都<=j;
			f[i][j] = f[i - 1][j];
		  =>f[i&1][j] = f[(i - 1)&1][j];

			f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
          =>f[i&1][j] = max(f[i&1][j], f[(i - 1)&1][j - v[i]] + w[i]);
			
			f[n][j]
          =>f[n&1][j]
            i的状态用i&1替代，当i为奇数的时候,i&1=1；当i为偶数的时候，i&1==0
            这样的话dp的状态就相当于在f[1][]和f[0][]两个数组中交替转化，O(NM)变为O(M)
            
            每个阶段实际上是执行了一次从f[i-1][]到f[i][]的拷贝操作，进一步省去f[i]
                
        (2)如果j从小往大遍历，后面的dp[j]可能已经被前面的更新了，相当于dp[i][j - v[i]]
        (3)所以让j从大到小倒序遍历。当j的时候，f数组的后半部分f[j~m]处于i阶段，就是放入第i个物品的情况；前半部分f[0~j-1]处于第i-1阶段，也就是没有i的更新；j减小就是用i-1状态去更新i状态。
        (4)如果是正序遍历j的话，可能会覆盖，产生矛盾
            
    4.注意：
    	(1)初值：f[0,0]=0,其余为负无穷
                
```

**代码：**

```c
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 1010;
int n, m;
int v[N], w[N];
int f[N][N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> v[i] >> w[i];
    // f[0~n][0~m]
    // f[0][0~m]=0，一件物品也没有选，都为0,所以不用枚举
    for (int i = 1; i <= n; i++)
    {
        // j=0表示一共选了体积为0的物体
        for (int j = 0; j <= m; j++)
        {
            //选法不包含i
            f[i][j] = f[i - 1][j];
            //选法包含i,第i件物品体积小于等于背包总容量
            if (j >= v[i])
                f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
        }
    }
    cout << f[n][m] << endl;
    return 0;
}
```

**优化后代码：**

```c
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 1010;
int n, m;
int v[N], w[N];
int f[N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> v[i] >> w[i];
    // f[0~n][0~m]
    // f[0][0~m]=0，一件物品也没有选，都为0,所以不用枚举
    for (int i = 1; i <= n; i++)
    {
        // j=0表示一共选了体积为0的物体	
        for (int j = m; j >= v[i]; j--)
        {
            f[j] = max(f[j], f[j - v[i]] + w[i]);
        }
    }
    cout << f[m] << endl;
    return 0;
}
```



#### 0.2 完全背包问题

**[题目：AcWing 3. 完全背包问题]()**

**题目描述**

有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。

第 i 种物品的体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

**输入格式**

第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。

接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 种物品的体积和价值。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

$0 < N,V ≤ 1000$

$0 < vi,wi ≤ 1000$

**输入样例：**

```c
4 5
1 2
2 4
3 4
4 5
```

**输出样例：**

```c
10
```

**题解：**

> **结论**：
>
> 将0-1背包中j的循环顺序改成从小到大，就变成了完全背包。
>
> 0-1背包：`dp[i][j] = max(dp[i-1][j], dp[i-1][j-vi]+wi)`
>
> 完全背包：`dp[i][j] = max(dp[i-1][j], dp[i][j-vi]+wi)`
>
> 0-1背包是从 i-1 转移过去的（从大到小枚举的），完全背包是从 i 转移过去的（从小到大枚举）

``` c
每件物品有无限个
DP 1.状态表示f(i,j)
    	1.1 集合
    		所有只考虑前i个物品，且总体积不大于j的所有选法
    	1.2 属性
    		Max
   2.状态计算
    	集合的划分:分若干组，按照第i个物品选多少个分
            0 1 2 3 4 5 ....k-1 k  第i个物品选了0~k个
            f(i,j)表示选第i个物品，总体积不超过j
    	(1)第i个物品不选，只考虑前1~i-1的话用f(i-1,j)表示
            当k=0,f(i-1,j)=f(i-1,j-k*v[i])+k*w[i]
        (2)第i个物品选，选k个
            1)去掉k个物品i
            2)求MAX,f(i-1,j-k*v[i])
            3)再加回来k个物品i
            =>f(i-1,j-k*v[i])+k*w[i]
     	=>f(i,j)=f(i-1,j-v[i]*k)+w[i]*k
            
   3.优化
   	f(i,j)=max(f(i-1,j) ,f(i-1,j-v)+w ,f(i-1,j-2*v)+2w ,f(i-1,j-3*v)+3w ,..,f(i-1,j-(k-1)*v)+(k-1)*v ,f(i-1,j-k*v)+k*v)
    f(i,j-v)=max(        f(i-1,j-v)   ,f(i-1,j-2*v)+ w ,f(i-1,j-3*v)+2w ,..,f(i-1,j-(k-1)*v)+(k-2)*v ,f(i-1,j-k*v)+(k-1)*v)       
            =>f(i,j)=max(f(i-1,j),f(i-1,j-v)+w)
        
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;
const int N = 1010;

int n, m;
int v[N], w[N];
int f[N][N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> v[i] >> w[i];

    for (int i = 1; i <= n; i++)
        for (int j = 0; j <= m; j++)
            for (int k = 0; k * v[i] <= j; k++)
                f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);
    cout << f[n][m] << endl;
    return 0;
}
```

**优化代码**

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;
const int N = 1010;

int n, m;
int v[N], w[N];
int f[N][N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> v[i] >> w[i];

    for (int i = 1; i <= n; i++)
        for (int j = 0; j <= m; j++)
        {
            f[i][j] = f[i - 1][j];
            if (j >= v[i])
                f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]);
        }

    cout << f[n][m] << endl;
    return 0;
}
```

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;
const int N = 1010;

int n, m;
int v[N], w[N];
int f[N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> v[i] >> w[i];

    for (int i = 1; i <= n; i++)
        for (int j = v[i]; j <= m; j++)
            f[j] = max(f[j], f[j - v[i]] + w[i]);

    cout << f[m] << endl;
    return 0;
}
```



#### 0.3 多重背包问题

**[题目：AcWing 4. 多重背包问题 I]()**

**题目描述**

有 N 种物品和一个容量是 V 的背包。

第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。

**输入格式**

第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。

接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

$0 < N,V ≤ 100$

$0 < vi,wi,si ≤ 100$

**输入样例：**

```c
4 5
1 2 3
2 4 1
3 4 3
4 5 2
```

**输出样例：**

```c
10
```

**题解：**

``` c
DP 1.状态表示f(i,j)
    1.1 集合
    	所有从前i个物品中选，并且总体积不超过j的选法
    
    1.2 属性
    	Max，总价值的最大值
    
    2.状态计算
    	集合的划分:分若干组，按照第i个物品选多少个分(完全背包类似)
            0 1 2 3 4 5 .... s[i]  第i个物品选了0~k个
            
		状态转移方程：f(i,j)=max(f[i][j],f[i-1][j-v[i]*k]+w[i]*k)  k=0,1,2.....s[i]
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 110;

int n, m;
int v[N], w[N], s[N];
int f[N][N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> v[i] >> w[i] >> s[i];

    for (int i = 1; i <= n; i++)
        for (int j = 0; j <= m; j++)
            for (int k = 0; k <= s[i] && k * v[i] <= j; k++)
                f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);

    cout << f[n][m] << endl;
    return 0;
}
```



**[题目：AcWing 5. 多重背包问题 II]()**

**题目描述**

有 N 种物品和一个容量是 V 的背包。

第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。

输出最大价值。

**输入格式**

第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。

接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

$0 < N ≤ 1000$

$0 < V ≤ 2000$

$0 < vi,wi,si ≤ 2000$

**输入样例：**

```c
4 5
1 2 3
2 4 1
3 4 3
4 5 2
```

**输出样例：**

```c
10
```

**题解：**

``` c
DP 1.状态表示f(i,j)
    1.1 集合
    	所有从前i个物品中选，并且总体积不超过j的选法
    
    1.2 属性
    	Max，总价值的最大值
    
    2.状态计算
    	集合的划分:分若干组，按照第i个物品选多少个分(完全背包类似)
            0 1 2 3 4 5 .... s[i]  第i个物品选了0~k个
            
		状态转移方程：f(i,j)=max(f[i][j],f[i-1][j-v[i]*k]+w[i]*k)  k=0,1,2.....s[i]
    3.优化
    f(i,j)=max(f(i,j),f(i-1,j-v)+w,f(i-1,j-2v)+2w,......f(i-1,j-sv)+sw)
    f(i,j-v)=max(     f(i-1,j-v),  f(i-1,j-2v)+w, ......f(i-1,j-sv)+(s-1)w ,f(i-1,j-(s+1)v)+sw);
		
	二进制优化 
        有s个物品：
        1，2，4，8，.....2^k,C
        C< 2^(k+1)
        所以可以凑出来C~C+2^(k+1)-1的数
```

**代码**

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 110;

int n, m;
int v[N], w[N], s[N];
int f[N][N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> v[i] >> w[i] >> s[i];

    for (int i = 1; i <= n; i++)
        for (int j = 0; j <= m; j++)
            for (int k = 0; k <= s[i] && k * v[i] <= j; k++)
                f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);

    cout << f[n][m] << endl;
    return 0;
}
```

**代码优化：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

// 1000 * log(2000) 开数据
const int N = 25000, M = 2010;

int n, m;
int v[N], w[M];
int f[N];

int main()
{
    cin >> n >> m;

    int cnt = 0;

    for (int i = 1; i <= n; i++)
    {
        int a, b, s;
        cin >> a >> b >> s;
        //小于S的时候一直减了凑：1+2+4+8+...+2^k+c <= s
        int k = 1;
        while (k <= s)
        {
            cnt++;
            v[cnt] = a * k;
            w[cnt] = b * k;
            s -= k;
            k *= 2;
        }
        //此时c == s
        if (s > 0)
        {
            cnt++;
            v[cnt] = a * s;
            w[cnt] = b * s;
        }
    }
    n = cnt;
    for (int i = 1; i <= n; i++)
        for (int j = m; j >= v[i]; j--)
            f[j] = max(f[j], f[j - v[i]] + w[i]);
    cout << f[m] << endl;
    return 0;
}
```

#### 0.4 分组背包问题

**[题目：AcWing 9. 分组背包问题]()**

**题目描述**

有 N 组物品和一个容量是 V 的背包。

每组物品有若干个，同一组内的物品最多只能选一个。

每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。

求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。

输出最大价值。

**输入格式**

第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。

接下来有 N 组数据：

- 每组数据第一行有一个整数 Si，表示第 i 个物品组的物品数量；
- 每组数据接下来有 Si 行，每行有两个整数 vij,wij，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值；

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

$0 < N,V ≤ 100$

$0 < Si ≤ 100$

$0 < vij,wij ≤ 100$

**输入样例：**

```c
3 5
2
1 2
2 4
1
3 4
1
4 5
```

**输出样例：**

```c
8
```

**题解：**

``` c
DP 1.状态表示f(i,j)
    1.1 集合
    	所有从前i组物品中选，并且总体积不大于j的选法
    
    1.2 属性
    	Max，总价值的最大值
    
   2.状态计算
    	集合的划分:分若干组，按照第i个物品选多少个分(完全背包类似)
            0 1 2 3 4 5 .... s[i]  选第i组的第k个物品选了0~k个
        (1)第i组的一个都不选
            f(i-1,j)
        (2)第i组物品选第k个物品
            f(i-1,j-v[i,k])+w[i,k]
           
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 110;
int n, m;
// s存每组的个数
int v[N][N], w[N][N], s[N];
int f[N];

int main()
{
    cin >> n >> m;

    for (int i = 1; i <= n; i++)
    {
        cin >> s[i];
        for (int j = 0; j < s[i]; j++)
            cin >> v[i][j] >> w[i][j];
    }

    for (int i = 1; i <= n; i++)
    {
        for (int j = m; j >= 0; j--)
        {
            for (int k = 0; k < s[i]; k++)
            {
                if (v[i][k] <= j)
                    f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);
            }
        }
    }
    cout << f[m] << endl;
    return 0;
}
```

### （一）01-背包应用

**[题目：AcWing 423. 采药  ](https://www.acwing.com/problem/content/425/)**

#### 3.1 采药

**题目描述**

辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。

为此，他想拜附近最有威望的医师为师。

医师为了判断他的资质，给他出了一个难题。

医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”

如果你是辰辰，你能完成这个任务吗？

**输入格式**

输入文件的第一行有两个整数 T 和 M，用一个空格隔开，T  代表总共能够用来采药的时间，M 代表山洞里的草药的数目。

接下来的 M 行每行包括两个在 1 到 100 之间（包括 1 和 100）的整数，分别表示采摘某株草药的时间和这株草药的价值。

**输出格式**

输出文件包括一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。

**数据范围**

$1≤T≤1000$,
$1≤M≤100$

**输入样例：**

```c
70 3
71 100
69 1
1 2
```

**输出样例：**

```c
3
```

**题解：**

``` c
组合数+选择问题（采摘/不采摘）+没有顺序
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 1010;

int n,m;
int f[N];

int main() {
  cin>>m>>n;
  for(int i = 0; i < n; i++) {
    int v, w;
    cin>>v>>w;
    for(int j = m; j >= v; j--) f[j] = max(f[j],f[j-v] + w);
  }

  cout<< f[m] << endl;
  return 0;
}
```



#### 3.2 装箱问题

[Acwing1024. 装箱问题](https://www.acwing.com/problem/content/1026/)

**题目描述**

有一个箱子容量为 V，同时有 n 个物品，每个物品有一个体积（正整数）。

要求 n 个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。

**输入格式**

第一行是一个整数 V，表示箱子容量。

第二行是一个整数 n，表示物品数。

接下来 n 行，每行一个正整数（不超过10000），分别表示这 n 个物品的各自体积。

**输出格式**

一个整数，表示箱子剩余空间。

**数据范围**

$0<V≤20000$,
$0<n≤30$

**输入样例：**

```c
24
6
8
3
12
7
9
7
```

**输出样例：**

```c
0
```

**题解：**

``` c
价值和体积都看作体积
    总体积最大 等价于 箱子剩余空间最小
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 20010;

int m,n;
int f[N];

int main() {
  cin>>m>>n;
  for(int i = 0; i < n; i++) {
    int v;
    cin>> v;
    for(int j = m; j >= v; j--) f[j] = max(f[j],f[j - v]+v);
  }
  cout << m - f[m] << endl;
  return 0;
}
```



#### 3.3 数字组合（01背包求方案数）

[Acwing 278. 数字组合](https://www.acwing.com/problem/content/280/)

**题目描述**

给定 N 个正整数 $A_1,A_2,…,A_N$，从中选出若干个数，使它们的和为 M，求有多少种选择方案。

**输入格式**

第一行包含两个整数 N 和 M。

第二行包含 N 个整数，表示 $A_1,A_2,…,A_N$。

**输出格式**

包含一个整数，表示可选方案数。

**数据范围**

$1≤N≤100$,
$1≤M≤10000$,
$1≤A_i≤1000$,
答案保证在 int 范围内。

**输入样例：**

```c
4 4
1 1 2 2
```

**输出样例：**

```c
3
```

**题解：**

``` c
M看作背包容量
把每个数看成是一个物品，Ai看成是体积
目标:求出总体积恰好是M的方案数
    
DP
    (1)状态表示：f[i][j]
    	1)集合：所有只从前i个物品中选择，且总体积恰好是j的方案的集合
    	2)属性：Count
    
    (2)状态计算
    	集合划分
    	初始化f[0][0] = 1,f[0][i] = 0
    	1)不包括物品i的所有选法
    		f[i-1][j]
    	2)包括物品i的所有选法
    		..... 物品i
    		..... 物品i
    		..... 物品i
    		
    		物品i前面部分，从物品1~i-1中选择，且体积<=j-vi
    		f[i-1][j-vi]
    f[i][j] = f[i-1][j] + f[i-1][j-vi]
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 10010;

int n,m;
int f[N];

int main() {
  cin >> n >> m;
  f[0] = 1;
  for(int i = 0; i < n; i++) {
    int v;
    cin >> v;
    for(int j = m; j >= v; j--) {
      f[j] += f[j-v];
    }
  }
  cout << f[m] << endl;
  return 0;
}
```



#### 3.4 开心的金明

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```



#### 3.5 能量石（贪心）

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```





### （二）完全背包问题应用

#### 3.6 买书（方案数）

[Acwing 1023. 买书](https://www.acwing.com/problem/content/1025/)

**题目描述**

小明手里有n元钱全部用来买书，书的价格为10元，20元，50元，100元。

问小明有多少种买书方案？（每种书可购买多本）

**输入格式**

一个整数 n，代表总共钱数。

**输出格式**

一个整数，代表选择方案种数。

**数据范围**

0≤n≤1000

**输入样例1：**

```c
20
```

**输出样例1：**

```c
2
```

**输入样例2：**

```c
15
```

**输出样例2：**

```c
0
```

**输入样例3：**

```c
0
```

**输出样例3：**

```c
1
```

**题解：**

``` c
DP
    (1)状态表示f[i][j]
    	1）集合：所有只从前i个物品中选，且总体积恰好是j的方案的集合
    	2）属性：Count
    (2)状态计算
    	1) 物品i选0个
    		f[i-1][j]
    	2) 物品i选1个
    	3) 物品i选2个
    	4) 物品i选3个
    	......
		s)   物品i选s-1个
    	s+1) 物品i选s个
    
    	...... 物品i选择k个
    	...... 物品i选择k个
    	...... 物品i选择k个
    	...... 物品i选择k个
    	左边部分：只从前i-1中选择，体积<=j-vi*k
    			f[i-1][j-vi*k]
    	
    f[i][j] = f[i-1][j]+f[i-1][j-vi*1]+f[i-1][j-vi*2]+ ...+f[i-1][j-vi*s]
    f[i][j-vi] =        f[i-1][j-vi*1]+f[i-1][j-vi*2]+ ...+f[i-1][j-vi*s] + f[i-1][j-vi*(s+1)]
    f[i][j-vi] =        f[i-1][j-vi*1]+f[i-1][j-vi*2]+ ...+f[i-1][j-vi*s]
    最多可以选择s个，所以f[i-1][j-vi*(s+1)]不存在
    f[i][j] = f[i-1][j]+f[i][j-vi]
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 1010;

int v[5] = {0,10,20,50,100};
int f[5][N];

int main() {
  int m;
  cin >> m;

  f[0][0] = 1;
  for(int i = 1; i <= 4; i++) {
    for(int j = 0; j <= m; j++) {
      f[i][j] = f[i-1][j];
      if(j >= v[i]) f[i][j] += f[i][j-v[i]];
    }
  }
  cout<< f[4][m]<<endl;
  return 0;
}
```

**优化**

```c
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 1010;

int v[5] = {0,10,20,50,100};
int f[N];

int main() {
  int m;
  cin >> m;

  f[0] = 1;
  for(int i = 1; i <= 4; i++) {
    for(int j = 0; j <= m; j++) {
      if(j >= v[i]) f[j] += f[j-v[i]];
    }
  }
  cout<< f[m]<<endl;
  return 0;
}
```



#### 3.7  Acwing1021货币系统 （方案数）

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```



#### 3.8 AcWing 532. 货币系统(贪心)

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```



### （三）多重背包问题应用

#### 3.9 多重背包问题 III（困难）

**题目描述**

有 N 种物品和一个容量是 V 的背包。

第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。

**输入格式**

第一行两个整数，$N，V， (0<N≤1000, 0<V≤20000)$，用空格隔开，分别表示物品种数和背包容积。

接下来有 N 行，每行三个整数 $v_i,w_i,s_i$，用空格隔开，分别表示第 i 种物品的体积、价值和数量。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

$0<N≤1000$,
$0<V≤20000$,
$0<v_i,w_i,s_i≤20000$

**提示**

本题考查多重背包的单调队列优化方法。

**输入样例：**

```c
4 5
1 2 3
2 4 1
3 4 3
4 5 2
```

**输出样例：**

```c
10
```

**题解：**

``` c
	3） 多重背包(队列优化)：每个物品选0个，选1个，....选si个
		集合的划分:分若干组，按照第i个物品选多少个分(完全背包类似)
            0 1 2 3 4 5 .... s[i]  第i个物品选了0~k个
            注意：下面的式子是理想情况，当j不够的时候，边界情况需要额外考虑
            f(i,j)=max(f(i-1,j) , f(i-1,j-v)+w , f(i-1,j-2*v)+2w , f(i-1,j-3*v)+3w ,..f(i-1,j-s*v)+sw )
            f(i,j-v)=max(         f(i-1,j-v)   , f(i-1,j-2*v)+ w , f(i-1,j-3*v)+2w ,..         f(i-1,j-(s+1)*v)+sw )       
            	和完全背包不同的是第二个式子最后一项，是 -(s+1)*v，求j-v前面到j-sv的最大值
            f(i,j-2v)=max(                       f(i-1,j-2*v)     , f(i-1,j-3*v)+w ,..         f(i-1,j-(s+1)*v)+(s-1)*w...)  
            f(i,j-3v)=
            ........
            
            j,-v,j-2v,j-3v.....都是j mod v的余数
            设r为j mod v的余数
            r	    r+v	   r+2v	   r+3v	  r+4v	r+5v	.....	j-v		j
           -0*w    -1*w    -2*w    -3*w   -4*w   .....
            当求f[j]的时候，就是求f[j-v]前面n步的最大值（滑动窗口）
            		
		状态转移方程：f(i,j)=max(f[i][j],f[i-1][j-v[i]*k]+w[i]*k)  k=0,1,2.....s[i]
```

```c
	//滑动窗口内最小值模板
	// hh表示队头，tt表示队尾，头左尾右
    int hh = 0, tt = -1;
    for (int i = 0; i < n; i++)
    {
        //当队列不为空hh<=tt,每次判断队列头是否滑出了窗口，当前位置是i;
        //前面的k个数据的起始坐标i-k+1,不在得话则弹出队列头维持窗口大小
        //也就是删除i - k + 1 > q[hh]
        if (hh <= tt && i - k + 1 > q[hh])
            hh++;
        //构造单调队列，新的元素a[i]是否比队尾元素小，小得话则删除
        while (hh <= tt && a[q[tt]] >= a[i])
            tt--;
        //删除后将当前节点i加入到队列尾部
        q[++tt] = i;
        //每次的答案是队列头元素
        if (i >= k - 1)
            printf("%d ", a[q[hh]]);
    }
```



**代码：**

```c
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 20010;

int n, m;
int f[N], g[N], q[N];

int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i ++ )
    {
        int v, w, s;
        cin >> v >> w >> s;
        memcpy(g, f, sizeof f);
        for (int j = 0; j < v; j ++ )
        {
            int hh = 0, tt = -1;
            for (int k = j; k <= m; k += v)
            {
                //队头元素划出窗口了，队列元素已经超过s个了，则划出
                if (hh <= tt && q[hh] < k - s * v) hh ++ ;
                while (hh <= tt && g[q[tt]] - (q[tt] - j) / v * w <= g[k] - (k - j) / v * w) tt -- ;
                q[ ++ tt] = k;
                f[k] = g[q[hh]] + (k - q[hh]) / v * w;
            }
        } 
    }

    cout << f[m] << endl;

    return 0;
}
```

[推荐链接1](https://www.acwing.com/solution/content/53507/)

[推荐链接2](https://www.acwing.com/solution/content/6500/)



#### 3.10 庆功会

[Acwing 1019. 庆功会](https://www.acwing.com/problem/content/1021/)

**题目描述**

为了庆贺班级在校运动会上取得全校第一名成绩，班主任决定开一场庆功会，为此拨款购买奖品犒劳运动员。

期望拨款金额能购买最大价值的奖品，可以补充他们的精力和体力。

**输入格式**

第一行二个数n，m，其中n代表希望购买的奖品的种数，m表示拨款金额。

接下来n行，每行3个数，v、w、s，分别表示第I种奖品的价格、价值（价格与价值是不同的概念）和能购买的最大数量（买0件到s件均可）。

**输出格式**

一行：一个数，表示此次购买能获得的最大的价值（注意！不是价格）。

**数据范围**

$n≤500,m≤6000$,
$v≤100,w≤1000,s≤10$

**输入样例：**

```c
5 1000
80 20 4
40 50 9
30 50 7
40 30 6
20 20 1
```

**输出样例：**

```c
1040
```

**题解：**

``` c
分组背包
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 6010;

int n,m;
int f[N];

int main() {
  cin >> n >> m;
  for(int i = 0; i < n; i++) {
    int v,w,s;
    cin >> v >> w >> s;
    for(int j = m; j >= 0; j--) {
      for(int k = 0; k <= s && k * v <= j; k++) {
        f[j] = max(f[j],f[j-k*v]+ k * w);
      }
    }
  }
  cout << f[m] << endl;
  return 0;
}
```



### （四）二维费用的背包问题

#### 3.11 二维费用的背包问题

[Axwing 8.二维费用的背包问题](https://www.acwing.com/problem/content/8/)

**题目描述**

有 N 件物品和一个容量是 V 的背包，背包能承受的最大重量是 M。

每件物品只能用一次。体积是 $v_i$，重量是 $m_i$，价值是 $w_i$。

求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。
输出最大价值。

**输入格式**

第一行三个整数，$N,V,M$，用空格隔开，分别表示物品件数、背包容积和背包可承受的最大重量。

接下来有 N 行，每行三个整数 $v_i,m_i,w_i$，用空格隔开，分别表示第 i 件物品的体积、重量和价值。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

$0<N≤1000$
$0<V,M≤100$
$0<v_i,m_i≤100$
$0<w_i≤1000$

**输入样例：**

```c
4 5 6
1 2 3
2 4 4
3 4 5
4 5 6
```

**输出样例：**

```c
8
```

**题解：**

``` c
二维费用：
    01背包
    完全背包
    多重背包
    
DP
    (1)状态表示 f[i,j,k]
    	1)集合：所有只从前i个物品中选，并且总体积不超过j，总重量不超过k的选法
    	2)属性：Max
    (2)状态计算
    	集合表示
    	1)所有不包含物品i的选法
    		只从前i-1个中选择
    		f[i-1,j,k]
    	2)所有包含物品i的选法
    		...... 物品i	
    		...... 物品i
    		...... 物品i
			 前i-1物品：1~i-1
    		 前i-1体积: <= j- vi
             前i-1重量: <= k -mi
           f[i-1,j-vi,k-mi]+wi
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 110;

int n,V,M;
int f[N][N];

int main() {
  cin>>n>>V>>M;
  for(int i = 0; i < n; i++) {
    int v,m,w;
    cin>> v >> m >> w;
    for(int j = V; j >= v; j--) {
      for(int k = M; k >= m; k--) {
        f[j][k] = max(f[j][k],f[j - v][k - m] + w);
      }
    }
  }
  cout << f[V][M]<<endl;
  return 0;
}
```



#### 3.12 宠物小精灵之收服（二维费用-阅读理解题）

[Acwing 1022. 宠物小精灵之收服](https://www.acwing.com/problem/content/1024/)

**题目描述**

宠物小精灵是一部讲述小智和他的搭档皮卡丘一起冒险的故事。

一天，小智和皮卡丘来到了小精灵狩猎场，里面有很多珍贵的野生宠物小精灵。

小智也想收服其中的一些小精灵。

然而，野生的小精灵并不那么容易被收服。

对于每一个野生小精灵而言，小智可能需要使用很多个精灵球才能收服它，而在收服过程中，野生小精灵也会对皮卡丘造成一定的伤害（从而减少皮卡丘的体力）。

当皮卡丘的体力小于等于0时，小智就必须结束狩猎（因为他需要给皮卡丘疗伤），而使得皮卡丘体力小于等于0的野生小精灵也不会被小智收服。

当小智的精灵球用完时，狩猎也宣告结束。

我们假设小智遇到野生小精灵时有两个选择：收服它，或者离开它。

如果小智选择了收服，那么一定会扔出能够收服该小精灵的精灵球，而皮卡丘也一定会受到相应的伤害；如果选择离开它，那么小智不会损失精灵球，皮卡丘也不会损失体力。

小智的目标有两个：主要目标是收服尽可能多的野生小精灵；如果可以收服的小精灵数量一样，小智希望皮卡丘受到的伤害越小（剩余体力越大），因为他们还要继续冒险。

现在已知小智的精灵球数量和皮卡丘的初始体力，已知每一个小精灵需要的用于收服的精灵球数目和它在被收服过程中会对皮卡丘造成的伤害数目。

请问，小智该如何选择收服哪些小精灵以达到他的目标呢？

**输入格式**

输入数据的第一行包含三个整数：N，M，K，分别代表小智的精灵球数量、皮卡丘初始的体力值、野生小精灵的数量。

之后的 K 行，每一行代表一个野生小精灵，包括两个整数：收服该小精灵需要的精灵球的数量，以及收服过程中对皮卡丘造成的伤害。

**输出格式**

输出为一行，包含两个整数：C，R，分别表示最多收服C个小精灵，以及收服C个小精灵时皮卡丘的剩余体力值最多为R。

**数据范围**

$0<N≤1000$,
$0<M≤500$,
$0<K≤100$

**输入样例1：**

```c
10 100 5
7 10
2 40
2 50
1 20
4 20
```

**输出样例1：**

```c
3 30
```

**输入样例2：**

```c
10 100 5
8 110
12 10
20 10
5 200
1 110
```

**输出样例2：**

```c
0 100
```

**题解：**

``` c
花费1：精灵球数量
花费2：皮卡丘体力值
价值：小精灵的数量
     
DP
    (1)状态表示: f[i,j,k]
    1）集合：所有从前i物品中选择，且花费1不超过j，花费2不超过k的选法的最大价值
    2）属性：max
    
    (2)状态计算
    集合的划分
    不选择：f[i-1,j,k]
    选择：j-v1[i],k-v2[i]] + 1 （价值为1）
    f[i,j,k] = max(f[i-1,j,k],f[i-1,j-v1[i],k-v2[i]] + 1)
    
    最多收复的小精灵的数量f[k,N,M]
    最少耗费体力的计算 f[k,N,m] == f[k,N,M]
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 1010, M = 510;

int n, V1, V2;
int f[N][M];

int main() {
  cin>>V1>>V2>>n;
  for(int i = 0; i < n; i++) {
    int v1,v2;
    cin >> v1>> v2;
    for(int j = V1; j>= v1; j--) {
      for(int k = V2; k >= v2; k--) {
        f[j][k] = max(f[j][k],f[j-v1][k-v2]+1);
      }
    }
  }
  cout<<f[V1][V2]<<' ';
  int k = V2;
  while(k > 0 && f[V1][k-1]==f[V1][V2]) k--;
  cout<<V2-k<<endl;
  return 0;
}
```



#### 3.13 潜水员（回）

[Acwing 1020. 潜水员](https://www.acwing.com/problem/content/1022/)

**题目描述**

潜水员为了潜水要使用特殊的装备。

他有一个带2种气体的气缸：一个为氧气，一个为氮气。

让潜水员下潜的深度需要各种数量的氧和氮。

潜水员有一定数量的气缸。

每个气缸都有重量和气体容量。

潜水员为了完成他的工作需要特定数量的氧和氮。

他完成工作所需气缸的总重的最低限度的是多少？

例如：潜水员有5个气缸。每行三个数字为：氧，氮的（升）量和气缸的重量：

```
3 36 120

10 25 129

5 50 250

1 45 130

4 20 119
```

如果潜水员需要5升的氧和60升的氮则总重最小为249（1，2或者4，5号气缸）。

你的任务就是计算潜水员为了完成他的工作需要的气缸的重量的最低值。

**输入格式**

第一行有2个整数 m，n。它们表示氧，氮各自需要的量。

第二行为整数 k 表示气缸的个数。

此后的 k 行，每行包括$a_i，b_i，c_i$，3个整数。这些各自是：第 i 个气缸里的氧和氮的容量及气缸重量。

**输出格式**

仅一行包含一个整数，为潜水员完成工作所需的气缸的重量总和的最低值。

**数据范围**

$1≤m≤21$,
$1≤n≤79$,
$1≤k≤1000$,
$1≤a_i≤21$,
$1≤b_i≤79$
$1≤c_i≤800$

**输入样例：**

```c
5 60
5
3 36 120
10 25 129
5 50 250
1 45 130
4 20 119
```

**输出样例：**

```c
249
```

**题解：**

``` c
技巧一：
DP常见状态表示的体积的三种情况
1、体积最多是j
    (更新的时候必须保证v>=0)
    初始化时候，全部为0
    
2、体积恰好是j
    恰好j,k初始化(更新的时候必须保证v>=0)：
    	(1)f[0] = 0;  (合法方案)
		(2)其余的f[i] = +∞ / -1  (不合法方案)
        对应本题如果是恰好
    	f[0,0,0] = 0        (合法方案)
    	f[0,j,k] = +∞ / -1  (不合法方案)
    	j>=v1i,k>=v2i
    
3、体积至少是j(✔)
    至少j,k初始化(更新的时候没有v的限制)：
        (1)f[0] = 0;  (合法方案)
		(2)其余的f[i] = +∞ / -1  (不合法方案)
        对应本题如果是至少
    	f[0,0,0] = 0        (合法方案)
    	f[0,j,k] = +∞ / -1  (不合法方案)
    	j>=v1i,k>=v2i -->合法
    	j<=v1i,k<=v2i -->此时也合法
            
技巧二：
for 物品
	for 体积
		for 决策(划分子集)
     从i-1转移到i的，遍历体积的时候，从大到小循环
     从i转移到i-1的，遍历体积的时候，从小到大循环

需要特定数量的氧和氮。
氧气：费用1 >= m
氮气：费用2 >= n
价值：重量   最小值
    
DP
    (1)状态表示 f[i][j][k]
    	1)集合：所有只从前i个物品中选，并且氧气含量至少是j，氮气含量至少是k的所有选法
    	2)属性：Min
    (2)状态计算
    	集合表示
    	1)所有不含物品i的所有选法
    		f[i-1][j][k]
    	2)所有包含物品i的所有选法
    		f[i-1][j-v1i][k-v2i] + wi	
    
    二维费用模板的时候：
    不超过：
    	f[0,j,k] = 0		(合法方案)
    
```

**代码：**

```c
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;
const int N = 22, M = 80;   

int n,m,K;
int f[N][M];

int main() {
  cin >> n >> m >> K;
  memset(f, 0x3f, sizeof f);
  f[0][0] = 0;

  while(K--) {
    int v1 , v2, w;
    cin >> v1 >> v2 >> w;
    for(int j = n; j >= 0; j--) {
      for(int k = m; k >= 0; k--) {
        f[j][k] = min(f[j][k],f[max(0,j-v1)][max(0,k-v2)] + w);
      }
    }
  }
  cout<<f[n][m]<<endl;
  return 0;
}
```



### （五）分组背包应用

#### 3.14 机器分配

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```



#### 3.15 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```





#### 3.15 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```



#### 3.15 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```



#### 3.15 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```



### （六）背包问题求具体方案

#### 3.1x  背包问题求具体方案

[Acwing 12. 背包问题求具体方案](https://www.acwing.com/problem/content/12/)

**题目描述**

有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。

第 i 件物品的体积是 $v_i$，价值是 $w_i$。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

输出 **字典序最小的方案**。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是 $1…N$。

**输入格式**

第一行两个整数，$N，V$，用空格隔开，分别表示物品数量和背包容积。

接下来有 N 行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 i 件物品的体积和价值。

**输出格式**

输出一行，包含若干个用空格隔开的整数，表示最优解中所选物品的编号序列，且该编号序列的字典序最小。

物品编号范围是 $1…N$。

**数据范围**

$0<N,V≤1000$,
$0<v_i,w_i≤1000$

**输入样例：**

```c
4 5
1 2
2 4
3 4
4 6
```

**输出样例：**

```c
1 4
```

**题解：**

``` c
状态转移：f[i][j] = max(f[i-1][j],f[i-1][j-v[i]]+ w[i])
最终求:f[n][m]
    
求背包问题具体的方案其实就是判断出每个物品是否被选
-> 最短路问题，求最短路径 
	f[n-1][m]
    	       \ 
    			   f[n][m]
    	       /
f[n-1][m-v[n]] (对应权重为w[n])
看f[n][m]和哪个相等，相等则是从前一个状态转移过来的
f[n][m] = f[n-1][m]
    	= f[n-1][m-v[n]] + w[n]
    	= 上面两个都可以
    
三种情况：
    1、只能选  必选
    2、只能不选 必不选
    3、可选/可不选  一定选择第一个
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 1010;

int n,m;
int v[N], w[N];
int f[N][N];

int main() {
  cin >> n >> m;
  for(int i = 1; i <= n; i++) cin >> v[i] >> w[i];

  //倒着来推导，需要先把v和w 读进来
  for(int i = n; i >= 1; i--) {
    for(int j = 0; j <= m; j++) {
      f[i][j] = f[i+1][j];
      if(j >= v[i]) 
        f[i][j] = max(f[i][j], f[i+1][j-v[i]] + w[i]);
    }
  }

  int j = m;
  for(int i = 1; i <= n; i++) {
    if(j >= v[i] && f[i][j] == f[i+1][j-v[i]] + w[i]){
      cout<< i << ' ';
      j -= v[i];
    }
  }
  return 0;
}
```



#### 3.15 机器分配（分组背包+方案数）

[Acwing 1013. 机器分配](https://www.acwing.com/problem/content/1015/)

**题目描述**

总公司拥有 M 台 **相同** 的高效设备，准备分给下属的 N 个分公司。

各分公司若获得这些设备，可以为国家提供一定的盈利。盈利与分配的设备数量有关。

问：如何分配这 M 台设备才能使国家得到的盈利最大？

求出最大盈利值。

分配原则：每个公司有权获得任意数目的设备，但总台数不超过设备数 M。

**输入格式**

第一行有两个数，第一个数是分公司数 N，第二个数是设备台数 M；

接下来是一个 $N×M$ 的矩阵，矩阵中的第 i 行第 j 列的整数表示第 i 个公司分配 j 台机器时的盈利。

**输出格式**

第一行输出最大盈利值；

接下 N 行，每行有 2 个数，即分公司编号和该分公司获得设备台数。

答案不唯一，输出任意合法方案即可。

**数据范围**

$1≤N≤10$,
$1≤M≤15$

**输入样例：**

```c
3 3
30 40 50
20 30 50
20 25 30
```

**输出样例：**

```c
70
1 1
2 1
3 1
```

**题解：**

``` c
1h 13min
```

**代码：**

```c

```

### 

## 二、搜索

### 1、BFS

应用：

①最短距离

②最小步数

特点：

①求最小，最短

②基于迭代的思想，不会爆栈

#### (1) Flood Fill

**在线性时间复杂度里面，找到某个点所在的连通块**

#### Acwing 池塘计数（八连通BFS）

**[题目：AcWing1097. 池塘计数]()**

**题目描述**

农夫约翰有一片 N∗M 的矩形土地。

最近，由于降雨的原因，部分土地被水淹没了。

现在用一个字符矩阵来表示他的土地。

每个单元格内，如果包含雨水，则用”W”表示，如果不含雨水，则用”.”表示。

现在，约翰想知道他的土地中形成了多少片池塘。

每组相连的积水单元格集合可以看作是一片池塘。

每个单元格视为与其上、下、左、右、左上、右上、左下、右下八个邻近单元格相连。

请你输出共有多少片池塘，即矩阵中共有多少片相连的”W”块。

**输入格式**

第一行包含两个整数 N 和 M。

接下来 N行，每行包含 M个字符，字符为”W”或”.”，用以表示矩形土地的积水状况，字符之间没有空格。

**输出格式**

输出一个整数，表示池塘数目。

**数据范围**

1≤N,M≤1000	

**输入样例：**

```c
10 12
W........WW.
.WWW.....WWW
....WW...WW.
.........WW.
.........W..
..W......W..
.W.W.....WW.
W.W.W.....W.
.W.W......W.
..W.......W.
```

**输出样例：**

```c
3
```

**题解：**

``` c

```

**代码：**

```c
#include <cstring>
#include <iostream>
#include <algorithm>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 1010, M = N * N;

int n, m;
char g[N][N];
PII q[M];
bool st[N][N];	//bfs很多时候都需要开标记数组

void bfs(int sx, int sy)
{
    int hh = 0, tt = 0;
    q[0] = {sx, sy};
    st[sx][sy] = true;

    while (hh <= tt)
    {
        PII t = q[hh ++ ];

        for (int i = t.x - 1; i <= t.x + 1; i ++ )
            for (int j = t.y - 1; j <= t.y + 1; j ++ )
            {
                if (i == t.x && j == t.y) continue;
                //判重，越界，撞墙
                if (i < 0 || i >= n || j < 0 || j >= m) continue;
                if (g[i][j] == '.' || st[i][j]) continue;
                q[ ++ tt] = {i, j};
                st[i][j] = true;
            }
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 0; i < n; i ++ ) scanf("%s", g[i]);

    int cnt = 0;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < m; j ++ )
            if (g[i][j] == 'W' && !st[i][j])
            {
                bfs(i, j);
                cnt ++ ;
            }

    printf("%d\n", cnt);

    return 0;
}
```

#### Acwing1106 山峰和山谷            

**[题目：AcWing1106 山峰和山谷 ]()**

**题目描述**

FGD小朋友特别喜欢爬山，在爬山的时候他就在研究山峰和山谷。

为了能够对旅程有一个安排，他想知道山峰和山谷的数量。

给定一个地图，为FGD想要旅行的区域，地图被分为 *n*×*n*的网格，每个格子 (*i*,*j*) 的高度 *w*(*i*,*j*)是给定的。

若两个格子有公共顶点，那么它们就是相邻的格子，如与 $(i,j)$

 相邻的格子有$(i−1,j−1),(i−1,j),(i−1,j+1),(i,j−1),(i,j+1),(i+1,j−1),(i+1,j),(i+1,j+1)$。

我们定义一个格子的集合 *S*为山峰（山谷）当且仅当：

1、*S*的所有格子都有相同的高度。

 2、*S* 的所有格子都连通。

3、对于 *s*属于 *S*，与 *s* 相邻的 *s*′ 不属于 *S*，都有 $w_s>w_s′$（山峰），或者 $w_s<w_s′$（山谷）。

4、如果周围不存在相邻区域，则同时将其视为山峰和山谷。

你的任务是，对于给定的地图，求出山峰和山谷的数量，如果所有格子都有相同的高度，那么整个地图即是山峰，又是山谷。

**输入格式**

第一行包含一个正整数 *n*，表示地图的大小。

接下来一个 *n*×*n* 的矩阵，表示地图上每个格子的高度 *w*。

**输出格式**

共一行，包含两个整数，表示山峰和山谷的数量。

**数据范围**

$1≤n≤1000$,
 $0≤w≤10^9$

**输入样例：**

```c
5
8 8 8 7 7
7 7 8 8 7
7 7 7 7 7
7 8 8 7 8
7 8 8 8 8
```

**输出样例：**

```c
2 1
```

**题解：**

``` c

```

**代码：**

```c
#include <cstring>
#include <iostream>
#include <algorithm>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 1010, M = N * N;

int n;
int h[N][N];
PII q[M];
bool st[N][N];

void bfs(int sx, int sy, bool& has_higher, bool& has_lower)
{
    int hh = 0, tt = 0;
    q[0] = {sx, sy};
    st[sx][sy] = true;

    while (hh <= tt)
    {
        PII t = q[hh ++ ];

        for (int i = t.x - 1; i <= t.x + 1; i ++ )
            for (int j = t.y - 1; j <= t.y + 1; j ++ )
            {
            	//遍历八个方向 
                if (i == t.x && j == t.y) continue;
                if (i < 0 || i >= n || j < 0 || j >= n) continue; //越界 
                if (h[i][j] != h[t.x][t.y]) // 山脉的边界(不相同的高度)
                {
                	//高 
                    if (h[i][j] > h[t.x][t.y]) has_higher  = true;
                    else has_lower = true; //山谷 
                }
                else if (!st[i][j])  //没有访问过 
                {
                    q[ ++ tt] = {i, j};
                    st[i][j] = true;
                }
            }
    }
}

int main()
{
    scanf("%d", &n);

    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            scanf("%d", &h[i][j]);

    int peak = 0, valley = 0;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            if (!st[i][j])
            {
                bool has_higher = false, has_lower = false;
                bfs(i, j, has_higher, has_lower);
                if (!has_higher) peak ++ ;
                //这里不用加else if 
                if (!has_lower) valley ++ ;
            }

    printf("%d %d\n", peak, valley);

    return 0;
}
```



### 2、

## 四、高级数据结构

### 1、并查集



### 2、树状数组



### 3、线段树

#### (1) pushup

####  3.1 AcWing 1275.最大数    

**[题目：AcWing 1275.最大数   ]()**

**题目描述**

给定一个正整数数列 $a_1,a_2,…,a_n$，每一个数都在 `0∼p−1`之间。

可以对这列数进行两种操作：

1. 添加操作：向序列后添加一个数，序列长度变成 `n+1`；
2. 询问操作：询问这个序列中最后 `L`个数中最大的数是多少。

程序运行的最开始，整数序列为空。

一共要对整数序列进行 `m`次操作。

写一个程序，读入操作的序列，并输出询问操作的答案。

**输入格式**

第一行有两个正整数 `m,p`，意义如题目描述；

接下来 `m`行，每一行表示一个操作。

如果该行的内容是 `Q L`，则表示这个操作是询问序列中最后 `L` 个数的最大数是多少；

如果是 `A t`，则表示向序列后面加一个数，加入的数是`(t+a) mod p`。其中，`t` 是输入的参数，`a`是在这个添加操作之前最后一个询问操作的答案（如果之前没有询问操作，则 `a=0`）。

第一个操作一定是添加操作。对于询问操作，`L>0` 且不超过当前序列的长度。

**输出格式**

对于每一个询问操作，输出一行。该行只有一个数，即序列中最后 `L`个数的最大数。

**数据范围**

$1≤m≤2×10^5$,
$1≤p≤2×10^9$,
$0≤t<p$

**输入样例：**

```
10 100
A 97
Q 1
Q 1
A 17
Q 2
A 63
Q 1
Q 1
Q 3
A 99
```

**输出样例：**

```
97
97
97
60
60
97
```

**样例解释**

最后的序列是 97,14,60,96。

**c++代码实现：**

```
线段树
1.线段树的每个节点都代表一个区间。
2.线段树具有唯一的根结点，代表的区间是整个统计范围，如[1,N]。
3.线段树的每个叶结点都代表一个长度为1的元区间[x,x]。
4.对于每个内部结点[l,r],他的左子结点是[l,mid],右子结点是[mid十1,r],其中mid=(l+r)>>1

线段树Tip
1.线段树是一棵非常漂亮二叉树，(除了最后一层外，是一棵满二叉树)，因此我们采用堆的思想来存整棵树
(1) 编号x的父节点：x/2 , 常书写的代码：x>>1
(2) 编号x的左儿子：2x , 常书写的代码：x<<1
(3) 编号x的右儿子：2x十1，常书写的代码：×<<1|1
2线段的下一层都是把当前层进行平分mid=L l+r>>1」
(1) 左区间为[l，mid]
(2) 右区间为[mid+1,r]
注意，线段树的两个子区间是不允许相交的,这也决定了许多题的分块要进行额外的操作，使之区间不能相交
3.线段树一般开长度为4N的空间
(1) 一个长度为N的区间，最终的叶结点，为N个
(2) 先考虑理想状态下(包含最后一层，整个二叉树都是满二叉树)，N个叶结点的满二叉树有
N+N/2+N/4+.....+2+1=2N-1个结点
(3) 但是线段树的存储方式下，最后一层还会有盈余，最坏情况下，最后一层是倒数第二层（也就是满二叉树的倒数第一层）两倍的点，所以所以保存线段树的数组长度要不小于4N才能保证不会越界

线段树的模版
1,pushup（）:由子结点的信息来计算父结点的信息
2.bui1d（）:将一段区间初始化为线段树
3.modify（）:修改
(1) 单点修改(easy)
(2) 区间修改(hard)：用到pushdown操作，懒标记思想
4.query（）:区间询问(例如：查间[a,b]区间)O(1ogn)最多是4logn的时间，因为最坏有两条链
```

![image-20230315164557036](../../../zky/Coding/Coderwhy/pic/image-20230315164557036.png)

![image-20230315164624686](../../../zky/Coding/Coderwhy/pic/image-20230315164624686.png)

![image-20230315164641441](../../../zky/Coding/Coderwhy/pic/image-20230315164641441.png)

```c
#include <cstdio>
#include <algorithm>
#include <string>
#include <iostream>

#define ac cin.tie(0), cin.sync_with_stdio(0);
#define endl "\n"

using namespace std;

const int N = 2e5+10;

int m,p;

struct Node{
    int l,r;
    int v;  //携带的信息，这里是[l,r]区间的最大值
}tr[N*4];

//pushup操作，由子节点的信息，来计算父节点的信息
void pushup(int u){
    tr[u].v=max(tr[u<<1].v,tr[u<<1|1].v);
}

//build的时候先赋值避免忘记
void build(int u,int l,int r){
    // tr[u]={l,r};
    tr[u].l=l,tr[u].r=r;    //节点u代表区间[l,r]
    if(l==r) return;    //是叶子节点
    int mid=l+r>>1;
    build(u<<1,l,mid),build(u<<1|1,mid+1,r);
}

int query(int u,int l,int r){
    if(tr[u].l>=l && tr[u].r<=r) return tr[u].v;    //查询在区间[l,r]的最大值，包含当前的节点u，则直接回溯返回当前点的值
    int mid=tr[u].l+tr[u].r>>1;
    int v=0;
    // if(l<=mid) v=max(v,query(u<<1,l,r));
    if(l<=mid) v=query(u<<1,l,r);
    if(r>mid) v=max(v,query(u<<1|1,l,r));
    // else v=max(v,query(u<<1|1,l,r));
    return v;
}

void modify(int u,int x,int v){
    if(tr[u].l==x && tr[u].r==x) tr[u].v=v;
    else{
        int mid=tr[u].l+tr[u].r>>1;
        if(x<=mid) modify(u<<1,x,v);
        else modify(u<<1|1,x,v);
        pushup(u);
    }
}

int main(){
    int n=0,last=0;   //last记录题目中所说的上次查询的结果a
    scanf("%d%d",&m,&p);
    build(1,1,m);
    
    int x;
    char op[2];
    while(m--){
        scanf("%s%d",op,&x);
        if(*op=='Q'){
            last=query(1,n-x+1,n);
            printf("%d\n",last);
        }else{
            modify(1,n+1,((long long)last+x)%p);
            n++;
        }
    }
    return 0;
}
```

Q:线段树建树build操作的时候，什么时候需要加pushup，什么时候不加pushup

A：在线段树的建树过程中，通常需要执行pushup操作来更新父节点的信息，以确保它的信息与子节点保持一致。pushup操作的时机取决于当前节点的性质以及子节点的性质，具体情况如下：

1. 对于区间修改操作（如单点修改、区间加、区间赋值等），因为修改操作会改变子节点的值，所以在递归调用build函数时需要先对子节点进行更新，再对父节点进行pushup操作。
2. 对于区间查询操作，因为查询操作只需要使用子节点的信息计算父节点的信息，而不需要修改子节点的信息，所以在递归调用build函数时不需要进行pushup操作。
3. 对于区间合并操作（如区间求和、区间最大值、区间最小值等），由于子节点的信息可以通过简单的合并得到父节点的信息，因此在递归调用build函数时需要先对子节点进行更新，再对父节点进行pushup操作。

总之，需要加pushup的情况是在对子节点进行更新之后，需要确保父节点的信息与子节点保持一致。不需要加pushup的情况是在不需要修改子节点的信息的情况下进行递归调用。

[推荐博客](https://www.cnblogs.com/zheyuanxie/archive/2022/08/09/segment-tree.html)

​        

#### 3.2 AcWing 245. 你能回答这些问题吗      

**[题目：AcWing 245. 你能回答这些问题吗  ]()**

**题目描述**

给定长度为 *N* 的数列 *A*，以及 *M*

 条指令，每条指令可能是以下两种之一：

1. `1 x y`，查询区间 [*x*,*y*]中的最大连续子段和，即$ max_{x≤l≤r≤y}{∑_{i=l}^rA[i]}$。

2. `2 x y`，把 *A*[*x*]改成 *y*

对于每个查询指令，输出一个整数表示答案。

**输入格式**

第一行两个整数 *N*,*M*。

第二行 *N*个整数 *A*[*i*]。

接下来 *M*行每行 3 个整数 *k*,*x*,*y*，*k*=1 表示查询（此时如果 *x*>*y*，请交换 *x*,*y*），*k*=2 表示修改。

**输出格式**

对于每个查询指令输出一个整数表示答案。

每个答案占一行。

**数据范围**

$N≤500000≤M≤100000$,
 $−1000≤A[i]≤1000$,

**输入样例：**

```r
5 3
1 2 -3 4 5
1 2 3
2 2 -1
1 3 2
```

**输出样例：**

```
2
-1
```

**题解：**

``` c
struct Node{
  int l,r;  //区间左右端点
  int sum; //区间和
  int lmax; //最大前缀和
  int rmax; //最大后缀和
  int tmax; //最大连续子段和
  //横跨左右子区间的最大子段和 = 左子区间的最大后缀 + 右子区间的最大前缀
}tr[N*4];

void pushup(Node& u,Node& l,Node& r){
  u.sum=l.sum+r.sum;  //区间和=左区间和+右区间和
  //最大前缀和:左儿子的前缀和（只有左儿子前缀）、左儿子区间和+右儿子的前缀和（覆盖到右儿子）
  u.lmax=max(l.lmax,l.sum+r.lmax);  
  //最大后缀和:右儿子的后缀和（只有右儿子后缀）、左儿子后缀+右儿子的区间和（覆盖到右儿子）
  u.rmax=max(r.rmax,l.rmax+r.sum);  
  //当只有左边或者右边儿子、跨越两个区间左儿子取后缀右儿子取前缀
  u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}
```

**代码：**

```c
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <iostream>

using namespace std;
const int N = 5e5+10;
int w[N];
int n,m;

struct Node{
  int l,r;  //区间左右端点
  int sum; //区间和
  int lmax; //最大前缀和
  int rmax; //最大后缀和
  int tmax; //最大连续子段和
  //横跨左右子区间的最大子段和 = 左子区间的最大后缀 + 右子区间的最大前缀
}tr[N*4];

void pushup(Node& u,Node& l,Node& r){
  u.sum=l.sum+r.sum;  //区间和=左区间和+右区间和
  //最大前缀和:左儿子的前缀和（只有左儿子前缀）、左儿子区间和+右儿子的前缀和（覆盖到右儿子）
  u.lmax=max(l.lmax,l.sum+r.lmax);  
  //最大后缀和:右儿子的后缀和（只有右儿子后缀）、左儿子后缀+右儿子的区间和（覆盖到右儿子）
  u.rmax=max(r.rmax,l.rmax+r.sum);  
  //当只有左边或者右边儿子、跨越两个区间左儿子取后缀右儿子取前缀
  u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u){
  pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r){
  tr[u].l=l,tr[u].r=r;	//	容易忘记写在else里面导致段错误
  //如果是叶子节点
  if(l==r){
    tr[u].sum=w[l];
    tr[u].lmax=w[l];
    tr[u].rmax=w[l];
    tr[u].tmax=w[l];
  }else{
    int mid=l+r>>1;
    build(u<<1,l,mid);
    build(u<<1|1,mid+1,r);
    pushup(u);
  }
}

void modify(int u,int x,int v){
  if(tr[u].l==x && tr[u].r==x){
    tr[u].l=x, tr[u].r=x, tr[u].sum=v, tr[u].lmax=v, tr[u].rmax=v, tr[u].tmax=v;
  }else{
    int mid=tr[u].l + tr[u].r>>1;
    if(x<=mid) modify(u<<1,x,v);
    else modify(u<<1|1,x,v);
    pushup(u);
  }
}

Node query(int u,int l,int r){
  if(tr[u].l>=l && tr[u].r<=r) return tr[u];
  else{
    int mid=tr[u].l+tr[u].r>>1;
    /*
    1、在左区间  r<=mid
    2、在右区间  l>mid
    3、左区间+右区间
    */
    if(r<=mid) return query(u<<1,l,r);
    else if(l>mid) return query(u<<1|1,l,r);
    else{
      Node left=query(u<<1,l,r);
      Node right=query(u<<1|1,l,r);
      Node res;
      pushup(res,left,right);
      return res;
    }
  }
}

int main()
{
  scanf("%d%d",&n,&m);
  //数组下标从1开始
  for(int i=1;i<=n;i++) scanf("%d",&w[i]);
  build(1,1,n);
  
  int k,x,y;
  while(m--){
    scanf("%d%d%d",&k,&x,&y);
    if(k==1){
      if(x>y) swap(x,y);
      printf("%d\n",query(1,x,y).tmax);
    }else modify(1,x,y);
  }
  return 0;
}
```



#### 3.3 AcWing 246. 区间最大公约数   (todo)

**[题目：246. 区间最大公约数 ]()**

**题目描述**

给定一个长度为 *N* 的数列 *A*，以及 *M* 条指令，每条指令可能是以下两种之一：

1、`C l r d`，表示把 $A[l]$,$A[l+1]$,…,$A[r]$都加上 $d$。

2、`Q l r`，表示询问 $A[l]$,$A[l+1]$,…,$A[r]$的最大公约数(GCD）

对于每个询问，输出一个整数表示答案。

**输入格式**

第一行两个整数 *N*,*M*。

第二行 *N*个整数 *A*[*i*]。

接下来 *M*行表示 *M* 条指令，每条指令的格式如题目描述所示。

**输出格式**

对于每个询问，输出一个整数表示答案。

每个答案占一行。

**数据范围**

$N≤500000,M≤100000$,
$1≤A[i]≤10^{18}$,
 $|d|≤10^{18}$

**输入样例：**

```r
5 5
1 3 5 7 9
Q 1 5
C 1 5 1
Q 1 5
C 3 3 6
Q 2 4
```

**输出样例：**

```
1
2
4
```

**题解：**

``` c
怎么将求解一个区间的操作转化为只对某一个点
最大公约数左边等于右边：
(x,y,z)= (x,y-x,z-y)    
(a1, a2, .....an) <= (a, a2-a1, a3-a2, ....an-an-1)
(a1, a2, .....an) >= (a, a2-a1, a3-a2, ....an-an-1)
(a1, a2, .....an) = (a, a2-a1, a3-a2, ....an-an-1) = d  
    
求[l,r]的最大公约数：
gcd(a[l], gcd{b[l+1]~b[r]})
    
用差分来存sum和gcd
```

**代码：**

```c
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 500010;

int n, m;
LL w[N];
struct Node
{
    int l, r;
    LL sum, d;
}tr[N * 4];

LL gcd(LL a, LL b)
{
    return b ? gcd(b, a % b) : a;
}

void pushup(Node &u, Node &l, Node &r)
{
    u.sum = l.sum + r.sum;
    u.d = gcd(l.d, r.d);
}

void pushup(int u)
{
    pushup(tr[u], tr[u << 1], tr[u << 1 | 1]);
}

void build(int u, int l, int r)
{
    if (l == r)
    {
        LL b = w[r] - w[r - 1];
        tr[u] = {l, r, b, b};
    }
    else
    {
        tr[u].l = l, tr[u].r = r;
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
}

void modify(int u, int x, LL v)
{
    if (tr[u].l == x && tr[u].r == x)
    {
        LL b = tr[u].sum + v;
        tr[u] = {x, x, b, b};
    }
    else
    {
        int mid = tr[u].l + tr[u].r >> 1;
        if (x <= mid) modify(u << 1, x, v);
        else modify(u << 1 | 1, x, v);
        pushup(u);
    }
}

Node query(int u, int l, int r)
{
    if (tr[u].l >= l && tr[u].r <= r) return tr[u];
    else
    {
        int mid = tr[u].l + tr[u].r >> 1;
        if (r <= mid) return query(u << 1, l, r);
        else if (l > mid) return query(u << 1 | 1, l, r);
        else
        {
            auto left = query(u << 1, l, r);
            auto right = query(u << 1 | 1, l, r);
            Node res;
            pushup(res, left, right);
            return res;
        }
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) scanf("%lld", &w[i]);
    build(1, 1, n);

    int l, r;
    LL d;
    char op[2];
    while (m -- )
    {
        scanf("%s%d%d", op, &l, &r);
        if (*op == 'Q')
        {
            auto left = query(1, 1, l);
            Node right({0, 0, 0, 0});
            if (l + 1 <= r) right = query(1, l + 1, r);
            printf("%lld\n", abs(gcd(left.sum, right.d)));
        }
        else
        {
            scanf("%lld", &d);
            modify(1, l, d);
            if (r + 1 <= n) modify(1, r + 1, -d);
        }
    }

    return 0;
}
```



#### (2) 赖标记、pushdown

单点修改一般pushup操作就够了

区间修改则需要懒标记-pushdown，思想来源于区间查询

```c
1、修改操作
信息：
    （1）sum:当前区间的总和
    （2）add懒标记，给以当前节点为根的子树中的每个节点，加上add(不包含根节点)
        当前的操作到该根节点之后就不在传播了，直接返回
        
2、查询操作
     查询某一段区间的时候，如果用到的某一个值被add懒标记过了，则需要找到该子节点的父节点，一开始加add懒标记的节点，再将祖宗的root所有的add操作累加到所求点位置，那么可以找到祖宗root节点，每次递归左右儿子加add懒标记，每次懒标记之后清空当前的add懒标记，一直pushdown向下。
     假设祖宗节点root被add懒标记了，root.add
     pushdown操作：
     left.add += root.add;
	 left.sum +=(left.R-left.R+1)*root.add	//	左儿子总和=左边节点个数*add
     right.add += root.add;
     right.sum +=(right.R-right.R+1)*root.add	//	左儿子总和=左边节点个数*add
     root.add = 0  //清空懒标记
```

[推荐](https://leetcode.cn/problems/my-calendar-i/solution/by-ac_oier-hnjl/?orderBy=hot)

#### 3.4  Acwing243. 一个简单的整数问题2             

**[题目：243. 一个简单的整数问题2 ]()**

**题目描述**

给定一个长度为 $N$ 的数列 $A$，以及 $M$条指令，每条指令可能是以下两种之一：

1. `C l r d`，表示把 $A[l]$,$A[l+1]$,…,$A[r]$都加上 $d$。

​    2.`Q l r`，表示询问数列中第 `l∼r`个数的和。

对于每个询问，输出一个整数表示答案。

**输入格式**

第一行两个整数 *N*,*M*。

第二行 *N*个整数 *A*[*i*]。

接下来 *M*行表示 *M* 条指令，每条指令的格式如题目描述所示。

**输出格式**

对于每个询问，输出一个整数表示答案。

每个答案占一行。

**数据范围**

$1≤N,M≤10^5$,
 $|d|≤10000$,
 $|A[i]|≤10^9$,

**输入样例：**

```r
10 5
1 2 3 4 5 6 7 8 9 10
Q 4 4
Q 1 10
Q 2 4
C 3 6 3
Q 2 4
```

**输出样例：**

```
4
55
9
15
```

**题解：**

``` c
维护:
    sum : 如果只考虑当前节点及子节点上的所有标记，当前区间和是多少（没有考虑所有祖先节点上的标记，只考虑当前点及儿子）
    add : 给当前区间的所有儿子加上add
```

**代码：**

```c
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <iostream>
typedef long long LL;
using namespace std;
const int N = 1e5+5;
int w[N];
int n,m;

struct Node{
  int l,r;  //左右区间
  LL sum,add;  //区间里面的总和，以及懒标记
}tr[N*4];

void pushup(int u){
  tr[u].sum = tr[u<<1].sum + tr[u<<1|1].sum;
}

void pushdown(int u){
  auto& root=tr[u],&left=tr[u<<1],&right=tr[u<<1|1];
  //如果存在懒标记
  if(root.add){
    left.add+=root.add, left.sum+=(LL)(left.r-left.l+1)*root.add;
    right.add+=root.add,right.sum+=(LL)(right.r-right.l+1)*root.add;
    //将懒标记清除
    root.add=0;
  }
}

void build(int u,int l,int r){
  if(l==r){
    //懒标记刚build的时候0
    tr[u]={l,r,w[r],0};
  }else{
    tr[u]={l,r}; //不加会段错误
    int mid = l+r>>1;
    build(u<<1,l,mid),build(u<<1|1,mid+1,r);
    pushup(u);
  }
}

void modify(int u,int l,int r,int d)
{
  //包含区间
  if(tr[u].l>=l && tr[u].r<=r){
    tr[u].sum+=(LL)(tr[u].r-tr[u].l+1)*d;
    tr[u].add+=d;
  }else{  //需要分裂，可能存在两边的add数值不一致
    pushdown(u);
    int mid=tr[u].l+tr[u].r>>1;
    if(l<=mid) modify(u<<1,l,r,d);
    if(r>mid) modify(u<<1|1,l,r,d);
    pushup(u);
  }
}

LL query(int u,int l,int r){
  if(tr[u].l>=l && tr[u].r<=r) return tr[u].sum;
  
  pushdown(u);
  int mid=tr[u].l+tr[u].r>>1;
  LL sum=0;
  if(l<=mid) sum=query(u<<1,l,r);
  if(r>mid) sum+=query(u<<1|1,l,r);
  return sum;
}

int main()
{
  scanf("%d%d",&n,&m);
  for(int i=1;i<=n;i++) scanf("%d",&w[i]);
  build(1,1,n);
  
  char op[2];
  int l,r,d;
  
  while(m--){
    scanf("%s%d%d",op,&l,&r);
    if(*op=='C'){
      scanf("%d",&d);
      modify(1,l,r,d);
    }else printf("%lld\n",query(1,l,r));
  }
  
  return 0;
}
```



#### 3.5 AcWing 1277. 维护序列                

**[题目：AcWing 1277. 维护序列 ]()**

**题目描述**

老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。

有长为 $N$的数列，不妨设为 $a1,a2,…,a_N$。

有如下三种操作形式：

1. 把数列中的一段数全部乘一个值；
2. 把数列中的一段数全部加一个值；
3. 询问数列中的一段数的和，由于答案可能很大，你只需输出这个数模 $P$的值。

**输入格式**

第一行两个整数 $N$和 $P$；

第二行含有 $N$个非负整数，从左到右依次为 $a1,a2,…,a_N$；

第三行有一个整数 $M$，表示操作总数；

从第四行开始每行描述一个操作，输入的操作有以下三种形式：

- 操作 1：`1 t g c`，表示把所有满足 $t≤i≤g$ 的 $a_i$ 改为 $a_i×c$；
- 操作 2：`2 t g c`，表示把所有满足 $t≤i≤g$ 的 $a_i$ 改为 $a_i$+c；
- 操作 3：`3 t g`，询问所有满足 $t≤i≤g$ 的 $a_i$ 的和模 $P$ 的值。

同一行相邻两数之间用一个空格隔开，每行开头和末尾没有多余空格。

**输出格式**

对每个操作 3，按照它在输入中出现的顺序，依次输出一行一个整数表示询问结果。

**数据范围**

$1≤N,M≤10^5$,
$ 1≤t≤g≤N$,
 $0≤c,a_i≤10^9$,
 $1≤P≤10^9$,

**输入样例：**

```r
7 43
1 2 3 4 5 6 7
5
1 2 5 5
3 2 4
2 3 7 9
3 1 3
3 4 7
```

**输出样例：**

```
2
35
8
```

**样例解释**

初始时数列为 `{1,2,3,4,5,6,7}`；

经过第 1 次操作后，数列为 `{1,10,15,20,25,6,7}`；

对第 2次操作，和为 `10+15+20=45`，模 43 的结果是 2；

经过第 3次操作后，数列为` {1,10,24,29,34,15,16}`；

对第 4次操作，和为` 1+10+24=35`，模 43 的结果是 35；

对第 5次操作，和为` 29+34+15+16=94`，模 43 的结果是 8。

**题解：**

``` c
1、线段树需要记录的信息：
	L，R
	sum,add,mul
	注意：
    	（1）add表示在区间加一个数，mul表示在区间里面乘一个数
    	（2）考虑先加还是先乘法，应该先乘法后加法(能保证操作前后形式统一)，x表示区间里面每个数
    		①加法的时候(将add + add`记为新的add)：
    				(x * mul + add )+ add` = x * mul + add
    			
    		②乘法的时候(将mul * mul`记为新的mul，同时将add * mul`记为新的add)：
    				(x * mul + add )*mul` = x * mul * mul` + add * mul` = x * mul + add
    
2、优化
    x * c + d
    (1)乘c ,等价与 d=0 , x * c + d = x * c
    (2)加d ,等价与 c=1 , x * 1 + d = x + d
综上：
    记ac为新的mul,bc+d为新的add
    (x * a + b) * c + d = x * ac + bc + d = x * mul + add
```

**代码：**

```c
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>

typedef long long ll;
using namespace std;
const int N = 1e5+10;

int n,m,p;
int w[N];

struct Node{
  int l,r;
  int sum,add,mul;
}tr[N*4];

//pushup操作
void pushup(int u)
{
  tr[u].sum = (tr[u<<1].sum + tr[u<<1|1].sum)%p;
}

void eval(Node& u,int add,int mul)
{
  //先乘法后加法，加的是整个区间的=个数*add
  u.sum = ((ll)u.sum*mul + (ll)(u.r-u.l+1)*add)%p;
  //乘法,直接mul
  u.mul = (ll)u.mul*mul % p;
  //加法,加法前需要先mul操作
  u.add = ((ll)u.add*mul + add)%p;
}

//pushdown操作
void pushdown(int u)
{
  eval(tr[u<<1],tr[u].add,tr[u].mul);
  eval(tr[u<<1|1],tr[u].add,tr[u].mul);
  //清空操作
  tr[u].add = 0,tr[u].mul = 1;
}

void build(int u,int l,int r)
{
  if(l==r) tr[u]={l,r,w[l],0,1};
  else{
    //初始sum为0
    tr[u]={l,r,0,0,1};
    int mid=l+r>>1;
    build(u<<1,l,mid),build(u<<1|1,mid+1,r);
    pushup(u);
  }
}

void modify(int u,int l,int r,int add,int mul)
{
  if(tr[u].l>=l && tr[u].r<=r) eval(tr[u],add,mul);
  else{
    pushdown(u);
    int mid = tr[u].l+tr[u].r>>1;
    if(l<=mid) modify(u<<1,l,r,add,mul);
    if(r>mid) modify(u<<1|1,l,r,add,mul);
    pushup(u);
  }
}

int query(int u,int l,int r)
{
  if(tr[u].l>=l && tr[u].r<=r) return tr[u].sum;
  pushdown(u);
  int mid=tr[u].l+tr[u].r>>1;
  int res=0;
  if(l<=mid) res=query(u<<1,l,r);
  if(r>mid) res=(res+query(u<<1|1,l,r))%p;
  return res;
}

int main(){
  scanf("%d%d",&n,&p);
  for(int i=1;i<=n;i++) scanf("%d",&w[i]);
  build(1,1,n);
  
  scanf("%d", &m);
  while (m -- )
  {
    int t, l, r, d;
    scanf("%d%d%d", &t, &l, &r);
    if (t == 1)
    {
      scanf("%d", &d);
      modify(1, l, r, 0, d);
    }
    else if (t == 2)
    {
      scanf("%d", &d);
      modify(1, l, r, d, 1);
    }
    else printf("%d\n", query(1, l, r));
  }
  return 0;
}
```



#### （3）扫描线

#### 3.6 AcWing 247. 亚特兰蒂斯  （todo）          

**[题目：AcWing 247. 亚特兰蒂斯 ]()**

**题目描述**

有几个古希腊书籍中包含了对传说中的亚特兰蒂斯岛的描述。 

其中一些甚至包括岛屿部分地图。 

但不幸的是，这些地图描述了亚特兰蒂斯的不同区域。 

您的朋友 Bill 必须知道地图的总面积。 

你自告奋勇写了一个计算这个总面积的程序。

**输入格式**

输入包含多组测试用例。

对于每组测试用例，第一行包含整数 $n$，表示总的地图数量。

接下来 $n$ 行，描绘了每张地图，每行包含四个数字 $x1,y1,x2,y2$（不一定是整数），$(x1,y1)$ 和 $(x2,y2)$分别是地图的左上角位置和右下角位置。

注意，坐标轴 $x$轴从上向下延伸，$y$轴从左向右延伸。

当输入用例 $n$=0时，表示输入终止，该用例无需处理。

**输出格式**

每组测试用例输出两行。

第一行输出 `Test case #k`，其中 $k$是测试用例的编号，从 1开始。

第二行输出 `Total explored area: a`，其中 *a*是总地图面积（即此测试用例中所有矩形的面积并，注意如果一片区域被多个地图包含，则在计算总面积时只计算一次），精确到小数点后两位数。

在每个测试用例后输出一个空行。

**数据范围**

$1≤n≤10000$,
 $0≤x1<x2≤100000$,
 $0≤y1<y2≤100000$
 注意，本题 $n$ 的范围上限加强至 10000。

**输入样例：**

```r
2
10 10 20 20
15 15 25 25.5
0
```

**输出样例：**

```
Test case #1
Total explored area: 180.00 
```

**样例解释**

样例所示地图覆盖区域如下图所示，两个矩形区域所覆盖的总面积，即为样例的解。

![](https://cdn.acwing.com/media/article/image/2019/12/26/19_4acba44c27-%E6%97%A0%E6%A0%87%E9%A2%98.png)**题解：**

``` c
操作1：
    将某一个区间[L,R]加一个k(K的取值是取决于y轴坐标，如果是左边取+1，右边取-1)
    
操作2：
    求整个区间中长度大于0的区间总长度是多少？
    
线段树中的节点信息：
	（1）cnt：当前区间整个被覆盖的次数是多少
	（2）len：不考虑所有的祖先节点cnt的前提下，cnt>0的区间总长
注意：线段树的节点，永远只向下看
    
    
扫描线：
（1）永远只考虑根节点的信息----查询query时候不需要调用pushdown
（2）所有的操作均是成对出现，且先加后减----modify的时候不需要pushdown
    对于减法，减完之后>0不影响正确性，=0也是不影响准确性
    对于加法，
    ①cnt > 0,如果被矩形覆盖了，就会被计算，无需向下分裂
    ②cnt = 0,pushdown是与否都一样
    
总的就是，修改的时候不用pushdown，不完全标记，如果完全包含区间的话，就在上面加上权值，往下面递归
   pushup注意当前的cnt==0，值是两个儿子的总和 ，如果不是0就是区间长度
```

**[代码](https://www.acwing.com/activity/content/code/content/167934/)**



## 六、基础算法

### 1、位运算、递推与递归

### 2、前缀和、差分、二分

### 3、排序、RMQ	

#### (1) 排序

#### (2) RMQ

$0------------i----------i+2^j-1--------------------n$
		                                          $f[i][j]$                                    $f[i+2^j-1]$

$f[i][j]$：表示从 $i$ 开始长度是 $2^j$ 的区间中,也就是区间 $[i,i+2^j-1]$ 的最大值是多少,也就是从 $i$ 开始的  $2^j$  个数的最大值
该区间一共有 $2^j$ 个数，如果均分为两个部分，则每个部分就是 $2^{j-1}$ 个数，则区间 $ [i,i+2^j-1]$ 变成区间  $[i+2^{j-1}-1]$ 和 $[i+2^{j-1},i+2^j-1]$

i 到 $i+2^j-1$ 中的最大值，可以分为  $f[i][2^{j-1}]+f[i+2^{j-1}][j-1]$
$f[i][j]=max(f[i][j-1],f[i+2^{j-1}][j-1])$

$----L-----------R------$
设 L 到 R 的长度是 len，找到 $2^k<=len <= 2*2^k=2^{k+1}$,也就是找到小于 len 区间长度的 2 的幂次的最大值 k
则L开始的 $2^k$ 个数  和  以 R 为结尾的 $2^k$ 个数 这两段区间一定覆盖整个区间 $[L,R]$ ,这两段最大值分别是$f[L][k]$ 和 $f[R-2^k+1][k]$
两者最大值就是整个区间的最大值，因为求的是最大值，所以就算是有重叠也没有关系
k可以先预处理好 $logk/log2$

缺点：不能修改，是静态的，线段树可以支持动态修改

#### AcWing 1273. 天才的记忆                 

**[题目：AcWing 1273. 天才的记忆 ]()**

**题目描述**

从前有个人名叫 WNB，他有着天才般的记忆力，他珍藏了许多许多的宝藏。

在他离世之后留给后人一个难题（专门考验记忆力的啊！），如果谁能轻松回答出这个问题，便可以继承他的宝藏。

题目是这样的：给你一大串数字（编号为 1到 *N*，大小可不一定哦！），在你看过一遍之后，它便消失在你面前，随后问题就出现了，给你 *M* 个询问，每次询问就给你两个数字 *A*,*B*，要求你瞬间就说出属于 *A* 到 *B*这段区间内的最大数。

一天，一位美丽的姐姐从天上飞过，看到这个问题，感到很有意思（主要是据说那个宝藏里面藏着一种美容水，喝了可以让这美丽的姐姐更加迷人），于是她就竭尽全力想解决这个问题。

但是，她每次都以失败告终，因为这数字的个数是在太多了！

于是她请天才的你帮他解决。如果你帮她解决了这个问题，可是会得到很多甜头的哦！

**输入格式**

第一行一个整数 *N*表示数字的个数。

接下来一行为 *N* 个数，表示数字序列。

第三行读入一个 *M*，表示你看完那串数后需要被提问的次数。

接下来 *M*行，每行都有两个整数 *A*,*B*。

**输出格式**

输出共 *M* 行，每行输出一个数，表示对一个问题的回答。

**数据范围**

$1≤N≤2×10^5$,
 $1≤M≤10^4$,
$ 1≤A≤B≤N$,

**输入样例：**

```r
6
34 1 8 123 3 2
4
1 2
1 5
3 4
2 3
```

**输出样例：**

```
34
123
123
8
```

**解答：**

```
0------------i----------i+2^j-1----------n
		 f[i][j]          f[i+2^j-1]

f[i][j]：表示从i开始长度是2^j的区间中,也就是区间[i,i+2^j-1]的最大值是多少,也就是从i开始的2^j个数的最大值
该区间一共有2^j个数，如果均分为两个部分，则每个部分就是2^{j-1}个数，则区间[i,i+2^j-1]变成区间[i+2^{j-1}-1]和[i+2^{j-1},i+2^j-1]

i到i+2^j-1中的最大值，可以分为f[i][2^{j-1}]+f[i+2^{j-1}][j-1]
f[i][j]=max(f[i][j-1],f[i+2^{j-1}][j-1])

----L-----------R------
设L到R的长度是len，找到2^k<=len <= 2*2^k=2^{k+1},也就是找到小于len区间长度的2的幂次的最大值k
则L开始的2^k个数  和  以R为结尾的2^k个数 这两段区间一定覆盖整个区间[L,R],这两段最大值分别是f[L][k]和f[R-2^k+1][k]
两者最大值就是整个区间的最大值，因为求的是最大值，所以就算是有重叠也没有关系
k可以先预处理好logk/log2

缺点：不能修改，是静态的，线段树可以支持动态修改
```

**代码：**

``` c
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <cmath>

using namespace std;
//j=log2(2*1e5)    65536=2^16   2^17>>int的值了 
const int N = 2e5+10,M =18;

int n,m;
int w[N];
int f[N][M];

void init()
{
	for(int j=0;j<M;j++){
		//右边不能超过终点,2^j-1的长度 
//		for(int i=1;i<=n-(1<<j)+1;j++){
		for(int i=1;i+(1<<j)-1<=n;i++){
			//表示只有一个数，f[i][0]就是[i,i]区间里面最大值
			if(!j) f[i][j]=w[i];
			//两个区间里面的最大值 
			else f[i][j]=max(f[i][j-1],f[i+(1<<(j-1))][j-1]);	 
		}
	}
} 

int query(int l,int r){
	int len=r-l+1; //长度
	int k=log(len)/log(2);
    //L开始的2^k个数  和  以R为结尾的2^k个数 这两段区间一定覆盖整个区间[L,R],这两段最大值分别是f[L][k]和f[R-2^k+1][k]
	return max(f[l][k],f[r-(1<<k)+1][k]); 
} 

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&w[i]);
	//初始化st表 
	init();
	
	scanf("%d",&m);
	while(m--){
		int l,r;
		scanf("%d%d",&l,&r);
		printf("%d\n",query(l,r));
	}	
	return 0;
} 
```







#### 1.2 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```

#### 

#### 1.2 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```

#### 



