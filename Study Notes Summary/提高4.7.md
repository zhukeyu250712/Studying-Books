## 一、DP

### 1.数字三角形模型

#### 1.1  摘花生

**[题目：AcWing1015. 摘花生](https://www.acwing.com/activity/content/problem/content/1256/)**

**题目描述**

Hello Kitty想摘点花生送给她喜欢的米老鼠。

她来到一片有网格状道路的矩形花生地(如下图)，从西北角进去，东南角出来。

地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。

Hello Kitty只能向东或向南走，不能向西或向北走。

问Hello Kitty最多能够摘到多少颗花生。

![](https://cdn.acwing.com/media/article/image/2019/09/12/19_a8509f26d5-1.gif)

**输入格式**

第一行是一个整数T，代表一共有多少组数据。

接下来是T组数据。

每组数据的第一行是两个整数，分别代表花生苗的行数R和列数 C。

每组数据的接下来R行数据，从北向南依次描述每行花生苗的情况。每行数据有C个整数，按从西向东的顺序描述了该行每株花生苗上的花生数目M。

**输出格式**

对每组输入数据，输出一行，内容为Hello Kitty能摘到得最多的花生颗数。

**数据范围**

$1≤T≤100$,
$1≤R,C≤100$,
$0≤M≤1000$

**输入样例：**

```c
2
2 2
1 1
3 4
2 3
2 3 4
1 6 5
```

**输出样例：**

```c
8
16
```

**题解：**

``` c
DP  1.状态(一个集合)表示
		二维：f(i,j)
		1.1 集合：所有选法
				条件：（1）所有从(1,1)走到(i,j)的所有路线
					 （2）所有路线的最大值max
    
		1.2 属性：max值
    
	2.状态计算:一步一步的将状态计算出来
		(1)总结：
        	1)集合的划分原则：
        		a.重复(不一定需要必须满足)
        		b.不遗漏(必须满足)
        	2)很重要的划分依据"最后",大部分题目依据最后一步来划分
        
		(2)f(i,j)集合划分为若干个更小的子集，每个子集都能求出答案
            1)最后一步是从上面下来的
        		(1,1)-->(i-1,j)-->(i,j)
        		f[i-1][j]+w[i][j]
            2)最后一步是从左边下来的
        		(1,1)-->(i,j-1)-->(i,j)
        		f[i][j-1]+w[i][j]
		  
		最终f[i][j]=max(f[i-1][j]+w[i][j],f[i][j-1]+w[i][j])
    3.优化
    4.注意       
```

**代码：**

```c
#include <bits/stdc++.h>
using namespace std;
const int N = 110;
int w[N][N];
int f[N][N];

int main()
{
  int T;
  scanf("%d",&T);
  while(T--){
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
      for(int j=1;j<=m;j++){
        scanf("%d",&w[i][j]);
      }
    }
    for(int i=1;i<=n;i++){
      for(int j=1;j<=m;j++){
        f[i][j]=max(f[i-1][j],f[i][j-1])+w[i][j];
      }
    }
    printf("%d\n",f[n][m]);
  }
  return 0;
}
```

#### 1.2 最低通行费

**[题目：AcWing1018. 最低通行费](https://www.acwing.com/problem/content/1020/)**

**题目描述**

一个商人穿过一个 N×N 的正方形的网格，去参加一个非常重要的商务活动。

他要从网格的左上角进，右下角出。

每穿越中间 1个小方格，都要花费 1个单位时间。

商人必须在 (2N−1)个单位时间穿越出去。

而在经过中间的每个小方格时，都需要缴纳一定的费用。

这个商人期望在规定时间内用最少费用穿越出去。

请问至少需要多少费用？

注意：不能对角穿越各个小方格（即，只能向上下左右四个方向移动且不能离开网格）。

**输入格式**

第一行是一个整数，表示正方形的宽度 N。

后面 N 行，每行 N 个不大于 100 的正整数，为网格上每个小方格的费用。

**输出格式**

输出一个整数，表示至少需要的费用。

**数据范围**

1≤N≤100

**输入样例：**

```c
5
1  4  6  8  10
2  5  7  15 17
6  8  9  18 20
10 11 12 19 21
20 23 25 29 33
```

**输出样例：**

```c
109
```

**样例解释:**

样例中，最小值为 109=1+2+5+7+9+12+19+21+33。

**题解：**

``` c
DP  1.状态(一个集合)表示
		二维：f(i,j)
		1.1 集合：所有选法
				条件：（1）所有从(1,1)走到(i,j)的所有路线
    				 （2）2n-1步等价于不能走回头路
					 （3）所有路线的最小值Min
    
		1.2 属性：max值
    
	2.状态计算:一步一步的将状态计算出来
		(1)总结：
        	1)集合的划分原则：
        		a.重复(不一定需要必须满足)
        		b.不遗漏(必须满足)
        	2)很重要的划分依据"最后",大部分题目依据最后一步来划分
        
		(2)f(i,j)集合划分为若干个更小的子集，每个子集都能求出答案
            1)最后一步是从上面下来的
        		(1,1)-->(i-1,j)-->(i,j)
        		f[i-1][j]+w[i][j]
            2)最后一步是从左边下来的
        		(1,1)-->(i,j-1)-->(i,j)
        		f[i][j-1]+w[i][j]
		  
		最终f[i][j]=min(f[i][j],f[i-1][j]+w[i][j],f[i][j-1]+w[i][j])
    3.优化
    4.注意       
```

**代码：求最小值需要考虑边界问题**

```c
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 110,INF = 1e9;

int n;
int w[N][N];
int f[N][N];

int main() {
  scanf("%d",&n);
  for(int i = 1; i <= n; i++) {
    for(int j = 1; j <= n; j++){
      scanf("%d",&w[i][j]);
    }
  }

  for(int i = 1; i <= n; i++) {
    for(int j = 1; j <= n; j++) {
      //特判下第一行和第一列
      if(i==1 && j==1) f[i][j] = w[i][j];  //特判左上角
      else {
        f[i][j] = INF;
        //只有不在第一行的时候，才可以从上面过来
        if(i>1) f[i][j] = min(f[i][j],f[i-1][j] + w[i][j]); 
        //只有不在第一列的时候，才可以从左边过来
        if(j>1) f[i][j] = min(f[i][j],f[i][j-1] + w[i][j]);
      }
    }
  }
  printf("%d\n",f[n][n]);
  return 0;
}
```



#### 1.3  方格取数

**[题目：AcWing.1027方格取数](https://www.acwing.com/problem/content/1029/)**

**题目描述**

设有 N×N 的方格图，我们在其中的某些方格中填入正整数，而其它的方格中则放入数字0。如下图所示：

![](https://cdn.acwing.com/media/article/image/2019/09/12/19_764ece6ed5-2.gif)

某人从图中的左上角 A 出发，可以向下行走，也可以向右行走，直到到达右下角的 B 点。

在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。

此人从 A 点到 B 点共走了两次，试找出两条这样的路径，使得取得的数字和为最大。

**输入格式**

第一行为一个整数N，表示 N×N 的方格图。

接下来的每行有三个整数，第一个为行号数，第二个为列号数，第三个为在该行、该列上所放的数。

行和列编号从 1 开始。

一行“0 0 0”表示结束。

**输出格式**

输出一个整数，表示两条路径上取得的最大的和。

**数据范围**

$N≤10$

**输入样例：**

```c
8
2 3 13
2 6 6
3 5 7
4 4 14
5 2 21
5 6 4
6 3 15
7 2 14
0 0 0
```

**输出样例：**

```c
67
```

**题解：**

``` c
如何处理同一个格子不能被重复选择？
    只有在ii+j1 == i2+j2时候，两条路径才可能重合
    
DP  1.状态(一个集合)表示
		四维：f(i1,j1,i2,j2)
    		 只有在ii+j1 == i2+j2时候，两条路径才可能重合
    		 f(k,i1,i2)表示所有从(1,1),(1,1)分别走到(i1,k-i1),(i2,k-i2)的路径的最大值
    		 k = i1+j1 = i2+j2
    
		1.1 集合：所有选法
				条件：（1）从(1,1),(1,1)分别走到(i1,k-i1),(i2,k-i2)的路径的最大值
					 （2）路线的最大值max
    
		1.2 属性：max值
    
	2.状态计算:一步一步的将状态计算出来
		(1)总结：
        	1)集合的划分原则：
        		a.重复(不一定需要必须满足)
        		b.不遗漏(必须满足)
        	2)很重要的划分依据"最后",大部分题目依据最后一步来划分
        
		(2)f(k,i1,i2)集合划分为若干个更小的子集，每个子集都能求出答案
            1)第一条路线向下走，第二条路线向下走
        		第一条路线:(1,1)->(i1-1,j1)->(i1,j1)
        		第二条路线:(1,1)->(i2-1,j2)->(i2,j2)
                ①前部部分的状态;f(k-1,i1-1,i2-1)
                ②后面部分判断(i1,j1)和(i2,j2)是否重合
                    重合则加 w(i1,j1)
                    不重合加 w(i1,j1)+w(i2,j2)
 
            2)第一条路线向下走，第二条路线向右走
        
        	3)第一条路线向右走，第二条路线向下走
        
        	4)第一条路线向右走，第二条路线向右走
        		
		最终4种情况取最大值
    3.优化
    4.注意       
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 15;

int n;
int w[N][N];
int f[N*2][N][N];

int main() {
  scanf("%d",&n);

  int a,b,c;
  while(cin>>a>>b>>c, a || b || c) w[a][b] = c;

  for(int k  =2; k <=n+n; k++) {
    for(int i1 = 1; i1 <= n; i1++){
      for(int i2 = 1; i2 <= n; i2++) {
        int j1 = k - i1, j2 = k - i2;
        if(j1 >=1 && j1 <=n && j2>=1 && j2<=n) {
          int t = w[i1][j1];
          if(i1!=i2 && j1!=j2) t+=w[i2][j2];
          // f[k][i1][i2] = max(f[k][i1][i2],f[k-1][i1-1][i2-1]+t);
          int &x = f[k][i1][i2];
          x = max(x,f[k-1][i1-1][i2-1] + t);
          x = max(x,f[k-1][i1-1][i2] + t);
          x = max(x,f[k-1][i1][i2-1] + t);
          x = max(x,f[k-1][i1][i2] + t);
        }
      }
    }
  }
  printf("%d",f[n*2][n][n]);
  return 0;
}
```



#### 1.4 传纸条(todo)

[Acwing275. 传纸条](https://www.acwing.com/problem/content/277/)

**题目描述**

小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。

一次素质拓展活动中，班上同学安排坐成一个 m 行 n 列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。

幸运的是，他们可以通过传纸条来进行交流。

纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标 (1,1)，小轩坐在矩阵的右下角，坐标 (m,n)。

从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。 

在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。

班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙，反之亦然。 

还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用 00 表示），可以用一个 0∼100 的自然数来表示，数越大表示越好心。

小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度之和最大。

现在，请你帮助小渊和小轩找到这样的两条路径。

**输入格式**

第一行有 2 个用空格隔开的整数 m 和 n，表示学生矩阵有 m 行 n 列。

接下来的 m 行是一个 m×n 的矩阵，矩阵中第 i 行 j 列的整数表示坐在第 i 行 j 列的学生的好心程度，每行的 n 个整数之间用空格隔开。

**输出格式**

输出一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。

**数据范围**

$1≤n,m≤50$

**输入样例：**

```c
3 3
0 3 9
2 8 5
5 7 0
```

**输出样例：**

```c
34
```

**题解：**

``` c

```

**代码：**

```c

```



### 2、最长上升子序列模型(LIS)

**[题目：AcWing 1017. 怪盗基德的滑翔翼  ](https://www.acwing.com/activity/content/problem/content/1259/)**

#### 2.1 怪盗基德的滑翔翼

**题目描述**

怪盗基德是一个充满传奇色彩的怪盗，专门以珠宝为目标的超级盗窃犯。

而他最为突出的地方，就是他每次都能逃脱中村警部的重重围堵，而这也很大程度上是多亏了他随身携带的便于操作的滑翔翼。

有一天，怪盗基德像往常一样偷走了一颗珍贵的钻石，不料却被柯南小朋友识破了伪装，而他的滑翔翼的动力装置也被柯南踢出的足球破坏了。

不得已，怪盗基德只能操作受损的滑翔翼逃脱。

假设城市中一共有N幢建筑排成一条线，每幢建筑的高度各不相同。

初始时，怪盗基德可以在任何一幢建筑的顶端。

他可以选择一个方向逃跑，但是不能中途改变方向（因为中森警部会在后面追击）。

因为滑翔翼动力装置受损，他只能往下滑行（即：只能从较高的建筑滑翔到较低的建筑）。

他希望尽可能多地经过不同建筑的顶部，这样可以减缓下降时的冲击力，减少受伤的可能性。

请问，他最多可以经过多少幢不同建筑的顶部(包含初始时的建筑)？

**输入格式**

输入数据第一行是一个整数K，代表有K组测试数据。

每组测试数据包含两行：第一行是一个整数N，代表有N幢建筑。第二行包含N个不同的整数，每一个对应一幢建筑的高度h，按照建筑的排列顺序给出。

**输出格式**

对于每一组测试数据，输出一行，包含一个整数，代表怪盗基德最多可以经过的建筑数量。

**数据范围**

$1≤K≤100,$
$1≤N≤100$,
$0<h<10000$

**输入样例：**

```c
3
8
300 207 155 299 298 170 158 65
8
65 158 170 298 299 155 207 300
10
2 1 3 4 5 6 7 8 9 10
```

**输出样例：**

```c
6
6
9
```

**题解：**

``` c
当确定方向和起点之后，最长的距离是多少？
    起点:a[i]
    最长距离：以a[i]记为的最长上升子序列
    步骤：选择向左的时候，从左到a[i]求LIS；选择向右的时候，从结尾到a[i]求LIS
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;

int n;
int a[N],f[N];

int main() {
  int T;
  scanf("%d",&T);
  while(T--) {
    scanf("%d",&n);
    for(int i = 1; i <= n; i++) scanf("%d",&a[i]);

    //先正向求解LIS问题
    int res = 0;
    for(int i = 1; i <= n; i++) {
      f[i] = 1;
      for(int j = 1; j< i; j++) {
        if(a[i] > a[j]){
          f[i] = max(f[i],f[j]+1);
        }
      }
      res = max(res,f[i]);
    }

    // 反向求解LIS问题
    for(int i = n; i ; i--) {
      f[i] = 1;
      for(int j = n; j > i; j--) {
        if(a[i] > a[j]) {
          f[i] = max(f[i],f[j] + 1);
        }
      }
      res = max(res, f[i]);
    }

    printf("%d\n",res);
  }
  return 0;
}
```



**[题目：AcWing 1014. 登山  ](https://www.acwing.com/problem/content/1016/)**

#### 2.2 登山

**题目描述**

五一到了，ACM队组织大家去登山观光，队员们发现山上一共有N个景点，并且决定按照顺序来浏览这些景点，即每次所浏览景点的编号都要大于前一个浏览景点的编号。

同时队员们还有另一个登山习惯，就是不连续浏览海拔相同的两个景点，并且一旦开始下山，就不再向上走了。

队员们希望在满足上面条件的同时，尽可能多的浏览景点，你能帮他们找出最多可能浏览的景点数么？

**输入格式**

第一行包含整数N，表示景点数量。

第二行包含N个整数，表示每个景点的海拔。

**输出格式**

输出一个整数，表示最多能浏览的景点数。

**数据范围**

$2≤N≤1000$

**输入样例：**

```c
8
186 186 150 200 160 130 197 220
```

**输出样例：**

```c
4
```

**题解：**

``` c
条件1：按照编号递增的顺序来浏览，也就是必须是子序列
条件2：相邻两个景点不能相同
条件3：一旦开始下降，就不能上升了
形状：先严格单调上升，后单调下降的路线(存在一个峰值a[k])
目标：求最多能浏览多少景点
目标：所有形状是上面这种子序列长度的最大值
    
    
集合划分：以 a[1],a[2],a[3],a[4]..a[k]..a[n-1],a[n] 这些点为峰值
    左边以a[k]为结尾的最长上升子序列，记为f[i]，右边以a[k]为开始到结尾的最长下降子序列,记为g[i]
    最后的答案f[k]+g[k]-1（中间的a[k]算了两次）
    
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 1010;
int n;
int a[N],f[N],g[N];

int main() {
  scanf("%d",&n);
  for(int i = 1; i <= n; i++) scanf("%d",&a[i]);

  for(int i = 1; i <= n; i++) {
    f[i] = 1;
    for(int j = 1; j < i; j++){
      if(a[j] < a[i]) {
        f[i] = max(f[i],f[j]+1);
      }
    }
  } 

  for(int i = n; i ; i--) {
    g[i] = 1;
    for(int j = n; j > i; j--) {
      if(a[j] < a[i]) {
        g[i] = max(g[i],g[j]+1);
      }
    }
  }

  int res = 0;
  for(int i = 1; i <= n; i++) res = max(res, f[i]+g[i]-1);
  printf("%d",res);
  return 0;
}
```



**[题目：AcWing 482. 合唱队形  ](https://www.acwing.com/problem/content/484/)**

#### 2.3 合唱队形

**题目描述**

$N$ 位同学站成一排，音乐老师要请其中的$(N−K)$位同学出列，使得剩下的 $K$位同学排成合唱队形。     

合唱队形是指这样的一种队形：设 $K$ 位同学从左到右依次编号为 $1，2…，K$，他们的身高分别为$T_1，T_2，…，T_K$，  则他们的身高满足 $T_1<…< T_i >T_{i+1}>…> T_K (1≤i≤K)$。     

你的任务是，已知所有 $N$ 位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。

**输入格式**

输入的第一行是一个整数 $N$，表示同学的总数。

第二行有 $N$ 个整数，用空格分隔，第 i 个整数 $T_i$是第 $i$ 位同学的身高(厘米)。

**输出格式**

输出包括一行，这一行只包含一个整数，就是最少需要几位同学出列。

**数据范围**

$2≤N≤100$,
$130≤Ti≤230$

**输入样例：**

```c
8
186 186 150 200 160 130 197 220
```

**输出样例：**

```c
4
```

**题解：**

``` c
同登山
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 110;
int n;
int a[N],f[N],g[N];

int main() {
  scanf("%d",&n);
  for(int i = 1; i <= n; i++) scanf("%d",&a[i]);

  for(int i = 1; i <= n; i++) {
    f[i] = 1;
    for(int j = 1; j < i; j++){
      if(a[j] < a[i]) {
        f[i] = max(f[i],f[j]+1);
      }
    }
  } 

  for(int i = n; i ; i--) {
    g[i] = 1;
    for(int j = n; j > i; j--) {
      if(a[j] < a[i]) {
        g[i] = max(g[i],g[j]+1);
      }
    }
  }

  int res = 0;
  for(int i = 1; i <= n; i++) res = max(res, f[i]+g[i]-1);
  printf("%d",n-res);
  return 0;
}
```



**[题目：AcWing 1012. 友好城市  ](https://www.acwing.com/problem/content/1014/)**

#### 2.4 友好城市（问题转化？）

**题目描述**

Palmia国有一条横贯东西的大河，河有笔直的南北两岸，岸上各有位置各不相同的N个城市。

北岸的每个城市有且仅有一个友好城市在南岸，而且不同城市的友好城市不相同。

每对友好城市都向政府申请在河上开辟一条直线航道连接两个城市，但是由于河上雾太大，政府决定避免任意两条航道交叉，以避免事故。

编程帮助政府做出一些批准和拒绝申请的决定，使得在保证任意两条航线不相交的情况下，被批准的申请尽量多。

**输入格式**

第1行，一个整数N，表示城市数。

第2行到第n+1行，每行两个整数，中间用1个空格隔开，分别表示南岸和北岸的一对友好城市的坐标。

**输出格式**

仅一行，输出一个整数，表示政府所能批准的最多申请数。

**数据范围**

$1≤N≤5000$,
$0≤x_i≤10000$

**输入样例：**

```c
7
22 4
2 6
10 3
15 12
9 8
17 17
4 2
```

**输出样例：**

```c
4
```

**题解：**

``` c
条件1：每个城市上只能建立一座桥
条件2：所有的桥与桥之间不能相交
目标：最多可以建多少桥
    
集合1：所有合法的建桥方式
集合2：上升子序列
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;
typedef pair<int,int> PII;
const int N = 5010;

int n;
PII q[N];
int f[N];

int main() {
  scanf("%d",&n);
  for(int i = 0; i < n; i++) scanf("%d%d",&q[i].first,&q[i].second);
  sort(q,q+n);

  int res = 0;
  for(int i = 0; i < n; i++) {
    f[i] = 1;
    for(int j = 0; j < i; j++) {
      if(q[i].second > q[j].second) {
        f[i] = max(f[i], f[j]+1);
      }
    }
    res = max(res,f[i]);
  }
  printf("%d\n",res);
  return 0;
}
```



**[题目：AcWing 1016. 最大上升子序列和   ](https://www.acwing.com/problem/content/1018/)**

#### 2.5 最大上升子序列和 

**题目描述**

一个数的序列 $b_i$，当 $b_1<b_2<…<b_S$ 的时候，我们称这个序列是上升的。

对于给定的一个序列$(a_1,a_2,…,a_N)$，我们可以得到一些上升的子序列$(a_{i1},a_{i2},…,a_{iK})$，这里$1≤i_1<i_2<…<i_K≤N$。

比如，对于序列$(1,7,3,5,9,4,8)$，有它的一些上升子序列，如$(1,7),(3,4,8)$等等。

这些子序列中和最大为$18$，为子序列$(1,3,5,9)$的和。

你的任务，就是对于给定的序列，求出最大上升子序列和。

注意，最长的上升子序列的和不一定是最大的，比如序列$(100,1,2,3)$的最大上升子序列和为$100$，而最长上升子序列为$(1,2,3)$。

**输入格式**

输入的第一行是序列的长度$N$。

第二行给出序列中的$N$个整数，这些整数的取值范围都在$0$到$10000$(可能重复)。

**输出格式**

输出一个整数，表示最大上升子序列和。

**数据范围**

$1≤N≤1000$

**输入样例：**

```c
7
1 7 3 5 9 4 8
```

**输出样例：**

```c
18
```

**题解：**

``` c
DP
    (1)状态表示f[i]
    1)集合表示：所有以a[i]结尾的上升子序列
    2)属性:和的最大值
    
    (2)状态计算
        集合划分：
        最后一个以 ：空,a[1],a[2].....a[i-1] 结尾
        倒数第2个数是a[k],最后一个是a[i]，则求最大值 max(所有以k结尾的最长上升子序列，也就是f[k])+a[i]
        只要a[k] < a[i]就满足
        
```

**代码：**

```c
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int n;
int a[N],f[N];

int main() {
  scanf("%d",&n);
  for(int i = 1; i <= n; i++) scanf("%d",&a[i]);

  int res = 0;
  for(int i = 1; i <= n; i++) {
    f[i] = a[i];
    for(int j = 1; j < i; j++) {
      if(a[j] < a[i]) {
        f[i] = max(f[i],f[j]+a[i]);
      }
    }
    res = max(res,f[i]);
  }
  printf("%d",res);
  return 0;
}
```



**[题目：AcWing 1017. 怪盗基德的滑翔翼  ](https://www.acwing.com/activity/content/problem/content/1259/)**

#### 2.6 怪盗基德的滑翔翼

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```



**[题目：AcWing 1017. 怪盗基德的滑翔翼  ](https://www.acwing.com/activity/content/problem/content/1259/)**

#### 2.7 怪盗基德的滑翔翼

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```



**[题目：AcWing 1017. 怪盗基德的滑翔翼  ](https://www.acwing.com/activity/content/problem/content/1259/)**

#### 2.8 怪盗基德的滑翔翼

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```



**[题目：AcWing 1017. 怪盗基德的滑翔翼  ](https://www.acwing.com/activity/content/problem/content/1259/)**

#### 2.9  怪盗基德的滑翔翼

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```





## 二、搜索

### 1、BFS

应用：

①最短距离

②最小步数

特点：

①求最小，最短

②基于迭代的思想，不会爆栈

#### (1) Flood Fill

**在线性时间复杂度里面，找到某个点所在的连通块**

#### Acwing 池塘计数（八连通BFS）

**[题目：AcWing1097. 池塘计数]()**

**题目描述**

农夫约翰有一片 N∗M 的矩形土地。

最近，由于降雨的原因，部分土地被水淹没了。

现在用一个字符矩阵来表示他的土地。

每个单元格内，如果包含雨水，则用”W”表示，如果不含雨水，则用”.”表示。

现在，约翰想知道他的土地中形成了多少片池塘。

每组相连的积水单元格集合可以看作是一片池塘。

每个单元格视为与其上、下、左、右、左上、右上、左下、右下八个邻近单元格相连。

请你输出共有多少片池塘，即矩阵中共有多少片相连的”W”块。

**输入格式**

第一行包含两个整数 N 和 M。

接下来 N行，每行包含 M个字符，字符为”W”或”.”，用以表示矩形土地的积水状况，字符之间没有空格。

**输出格式**

输出一个整数，表示池塘数目。

**数据范围**

1≤N,M≤1000	

**输入样例：**

```c
10 12
W........WW.
.WWW.....WWW
....WW...WW.
.........WW.
.........W..
..W......W..
.W.W.....WW.
W.W.W.....W.
.W.W......W.
..W.......W.
```

**输出样例：**

```c
3
```

**题解：**

``` c

```

**代码：**

```c
#include <cstring>
#include <iostream>
#include <algorithm>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 1010, M = N * N;

int n, m;
char g[N][N];
PII q[M];
bool st[N][N];	//bfs很多时候都需要开标记数组

void bfs(int sx, int sy)
{
    int hh = 0, tt = 0;
    q[0] = {sx, sy};
    st[sx][sy] = true;

    while (hh <= tt)
    {
        PII t = q[hh ++ ];

        for (int i = t.x - 1; i <= t.x + 1; i ++ )
            for (int j = t.y - 1; j <= t.y + 1; j ++ )
            {
                if (i == t.x && j == t.y) continue;
                //判重，越界，撞墙
                if (i < 0 || i >= n || j < 0 || j >= m) continue;
                if (g[i][j] == '.' || st[i][j]) continue;
                q[ ++ tt] = {i, j};
                st[i][j] = true;
            }
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 0; i < n; i ++ ) scanf("%s", g[i]);

    int cnt = 0;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < m; j ++ )
            if (g[i][j] == 'W' && !st[i][j])
            {
                bfs(i, j);
                cnt ++ ;
            }

    printf("%d\n", cnt);

    return 0;
}
```

#### Acwing1106 山峰和山谷            

**[题目：AcWing1106 山峰和山谷 ]()**

**题目描述**

FGD小朋友特别喜欢爬山，在爬山的时候他就在研究山峰和山谷。

为了能够对旅程有一个安排，他想知道山峰和山谷的数量。

给定一个地图，为FGD想要旅行的区域，地图被分为 *n*×*n*的网格，每个格子 (*i*,*j*) 的高度 *w*(*i*,*j*)是给定的。

若两个格子有公共顶点，那么它们就是相邻的格子，如与 $(i,j)$

 相邻的格子有$(i−1,j−1),(i−1,j),(i−1,j+1),(i,j−1),(i,j+1),(i+1,j−1),(i+1,j),(i+1,j+1)$。

我们定义一个格子的集合 *S*为山峰（山谷）当且仅当：

1、*S*的所有格子都有相同的高度。

 2、*S* 的所有格子都连通。

3、对于 *s*属于 *S*，与 *s* 相邻的 *s*′ 不属于 *S*，都有 $w_s>w_s′$（山峰），或者 $w_s<w_s′$（山谷）。

4、如果周围不存在相邻区域，则同时将其视为山峰和山谷。

你的任务是，对于给定的地图，求出山峰和山谷的数量，如果所有格子都有相同的高度，那么整个地图即是山峰，又是山谷。

**输入格式**

第一行包含一个正整数 *n*，表示地图的大小。

接下来一个 *n*×*n* 的矩阵，表示地图上每个格子的高度 *w*。

**输出格式**

共一行，包含两个整数，表示山峰和山谷的数量。

**数据范围**

$1≤n≤1000$,
 $0≤w≤10^9$

**输入样例：**

```c
5
8 8 8 7 7
7 7 8 8 7
7 7 7 7 7
7 8 8 7 8
7 8 8 8 8
```

**输出样例：**

```c
2 1
```

**题解：**

``` c

```

**代码：**

```c
#include <cstring>
#include <iostream>
#include <algorithm>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 1010, M = N * N;

int n;
int h[N][N];
PII q[M];
bool st[N][N];

void bfs(int sx, int sy, bool& has_higher, bool& has_lower)
{
    int hh = 0, tt = 0;
    q[0] = {sx, sy};
    st[sx][sy] = true;

    while (hh <= tt)
    {
        PII t = q[hh ++ ];

        for (int i = t.x - 1; i <= t.x + 1; i ++ )
            for (int j = t.y - 1; j <= t.y + 1; j ++ )
            {
            	//遍历八个方向 
                if (i == t.x && j == t.y) continue;
                if (i < 0 || i >= n || j < 0 || j >= n) continue; //越界 
                if (h[i][j] != h[t.x][t.y]) // 山脉的边界(不相同的高度)
                {
                	//高 
                    if (h[i][j] > h[t.x][t.y]) has_higher  = true;
                    else has_lower = true; //山谷 
                }
                else if (!st[i][j])  //没有访问过 
                {
                    q[ ++ tt] = {i, j};
                    st[i][j] = true;
                }
            }
    }
}

int main()
{
    scanf("%d", &n);

    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            scanf("%d", &h[i][j]);

    int peak = 0, valley = 0;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            if (!st[i][j])
            {
                bool has_higher = false, has_lower = false;
                bfs(i, j, has_higher, has_lower);
                if (!has_higher) peak ++ ;
                //这里不用加else if 
                if (!has_lower) valley ++ ;
            }

    printf("%d %d\n", peak, valley);

    return 0;
}
```



### 2、

## 四、高级数据结构

### 1、并查集



### 2、树状数组



### 3、线段树

#### (1) pushup

####  3.1 AcWing 1275.最大数    

**[题目：AcWing 1275.最大数   ]()**

**题目描述**

给定一个正整数数列 $a_1,a_2,…,a_n$，每一个数都在 `0∼p−1`之间。

可以对这列数进行两种操作：

1. 添加操作：向序列后添加一个数，序列长度变成 `n+1`；
2. 询问操作：询问这个序列中最后 `L`个数中最大的数是多少。

程序运行的最开始，整数序列为空。

一共要对整数序列进行 `m`次操作。

写一个程序，读入操作的序列，并输出询问操作的答案。

**输入格式**

第一行有两个正整数 `m,p`，意义如题目描述；

接下来 `m`行，每一行表示一个操作。

如果该行的内容是 `Q L`，则表示这个操作是询问序列中最后 `L` 个数的最大数是多少；

如果是 `A t`，则表示向序列后面加一个数，加入的数是`(t+a) mod p`。其中，`t` 是输入的参数，`a`是在这个添加操作之前最后一个询问操作的答案（如果之前没有询问操作，则 `a=0`）。

第一个操作一定是添加操作。对于询问操作，`L>0` 且不超过当前序列的长度。

**输出格式**

对于每一个询问操作，输出一行。该行只有一个数，即序列中最后 `L`个数的最大数。

**数据范围**

$1≤m≤2×10^5$,
$1≤p≤2×10^9$,
$0≤t<p$

**输入样例：**

```
10 100
A 97
Q 1
Q 1
A 17
Q 2
A 63
Q 1
Q 1
Q 3
A 99
```

**输出样例：**

```
97
97
97
60
60
97
```

**样例解释**

最后的序列是 97,14,60,96。

**c++代码实现：**

```
线段树
1.线段树的每个节点都代表一个区间。
2.线段树具有唯一的根结点，代表的区间是整个统计范围，如[1,N]。
3.线段树的每个叶结点都代表一个长度为1的元区间[x,x]。
4.对于每个内部结点[l,r],他的左子结点是[l,mid],右子结点是[mid十1,r],其中mid=(l+r)>>1

线段树Tip
1.线段树是一棵非常漂亮二叉树，(除了最后一层外，是一棵满二叉树)，因此我们采用堆的思想来存整棵树
(1) 编号x的父节点：x/2 , 常书写的代码：x>>1
(2) 编号x的左儿子：2x , 常书写的代码：x<<1
(3) 编号x的右儿子：2x十1，常书写的代码：×<<1|1
2线段的下一层都是把当前层进行平分mid=L l+r>>1」
(1) 左区间为[l，mid]
(2) 右区间为[mid+1,r]
注意，线段树的两个子区间是不允许相交的,这也决定了许多题的分块要进行额外的操作，使之区间不能相交
3.线段树一般开长度为4N的空间
(1) 一个长度为N的区间，最终的叶结点，为N个
(2) 先考虑理想状态下(包含最后一层，整个二叉树都是满二叉树)，N个叶结点的满二叉树有
N+N/2+N/4+.....+2+1=2N-1个结点
(3) 但是线段树的存储方式下，最后一层还会有盈余，最坏情况下，最后一层是倒数第二层（也就是满二叉树的倒数第一层）两倍的点，所以所以保存线段树的数组长度要不小于4N才能保证不会越界

线段树的模版
1,pushup（）:由子结点的信息来计算父结点的信息
2.bui1d（）:将一段区间初始化为线段树
3.modify（）:修改
(1) 单点修改(easy)
(2) 区间修改(hard)：用到pushdown操作，懒标记思想
4.query（）:区间询问(例如：查间[a,b]区间)O(1ogn)最多是4logn的时间，因为最坏有两条链
```

![image-20230315164557036](../../../zky/Coding/Coderwhy/pic/image-20230315164557036.png)

![image-20230315164624686](../../../zky/Coding/Coderwhy/pic/image-20230315164624686.png)

![image-20230315164641441](../../../zky/Coding/Coderwhy/pic/image-20230315164641441.png)

```c
#include <cstdio>
#include <algorithm>
#include <string>
#include <iostream>

#define ac cin.tie(0), cin.sync_with_stdio(0);
#define endl "\n"

using namespace std;

const int N = 2e5+10;

int m,p;

struct Node{
    int l,r;
    int v;  //携带的信息，这里是[l,r]区间的最大值
}tr[N*4];

//pushup操作，由子节点的信息，来计算父节点的信息
void pushup(int u){
    tr[u].v=max(tr[u<<1].v,tr[u<<1|1].v);
}

//build的时候先赋值避免忘记
void build(int u,int l,int r){
    // tr[u]={l,r};
    tr[u].l=l,tr[u].r=r;    //节点u代表区间[l,r]
    if(l==r) return;    //是叶子节点
    int mid=l+r>>1;
    build(u<<1,l,mid),build(u<<1|1,mid+1,r);
}

int query(int u,int l,int r){
    if(tr[u].l>=l && tr[u].r<=r) return tr[u].v;    //查询在区间[l,r]的最大值，包含当前的节点u，则直接回溯返回当前点的值
    int mid=tr[u].l+tr[u].r>>1;
    int v=0;
    // if(l<=mid) v=max(v,query(u<<1,l,r));
    if(l<=mid) v=query(u<<1,l,r);
    if(r>mid) v=max(v,query(u<<1|1,l,r));
    // else v=max(v,query(u<<1|1,l,r));
    return v;
}

void modify(int u,int x,int v){
    if(tr[u].l==x && tr[u].r==x) tr[u].v=v;
    else{
        int mid=tr[u].l+tr[u].r>>1;
        if(x<=mid) modify(u<<1,x,v);
        else modify(u<<1|1,x,v);
        pushup(u);
    }
}

int main(){
    int n=0,last=0;   //last记录题目中所说的上次查询的结果a
    scanf("%d%d",&m,&p);
    build(1,1,m);
    
    int x;
    char op[2];
    while(m--){
        scanf("%s%d",op,&x);
        if(*op=='Q'){
            last=query(1,n-x+1,n);
            printf("%d\n",last);
        }else{
            modify(1,n+1,((long long)last+x)%p);
            n++;
        }
    }
    return 0;
}
```

Q:线段树建树build操作的时候，什么时候需要加pushup，什么时候不加pushup

A：在线段树的建树过程中，通常需要执行pushup操作来更新父节点的信息，以确保它的信息与子节点保持一致。pushup操作的时机取决于当前节点的性质以及子节点的性质，具体情况如下：

1. 对于区间修改操作（如单点修改、区间加、区间赋值等），因为修改操作会改变子节点的值，所以在递归调用build函数时需要先对子节点进行更新，再对父节点进行pushup操作。
2. 对于区间查询操作，因为查询操作只需要使用子节点的信息计算父节点的信息，而不需要修改子节点的信息，所以在递归调用build函数时不需要进行pushup操作。
3. 对于区间合并操作（如区间求和、区间最大值、区间最小值等），由于子节点的信息可以通过简单的合并得到父节点的信息，因此在递归调用build函数时需要先对子节点进行更新，再对父节点进行pushup操作。

总之，需要加pushup的情况是在对子节点进行更新之后，需要确保父节点的信息与子节点保持一致。不需要加pushup的情况是在不需要修改子节点的信息的情况下进行递归调用。

[推荐博客](https://www.cnblogs.com/zheyuanxie/archive/2022/08/09/segment-tree.html)

​        

#### 3.2 AcWing 245. 你能回答这些问题吗      

**[题目：AcWing 245. 你能回答这些问题吗  ]()**

**题目描述**

给定长度为 *N* 的数列 *A*，以及 *M*

 条指令，每条指令可能是以下两种之一：

1. `1 x y`，查询区间 [*x*,*y*]中的最大连续子段和，即$ max_{x≤l≤r≤y}{∑_{i=l}^rA[i]}$。

2. `2 x y`，把 *A*[*x*]改成 *y*

对于每个查询指令，输出一个整数表示答案。

**输入格式**

第一行两个整数 *N*,*M*。

第二行 *N*个整数 *A*[*i*]。

接下来 *M*行每行 3 个整数 *k*,*x*,*y*，*k*=1 表示查询（此时如果 *x*>*y*，请交换 *x*,*y*），*k*=2 表示修改。

**输出格式**

对于每个查询指令输出一个整数表示答案。

每个答案占一行。

**数据范围**

$N≤500000≤M≤100000$,
 $−1000≤A[i]≤1000$,

**输入样例：**

```r
5 3
1 2 -3 4 5
1 2 3
2 2 -1
1 3 2
```

**输出样例：**

```
2
-1
```

**题解：**

``` c
struct Node{
  int l,r;  //区间左右端点
  int sum; //区间和
  int lmax; //最大前缀和
  int rmax; //最大后缀和
  int tmax; //最大连续子段和
  //横跨左右子区间的最大子段和 = 左子区间的最大后缀 + 右子区间的最大前缀
}tr[N*4];

void pushup(Node& u,Node& l,Node& r){
  u.sum=l.sum+r.sum;  //区间和=左区间和+右区间和
  //最大前缀和:左儿子的前缀和（只有左儿子前缀）、左儿子区间和+右儿子的前缀和（覆盖到右儿子）
  u.lmax=max(l.lmax,l.sum+r.lmax);  
  //最大后缀和:右儿子的后缀和（只有右儿子后缀）、左儿子后缀+右儿子的区间和（覆盖到右儿子）
  u.rmax=max(r.rmax,l.rmax+r.sum);  
  //当只有左边或者右边儿子、跨越两个区间左儿子取后缀右儿子取前缀
  u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}
```

**代码：**

```c
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <iostream>

using namespace std;
const int N = 5e5+10;
int w[N];
int n,m;

struct Node{
  int l,r;  //区间左右端点
  int sum; //区间和
  int lmax; //最大前缀和
  int rmax; //最大后缀和
  int tmax; //最大连续子段和
  //横跨左右子区间的最大子段和 = 左子区间的最大后缀 + 右子区间的最大前缀
}tr[N*4];

void pushup(Node& u,Node& l,Node& r){
  u.sum=l.sum+r.sum;  //区间和=左区间和+右区间和
  //最大前缀和:左儿子的前缀和（只有左儿子前缀）、左儿子区间和+右儿子的前缀和（覆盖到右儿子）
  u.lmax=max(l.lmax,l.sum+r.lmax);  
  //最大后缀和:右儿子的后缀和（只有右儿子后缀）、左儿子后缀+右儿子的区间和（覆盖到右儿子）
  u.rmax=max(r.rmax,l.rmax+r.sum);  
  //当只有左边或者右边儿子、跨越两个区间左儿子取后缀右儿子取前缀
  u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u){
  pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r){
  tr[u].l=l,tr[u].r=r;	//	容易忘记写在else里面导致段错误
  //如果是叶子节点
  if(l==r){
    tr[u].sum=w[l];
    tr[u].lmax=w[l];
    tr[u].rmax=w[l];
    tr[u].tmax=w[l];
  }else{
    int mid=l+r>>1;
    build(u<<1,l,mid);
    build(u<<1|1,mid+1,r);
    pushup(u);
  }
}

void modify(int u,int x,int v){
  if(tr[u].l==x && tr[u].r==x){
    tr[u].l=x, tr[u].r=x, tr[u].sum=v, tr[u].lmax=v, tr[u].rmax=v, tr[u].tmax=v;
  }else{
    int mid=tr[u].l + tr[u].r>>1;
    if(x<=mid) modify(u<<1,x,v);
    else modify(u<<1|1,x,v);
    pushup(u);
  }
}

Node query(int u,int l,int r){
  if(tr[u].l>=l && tr[u].r<=r) return tr[u];
  else{
    int mid=tr[u].l+tr[u].r>>1;
    /*
    1、在左区间  r<=mid
    2、在右区间  l>mid
    3、左区间+右区间
    */
    if(r<=mid) return query(u<<1,l,r);
    else if(l>mid) return query(u<<1|1,l,r);
    else{
      Node left=query(u<<1,l,r);
      Node right=query(u<<1|1,l,r);
      Node res;
      pushup(res,left,right);
      return res;
    }
  }
}

int main()
{
  scanf("%d%d",&n,&m);
  //数组下标从1开始
  for(int i=1;i<=n;i++) scanf("%d",&w[i]);
  build(1,1,n);
  
  int k,x,y;
  while(m--){
    scanf("%d%d%d",&k,&x,&y);
    if(k==1){
      if(x>y) swap(x,y);
      printf("%d\n",query(1,x,y).tmax);
    }else modify(1,x,y);
  }
  return 0;
}
```



#### 3.3 AcWing 246. 区间最大公约数   (todo)

**[题目：246. 区间最大公约数 ]()**

**题目描述**

给定一个长度为 *N* 的数列 *A*，以及 *M* 条指令，每条指令可能是以下两种之一：

1、`C l r d`，表示把 $A[l]$,$A[l+1]$,…,$A[r]$都加上 $d$。

2、`Q l r`，表示询问 $A[l]$,$A[l+1]$,…,$A[r]$的最大公约数(GCD）

对于每个询问，输出一个整数表示答案。

**输入格式**

第一行两个整数 *N*,*M*。

第二行 *N*个整数 *A*[*i*]。

接下来 *M*行表示 *M* 条指令，每条指令的格式如题目描述所示。

**输出格式**

对于每个询问，输出一个整数表示答案。

每个答案占一行。

**数据范围**

$N≤500000,M≤100000$,
$1≤A[i]≤10^{18}$,
 $|d|≤10^{18}$

**输入样例：**

```r
5 5
1 3 5 7 9
Q 1 5
C 1 5 1
Q 1 5
C 3 3 6
Q 2 4
```

**输出样例：**

```
1
2
4
```

**题解：**

``` c
怎么将求解一个区间的操作转化为只对某一个点
最大公约数左边等于右边：
(x,y,z)= (x,y-x,z-y)    
(a1, a2, .....an) <= (a, a2-a1, a3-a2, ....an-an-1)
(a1, a2, .....an) >= (a, a2-a1, a3-a2, ....an-an-1)
(a1, a2, .....an) = (a, a2-a1, a3-a2, ....an-an-1) = d  
    
求[l,r]的最大公约数：
gcd(a[l], gcd{b[l+1]~b[r]})
    
用差分来存sum和gcd
```

**代码：**

```c
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 500010;

int n, m;
LL w[N];
struct Node
{
    int l, r;
    LL sum, d;
}tr[N * 4];

LL gcd(LL a, LL b)
{
    return b ? gcd(b, a % b) : a;
}

void pushup(Node &u, Node &l, Node &r)
{
    u.sum = l.sum + r.sum;
    u.d = gcd(l.d, r.d);
}

void pushup(int u)
{
    pushup(tr[u], tr[u << 1], tr[u << 1 | 1]);
}

void build(int u, int l, int r)
{
    if (l == r)
    {
        LL b = w[r] - w[r - 1];
        tr[u] = {l, r, b, b};
    }
    else
    {
        tr[u].l = l, tr[u].r = r;
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
}

void modify(int u, int x, LL v)
{
    if (tr[u].l == x && tr[u].r == x)
    {
        LL b = tr[u].sum + v;
        tr[u] = {x, x, b, b};
    }
    else
    {
        int mid = tr[u].l + tr[u].r >> 1;
        if (x <= mid) modify(u << 1, x, v);
        else modify(u << 1 | 1, x, v);
        pushup(u);
    }
}

Node query(int u, int l, int r)
{
    if (tr[u].l >= l && tr[u].r <= r) return tr[u];
    else
    {
        int mid = tr[u].l + tr[u].r >> 1;
        if (r <= mid) return query(u << 1, l, r);
        else if (l > mid) return query(u << 1 | 1, l, r);
        else
        {
            auto left = query(u << 1, l, r);
            auto right = query(u << 1 | 1, l, r);
            Node res;
            pushup(res, left, right);
            return res;
        }
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) scanf("%lld", &w[i]);
    build(1, 1, n);

    int l, r;
    LL d;
    char op[2];
    while (m -- )
    {
        scanf("%s%d%d", op, &l, &r);
        if (*op == 'Q')
        {
            auto left = query(1, 1, l);
            Node right({0, 0, 0, 0});
            if (l + 1 <= r) right = query(1, l + 1, r);
            printf("%lld\n", abs(gcd(left.sum, right.d)));
        }
        else
        {
            scanf("%lld", &d);
            modify(1, l, d);
            if (r + 1 <= n) modify(1, r + 1, -d);
        }
    }

    return 0;
}
```



#### (2) 赖标记、pushdown

单点修改一般pushup操作就够了

区间修改则需要懒标记-pushdown，思想来源于区间查询

```c
1、修改操作
信息：
    （1）sum:当前区间的总和
    （2）add懒标记，给以当前节点为根的子树中的每个节点，加上add(不包含根节点)
        当前的操作到该根节点之后就不在传播了，直接返回
        
2、查询操作
     查询某一段区间的时候，如果用到的某一个值被add懒标记过了，则需要找到该子节点的父节点，一开始加add懒标记的节点，再将祖宗的root所有的add操作累加到所求点位置，那么可以找到祖宗root节点，每次递归左右儿子加add懒标记，每次懒标记之后清空当前的add懒标记，一直pushdown向下。
     假设祖宗节点root被add懒标记了，root.add
     pushdown操作：
     left.add += root.add;
	 left.sum +=(left.R-left.R+1)*root.add	//	左儿子总和=左边节点个数*add
     right.add += root.add;
     right.sum +=(right.R-right.R+1)*root.add	//	左儿子总和=左边节点个数*add
     root.add = 0  //清空懒标记
```

[推荐](https://leetcode.cn/problems/my-calendar-i/solution/by-ac_oier-hnjl/?orderBy=hot)

#### 3.4  Acwing243. 一个简单的整数问题2             

**[题目：243. 一个简单的整数问题2 ]()**

**题目描述**

给定一个长度为 $N$ 的数列 $A$，以及 $M$条指令，每条指令可能是以下两种之一：

1. `C l r d`，表示把 $A[l]$,$A[l+1]$,…,$A[r]$都加上 $d$。

​    2.`Q l r`，表示询问数列中第 `l∼r`个数的和。

对于每个询问，输出一个整数表示答案。

**输入格式**

第一行两个整数 *N*,*M*。

第二行 *N*个整数 *A*[*i*]。

接下来 *M*行表示 *M* 条指令，每条指令的格式如题目描述所示。

**输出格式**

对于每个询问，输出一个整数表示答案。

每个答案占一行。

**数据范围**

$1≤N,M≤10^5$,
 $|d|≤10000$,
 $|A[i]|≤10^9$,

**输入样例：**

```r
10 5
1 2 3 4 5 6 7 8 9 10
Q 4 4
Q 1 10
Q 2 4
C 3 6 3
Q 2 4
```

**输出样例：**

```
4
55
9
15
```

**题解：**

``` c
维护:
    sum : 如果只考虑当前节点及子节点上的所有标记，当前区间和是多少（没有考虑所有祖先节点上的标记，只考虑当前点及儿子）
    add : 给当前区间的所有儿子加上add
```

**代码：**

```c
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <iostream>
typedef long long LL;
using namespace std;
const int N = 1e5+5;
int w[N];
int n,m;

struct Node{
  int l,r;  //左右区间
  LL sum,add;  //区间里面的总和，以及懒标记
}tr[N*4];

void pushup(int u){
  tr[u].sum = tr[u<<1].sum + tr[u<<1|1].sum;
}

void pushdown(int u){
  auto& root=tr[u],&left=tr[u<<1],&right=tr[u<<1|1];
  //如果存在懒标记
  if(root.add){
    left.add+=root.add, left.sum+=(LL)(left.r-left.l+1)*root.add;
    right.add+=root.add,right.sum+=(LL)(right.r-right.l+1)*root.add;
    //将懒标记清除
    root.add=0;
  }
}

void build(int u,int l,int r){
  if(l==r){
    //懒标记刚build的时候0
    tr[u]={l,r,w[r],0};
  }else{
    tr[u]={l,r}; //不加会段错误
    int mid = l+r>>1;
    build(u<<1,l,mid),build(u<<1|1,mid+1,r);
    pushup(u);
  }
}

void modify(int u,int l,int r,int d)
{
  //包含区间
  if(tr[u].l>=l && tr[u].r<=r){
    tr[u].sum+=(LL)(tr[u].r-tr[u].l+1)*d;
    tr[u].add+=d;
  }else{  //需要分裂，可能存在两边的add数值不一致
    pushdown(u);
    int mid=tr[u].l+tr[u].r>>1;
    if(l<=mid) modify(u<<1,l,r,d);
    if(r>mid) modify(u<<1|1,l,r,d);
    pushup(u);
  }
}

LL query(int u,int l,int r){
  if(tr[u].l>=l && tr[u].r<=r) return tr[u].sum;
  
  pushdown(u);
  int mid=tr[u].l+tr[u].r>>1;
  LL sum=0;
  if(l<=mid) sum=query(u<<1,l,r);
  if(r>mid) sum+=query(u<<1|1,l,r);
  return sum;
}

int main()
{
  scanf("%d%d",&n,&m);
  for(int i=1;i<=n;i++) scanf("%d",&w[i]);
  build(1,1,n);
  
  char op[2];
  int l,r,d;
  
  while(m--){
    scanf("%s%d%d",op,&l,&r);
    if(*op=='C'){
      scanf("%d",&d);
      modify(1,l,r,d);
    }else printf("%lld\n",query(1,l,r));
  }
  
  return 0;
}
```



#### 3.5 AcWing 1277. 维护序列                

**[题目：AcWing 1277. 维护序列 ]()**

**题目描述**

老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。

有长为 $N$的数列，不妨设为 $a1,a2,…,a_N$。

有如下三种操作形式：

1. 把数列中的一段数全部乘一个值；
2. 把数列中的一段数全部加一个值；
3. 询问数列中的一段数的和，由于答案可能很大，你只需输出这个数模 $P$的值。

**输入格式**

第一行两个整数 $N$和 $P$；

第二行含有 $N$个非负整数，从左到右依次为 $a1,a2,…,a_N$；

第三行有一个整数 $M$，表示操作总数；

从第四行开始每行描述一个操作，输入的操作有以下三种形式：

- 操作 1：`1 t g c`，表示把所有满足 $t≤i≤g$ 的 $a_i$ 改为 $a_i×c$；
- 操作 2：`2 t g c`，表示把所有满足 $t≤i≤g$ 的 $a_i$ 改为 $a_i$+c；
- 操作 3：`3 t g`，询问所有满足 $t≤i≤g$ 的 $a_i$ 的和模 $P$ 的值。

同一行相邻两数之间用一个空格隔开，每行开头和末尾没有多余空格。

**输出格式**

对每个操作 3，按照它在输入中出现的顺序，依次输出一行一个整数表示询问结果。

**数据范围**

$1≤N,M≤10^5$,
$ 1≤t≤g≤N$,
 $0≤c,a_i≤10^9$,
 $1≤P≤10^9$,

**输入样例：**

```r
7 43
1 2 3 4 5 6 7
5
1 2 5 5
3 2 4
2 3 7 9
3 1 3
3 4 7
```

**输出样例：**

```
2
35
8
```

**样例解释**

初始时数列为 `{1,2,3,4,5,6,7}`；

经过第 1 次操作后，数列为 `{1,10,15,20,25,6,7}`；

对第 2次操作，和为 `10+15+20=45`，模 43 的结果是 2；

经过第 3次操作后，数列为` {1,10,24,29,34,15,16}`；

对第 4次操作，和为` 1+10+24=35`，模 43 的结果是 35；

对第 5次操作，和为` 29+34+15+16=94`，模 43 的结果是 8。

**题解：**

``` c
1、线段树需要记录的信息：
	L，R
	sum,add,mul
	注意：
    	（1）add表示在区间加一个数，mul表示在区间里面乘一个数
    	（2）考虑先加还是先乘法，应该先乘法后加法(能保证操作前后形式统一)，x表示区间里面每个数
    		①加法的时候(将add + add`记为新的add)：
    				(x * mul + add )+ add` = x * mul + add
    			
    		②乘法的时候(将mul * mul`记为新的mul，同时将add * mul`记为新的add)：
    				(x * mul + add )*mul` = x * mul * mul` + add * mul` = x * mul + add
    
2、优化
    x * c + d
    (1)乘c ,等价与 d=0 , x * c + d = x * c
    (2)加d ,等价与 c=1 , x * 1 + d = x + d
综上：
    记ac为新的mul,bc+d为新的add
    (x * a + b) * c + d = x * ac + bc + d = x * mul + add
```

**代码：**

```c
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>

typedef long long ll;
using namespace std;
const int N = 1e5+10;

int n,m,p;
int w[N];

struct Node{
  int l,r;
  int sum,add,mul;
}tr[N*4];

//pushup操作
void pushup(int u)
{
  tr[u].sum = (tr[u<<1].sum + tr[u<<1|1].sum)%p;
}

void eval(Node& u,int add,int mul)
{
  //先乘法后加法，加的是整个区间的=个数*add
  u.sum = ((ll)u.sum*mul + (ll)(u.r-u.l+1)*add)%p;
  //乘法,直接mul
  u.mul = (ll)u.mul*mul % p;
  //加法,加法前需要先mul操作
  u.add = ((ll)u.add*mul + add)%p;
}

//pushdown操作
void pushdown(int u)
{
  eval(tr[u<<1],tr[u].add,tr[u].mul);
  eval(tr[u<<1|1],tr[u].add,tr[u].mul);
  //清空操作
  tr[u].add = 0,tr[u].mul = 1;
}

void build(int u,int l,int r)
{
  if(l==r) tr[u]={l,r,w[l],0,1};
  else{
    //初始sum为0
    tr[u]={l,r,0,0,1};
    int mid=l+r>>1;
    build(u<<1,l,mid),build(u<<1|1,mid+1,r);
    pushup(u);
  }
}

void modify(int u,int l,int r,int add,int mul)
{
  if(tr[u].l>=l && tr[u].r<=r) eval(tr[u],add,mul);
  else{
    pushdown(u);
    int mid = tr[u].l+tr[u].r>>1;
    if(l<=mid) modify(u<<1,l,r,add,mul);
    if(r>mid) modify(u<<1|1,l,r,add,mul);
    pushup(u);
  }
}

int query(int u,int l,int r)
{
  if(tr[u].l>=l && tr[u].r<=r) return tr[u].sum;
  pushdown(u);
  int mid=tr[u].l+tr[u].r>>1;
  int res=0;
  if(l<=mid) res=query(u<<1,l,r);
  if(r>mid) res=(res+query(u<<1|1,l,r))%p;
  return res;
}

int main(){
  scanf("%d%d",&n,&p);
  for(int i=1;i<=n;i++) scanf("%d",&w[i]);
  build(1,1,n);
  
  scanf("%d", &m);
  while (m -- )
  {
    int t, l, r, d;
    scanf("%d%d%d", &t, &l, &r);
    if (t == 1)
    {
      scanf("%d", &d);
      modify(1, l, r, 0, d);
    }
    else if (t == 2)
    {
      scanf("%d", &d);
      modify(1, l, r, d, 1);
    }
    else printf("%d\n", query(1, l, r));
  }
  return 0;
}
```



#### （3）扫描线

#### 3.6 AcWing 247. 亚特兰蒂斯  （todo）          

**[题目：AcWing 247. 亚特兰蒂斯 ]()**

**题目描述**

有几个古希腊书籍中包含了对传说中的亚特兰蒂斯岛的描述。 

其中一些甚至包括岛屿部分地图。 

但不幸的是，这些地图描述了亚特兰蒂斯的不同区域。 

您的朋友 Bill 必须知道地图的总面积。 

你自告奋勇写了一个计算这个总面积的程序。

**输入格式**

输入包含多组测试用例。

对于每组测试用例，第一行包含整数 $n$，表示总的地图数量。

接下来 $n$ 行，描绘了每张地图，每行包含四个数字 $x1,y1,x2,y2$（不一定是整数），$(x1,y1)$ 和 $(x2,y2)$分别是地图的左上角位置和右下角位置。

注意，坐标轴 $x$轴从上向下延伸，$y$轴从左向右延伸。

当输入用例 $n$=0时，表示输入终止，该用例无需处理。

**输出格式**

每组测试用例输出两行。

第一行输出 `Test case #k`，其中 $k$是测试用例的编号，从 1开始。

第二行输出 `Total explored area: a`，其中 *a*是总地图面积（即此测试用例中所有矩形的面积并，注意如果一片区域被多个地图包含，则在计算总面积时只计算一次），精确到小数点后两位数。

在每个测试用例后输出一个空行。

**数据范围**

$1≤n≤10000$,
 $0≤x1<x2≤100000$,
 $0≤y1<y2≤100000$
 注意，本题 $n$ 的范围上限加强至 10000。

**输入样例：**

```r
2
10 10 20 20
15 15 25 25.5
0
```

**输出样例：**

```
Test case #1
Total explored area: 180.00 
```

**样例解释**

样例所示地图覆盖区域如下图所示，两个矩形区域所覆盖的总面积，即为样例的解。

![](https://cdn.acwing.com/media/article/image/2019/12/26/19_4acba44c27-%E6%97%A0%E6%A0%87%E9%A2%98.png)**题解：**

``` c
操作1：
    将某一个区间[L,R]加一个k(K的取值是取决于y轴坐标，如果是左边取+1，右边取-1)
    
操作2：
    求整个区间中长度大于0的区间总长度是多少？
    
线段树中的节点信息：
	（1）cnt：当前区间整个被覆盖的次数是多少
	（2）len：不考虑所有的祖先节点cnt的前提下，cnt>0的区间总长
注意：线段树的节点，永远只向下看
    
    
扫描线：
（1）永远只考虑根节点的信息----查询query时候不需要调用pushdown
（2）所有的操作均是成对出现，且先加后减----modify的时候不需要pushdown
    对于减法，减完之后>0不影响正确性，=0也是不影响准确性
    对于加法，
    ①cnt > 0,如果被矩形覆盖了，就会被计算，无需向下分裂
    ②cnt = 0,pushdown是与否都一样
    
总的就是，修改的时候不用pushdown，不完全标记，如果完全包含区间的话，就在上面加上权值，往下面递归
   pushup注意当前的cnt==0，值是两个儿子的总和 ，如果不是0就是区间长度
```

**[代码](https://www.acwing.com/activity/content/code/content/167934/)**



## 六、基础算法

### 1、位运算、递推与递归

### 2、前缀和、差分、二分

### 3、排序、RMQ	

#### (1) 排序

#### (2) RMQ

$0------------i----------i+2^j-1--------------------n$
		                                          $f[i][j]$                                    $f[i+2^j-1]$

$f[i][j]$：表示从 $i$ 开始长度是 $2^j$ 的区间中,也就是区间 $[i,i+2^j-1]$ 的最大值是多少,也就是从 $i$ 开始的  $2^j$  个数的最大值
该区间一共有 $2^j$ 个数，如果均分为两个部分，则每个部分就是 $2^{j-1}$ 个数，则区间 $ [i,i+2^j-1]$ 变成区间  $[i+2^{j-1}-1]$ 和 $[i+2^{j-1},i+2^j-1]$

i 到 $i+2^j-1$ 中的最大值，可以分为  $f[i][2^{j-1}]+f[i+2^{j-1}][j-1]$
$f[i][j]=max(f[i][j-1],f[i+2^{j-1}][j-1])$

$----L-----------R------$
设 L 到 R 的长度是 len，找到 $2^k<=len <= 2*2^k=2^{k+1}$,也就是找到小于 len 区间长度的 2 的幂次的最大值 k
则L开始的 $2^k$ 个数  和  以 R 为结尾的 $2^k$ 个数 这两段区间一定覆盖整个区间 $[L,R]$ ,这两段最大值分别是$f[L][k]$ 和 $f[R-2^k+1][k]$
两者最大值就是整个区间的最大值，因为求的是最大值，所以就算是有重叠也没有关系
k可以先预处理好 $logk/log2$

缺点：不能修改，是静态的，线段树可以支持动态修改

#### AcWing 1273. 天才的记忆                 

**[题目：AcWing 1273. 天才的记忆 ]()**

**题目描述**

从前有个人名叫 WNB，他有着天才般的记忆力，他珍藏了许多许多的宝藏。

在他离世之后留给后人一个难题（专门考验记忆力的啊！），如果谁能轻松回答出这个问题，便可以继承他的宝藏。

题目是这样的：给你一大串数字（编号为 1到 *N*，大小可不一定哦！），在你看过一遍之后，它便消失在你面前，随后问题就出现了，给你 *M* 个询问，每次询问就给你两个数字 *A*,*B*，要求你瞬间就说出属于 *A* 到 *B*这段区间内的最大数。

一天，一位美丽的姐姐从天上飞过，看到这个问题，感到很有意思（主要是据说那个宝藏里面藏着一种美容水，喝了可以让这美丽的姐姐更加迷人），于是她就竭尽全力想解决这个问题。

但是，她每次都以失败告终，因为这数字的个数是在太多了！

于是她请天才的你帮他解决。如果你帮她解决了这个问题，可是会得到很多甜头的哦！

**输入格式**

第一行一个整数 *N*表示数字的个数。

接下来一行为 *N* 个数，表示数字序列。

第三行读入一个 *M*，表示你看完那串数后需要被提问的次数。

接下来 *M*行，每行都有两个整数 *A*,*B*。

**输出格式**

输出共 *M* 行，每行输出一个数，表示对一个问题的回答。

**数据范围**

$1≤N≤2×10^5$,
 $1≤M≤10^4$,
$ 1≤A≤B≤N$,

**输入样例：**

```r
6
34 1 8 123 3 2
4
1 2
1 5
3 4
2 3
```

**输出样例：**

```
34
123
123
8
```

**解答：**

```
0------------i----------i+2^j-1----------n
		 f[i][j]          f[i+2^j-1]

f[i][j]：表示从i开始长度是2^j的区间中,也就是区间[i,i+2^j-1]的最大值是多少,也就是从i开始的2^j个数的最大值
该区间一共有2^j个数，如果均分为两个部分，则每个部分就是2^{j-1}个数，则区间[i,i+2^j-1]变成区间[i+2^{j-1}-1]和[i+2^{j-1},i+2^j-1]

i到i+2^j-1中的最大值，可以分为f[i][2^{j-1}]+f[i+2^{j-1}][j-1]
f[i][j]=max(f[i][j-1],f[i+2^{j-1}][j-1])

----L-----------R------
设L到R的长度是len，找到2^k<=len <= 2*2^k=2^{k+1},也就是找到小于len区间长度的2的幂次的最大值k
则L开始的2^k个数  和  以R为结尾的2^k个数 这两段区间一定覆盖整个区间[L,R],这两段最大值分别是f[L][k]和f[R-2^k+1][k]
两者最大值就是整个区间的最大值，因为求的是最大值，所以就算是有重叠也没有关系
k可以先预处理好logk/log2

缺点：不能修改，是静态的，线段树可以支持动态修改
```

**代码：**

``` c
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <cmath>

using namespace std;
//j=log2(2*1e5)    65536=2^16   2^17>>int的值了 
const int N = 2e5+10,M =18;

int n,m;
int w[N];
int f[N][M];

void init()
{
	for(int j=0;j<M;j++){
		//右边不能超过终点,2^j-1的长度 
//		for(int i=1;i<=n-(1<<j)+1;j++){
		for(int i=1;i+(1<<j)-1<=n;i++){
			//表示只有一个数，f[i][0]就是[i,i]区间里面最大值
			if(!j) f[i][j]=w[i];
			//两个区间里面的最大值 
			else f[i][j]=max(f[i][j-1],f[i+(1<<(j-1))][j-1]);	 
		}
	}
} 

int query(int l,int r){
	int len=r-l+1; //长度
	int k=log(len)/log(2);
    //L开始的2^k个数  和  以R为结尾的2^k个数 这两段区间一定覆盖整个区间[L,R],这两段最大值分别是f[L][k]和f[R-2^k+1][k]
	return max(f[l][k],f[r-(1<<k)+1][k]); 
} 

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&w[i]);
	//初始化st表 
	init();
	
	scanf("%d",&m);
	while(m--){
		int l,r;
		scanf("%d%d",&l,&r);
		printf("%d\n",query(l,r));
	}	
	return 0;
} 
```







#### 1.2 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```

#### 

#### 1.2 最低通行费

**题目描述**



**输入格式**



**输出格式**



**数据范围**



**输入样例：**

```c

```

**输出样例：**

```c

```

**题解：**

``` c

```

**代码：**

```c

```

#### 



